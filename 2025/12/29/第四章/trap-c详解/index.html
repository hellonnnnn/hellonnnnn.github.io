<!DOCTYPE html>
<html 
	lang="zh-Hans">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> trap.c详解 -  Ivan&#39;s Tech Blog</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://kira.host/assets/Pictures/Others/116359b4ccf19917.jpg"
			type="image/png"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 8.1.1"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('/img/background4.jpg')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="Ivan&#39;s Tech Blog">
        <img
			src="/img/avatar.png"
			alt="Ivan-FYF"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a href="/img/avatar.png" title="Ivan-FYF">
			<img
				src="/img/avatar.png"
				alt="Ivan-FYF"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>30</div>
		<div><span>标签</span>6</div>
		<div><span>分类</span>3</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about/"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2933852809&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/<hellonnnnn>/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/os项目/">
              <img 
                src="/img/background1.jpg" 
                alt="os项目" 
                style="width:20px; height:20px; margin-right:4px; vertical-align: middle;"
              >
              os项目
            </a>
            <span class="category-list-count">28</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/八股/">
              <img 
                src="/img/background3.jpg" 
                alt="八股" 
                style="width:20px; height:20px; margin-right:4px; vertical-align: middle;"
              >
              八股
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/算法/">
              <img 
                src="/img/background2.jpg" 
                alt="算法" 
                style="width:20px; height:20px; margin-right:4px; vertical-align: middle;"
              >
              算法
            </a>
            <span class="category-list-count">1</span>
          </li>
        
      </ul>
    </div>
  </div>


		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%AA%8C%E4%B8%80/" style="font-size: 13.33px;">xv6操作系统项目实验一</a> <a href="/tags/xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%AA%8C%E4%B8%89/" style="font-size: 16.67px;">xv6操作系统项目实验三</a> <a href="/tags/xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%AA%8C%E4%BA%8C/" style="font-size: 16.67px;">xv6操作系统项目实验二</a> <a href="/tags/xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%AA%8C%E5%9B%9B/" style="font-size: 20px;">xv6操作系统项目实验四</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">基础知识</a> <a href="/tags/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/" style="font-size: 10px;">算法训练营</a>

		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			文章归档
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/">2026</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">26</span></li></ul>
		</div>
	</div>


		
	</aside>
	<!-- 保留空的版权容器，修复布局 -->
    	<div class="kira-copyright">
    </div>
</div> <!-- 侧边栏的闭合div，必须保留 -->
	<!-- <div class="kira-copyright">
		&copy; 2026
		<a href="/">Ivan-FYF</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		
	</div>
</div> -->
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div
			class="kira-post-cover"
			style="padding-bottom: '56.25%'"
		>
			<img
				data-src="/img/background4.jpg"
				data-sizes="auto"
				alt="trap.c详解"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>trap.c详解</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年12月29日</a>
			<a><i class="kirafont icon-edit-fill"></i>5.2k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 23 分钟</a>
		</div>
		<html><head></head><body><h1><span id="xv6-trapc-%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90%E9%99%B7%E9%98%B1%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E6%A0%B8%E5%BF%83">xv6 trap.c 源码全解析：陷阱（中断/异常/系统调用）处理核心</span></h1><p><code>trap.c</code> 是 xv6 处理 RISC-V 架构<strong>陷阱（Trap）</strong> 的核心文件，负责接管所有「用户态→内核态」的切换（系统调用、用户态中断/异常）和「内核态自身的中断/异常」，是理解 xv6 特权级切换、中断处理、系统调用分发的关键。以下按「代码结构、核心函数、关键逻辑、设计思路」逐层解析。</p>
<h2><span id="%E4%B8%80%E6%96%87%E4%BB%B6%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8">一、文件核心作用</span></h2><p>陷阱是 RISC-V CPU 对「中断（如计时器、外设）、异常（如页面错误、非法指令）、系统调用（ecall）」的统一响应机制。该文件实现：</p>
<ol>
<li>陷阱初始化（设置陷阱入口、自旋锁）；</li>
<li>用户态陷阱处理（<code>usertrap</code>）与返回（<code>usertrapret</code>）；</li>
<li>内核态陷阱处理（<code>kerneltrap</code>）；</li>
<li>设备中断识别（<code>devintr</code>）与时钟中断（<code>clockintr</code>）；</li>
<li>衔接蹦床页（trampoline）完成用户/内核页表切换。</li>
</ol>
<h2><span id="%E4%BA%8C%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">二、前置声明与全局变量</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"types.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"param.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"memlayout.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"riscv.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"spinlock.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"proc.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"defs.h"</span></span><br><br><span class="hljs-comment">// 保护 ticks 计数器的自旋锁（多核心安全）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">tickslock</span>;</span><br><span class="hljs-comment">// 系统启动后的时钟滴答数（计时器中断累加）</span><br>uint ticks;<br><br><span class="hljs-comment">// 外部声明：蹦床页的汇编函数（trampoline.S）</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> trampoline[], uservec[], userret[];<br><br><span class="hljs-comment">// 外部声明：kernelvec.S 中的内核陷阱入口，会调用 kerneltrap()</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kernelvec</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 外部声明：设备中断处理函数（识别并处理外设中断）</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">devintr</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>trampoline/uservec/userret</code>：蹦床页的汇编代码，负责用户态陷阱的入口/返回、页表切换；</li>
<li><code>kernelvec</code>：内核态陷阱的汇编入口，会保存寄存器后调用 <code>kerneltrap</code>；</li>
<li><code>ticks</code>：全局时钟计数器，用于系统计时、进程调度（计时器中断触发）。</li>
</ul>
<h2><span id="%E4%B8%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E9%99%B7%E9%98%B1%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">三、初始化函数：陷阱环境准备</span></h2><h3><span id="1-trapinit%E5%85%A8%E5%B1%80%E5%88%9D%E5%A7%8B%E5%8C%96">1. trapinit：全局初始化</span></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trapinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  initlock(&amp;tickslock, <span class="hljs-string">"time"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化保护 <code>ticks</code> 的自旋锁 <code>tickslock</code>，避免多核心同时修改 <code>ticks</code> 导致竞态。</li>
</ul>
<h3><span id="2-trapinithart%E6%AF%8F%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%9A%84%E9%99%B7%E9%98%B1%E5%85%A5%E5%8F%A3%E8%AE%BE%E7%BD%AE">2. trapinithart：每个核心的陷阱入口设置</span></h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trapinithart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  w_stvec((uint64)kernelvec);<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>w_stvec</code>：写入 RISC-V 的 <code>stvec</code> 寄存器（陷阱向量基址）；</li>
<li>作用：设置<strong>内核态</strong>的陷阱入口为 <code>kernelvec</code>（汇编函数），内核执行时触发的所有陷阱（中断/异常）都会跳转到 <code>kernelvec</code>。</li>
</ul>
<h2><span id="%E5%9B%9B%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86usertrap%E6%A0%B8%E5%BF%83">四、用户态陷阱处理：usertrap（核心）</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 校验：必须来自用户态（SSTATUS_SPP=0 表示上一级是用户态）</span><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">"usertrap: not from user mode"</span>);<br><br>  <span class="hljs-comment">// 切换内核态的陷阱入口：后续内核内的陷阱跳转到 kernelvec</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// 保存用户态的程序计数器（sepc）到进程的 trapframe</span><br>  <span class="hljs-comment">// sepc 存储触发陷阱的用户态指令地址（如 ecall）</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-comment">// 场景1：处理系统调用（scause=8 表示用户态 ecall）</span><br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>){<br>    <span class="hljs-comment">// 若进程已被标记为 killed，直接退出</span><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// 调整 epc：sepc 指向 ecall 指令，返回时需执行下一条（+4 字节）</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 开启中断（此前陷阱触发时硬件自动关中断，系统调用可响应外设中断）</span><br>    intr_on();<br><br>    <span class="hljs-comment">// 分发系统调用（syscall.c）：读取 trapframe 的 a7（调用号），执行对应函数</span><br>    syscall();<br>  } <br>  <span class="hljs-comment">// 场景2：处理设备中断（devintr 识别中断类型，返回非0表示处理成功）</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>){<br>    <span class="hljs-comment">// 设备中断处理完成，无需额外操作</span><br>  } <br>  <span class="hljs-comment">// 场景3：未知异常（如页面错误、非法指令）</span><br>  <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 打印错误信息，标记进程为 killed</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-comment">// 若进程被标记为 killed，退出进程</span><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// 若为计时器中断（which_dev=2），让出 CPU 调度其他进程</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  <span class="hljs-comment">// 返回到用户态</span><br>  usertrapret();<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%E6%8B%86%E8%A7%A3">关键逻辑拆解</span></h3><ol>
<li><strong>用户态校验</strong>：<code>SSTATUS_SPP</code> 是 RISC-V <code>sstatus</code> 寄存器的位，0=上一级是用户态，1=内核态；若内核态调用 <code>usertrap</code> 直接 panic（致命错误）。</li>
<li><strong>stvec 切换</strong>：进入内核后，将陷阱入口改为 <code>kernelvec</code>（内核态陷阱用），避免内核内的陷阱跳回用户态的 <code>uservec</code>。</li>
<li><strong>系统调用处理</strong>：<ul>
<li><code>r_scause() == 8</code>：RISC-V 定义 <code>scause=8</code> 为「用户态触发 ecall」；</li>
<li><code>epc +=4</code>：ecall 指令占 4 字节，返回用户态时需从下一条指令执行；</li>
<li><code>syscall()</code>：分发系统调用（如 exec/read/write），读取 <code>trapframe-&gt;a7</code> 的调用号，执行对应内核函数。</li>
</ul>
</li>
<li><strong>设备中断处理</strong>：<code>devintr()</code> 识别中断类型（计时器、UART、磁盘），返回值：<ul>
<li>2：计时器中断；</li>
<li>1：其他外设中断（UART/磁盘）；</li>
<li>0：未识别的中断/异常。</li>
</ul>
</li>
<li><strong>异常处理</strong>：未知异常直接标记进程为 killed，后续 <code>exit(-1)</code> 终止进程（xv6 对用户态异常的极简处理）。</li>
<li><strong>计时器中断调度</strong>：<code>yield()</code> 触发进程调度，让其他进程有机会运行。</li>
</ol>
<h2><span id="%E4%BA%94%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E9%98%B1%E8%BF%94%E5%9B%9Eusertrapret%E6%A0%B8%E5%BF%83">五、用户态陷阱返回：usertrapret（核心）</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// 关中断：切换 stvec 前避免触发新陷阱（防止入口错误）</span><br>  intr_off();<br><br>  <span class="hljs-comment">// 切换陷阱入口：用户态的陷阱跳转到蹦床页的 uservec</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));<br><br>  <span class="hljs-comment">// 填充 trapframe：uservec 后续需要这些信息来恢复内核态上下文</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// 内核页表（satp 寄存器值）</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// 进程的内核栈顶</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap; <span class="hljs-comment">// 下次用户态陷阱的入口</span><br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// 核心 ID（cpuid() 用）</span><br><br>  <span class="hljs-comment">// 配置 sstatus 寄存器：准备返回用户态</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// 清除 SPP 位（标记下一级为用户态）</span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// 开启 SPIE 位（用户态允许中断）</span><br>  w_sstatus(x);<br><br>  <span class="hljs-comment">// 恢复用户态的程序计数器（sepc = 保存的 epc）</span><br>  w_sepc(p-&gt;trapframe-&gt;epc);<br><br>  <span class="hljs-comment">// 构造用户页表的 satp 值（MAKE_SATP 宏：页表基址 + ASID）</span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);<br><br>  <span class="hljs-comment">// 跳转到蹦床页的 userret 汇编函数：</span><br>  <span class="hljs-comment">// 1. 切换到用户页表；2. 恢复用户寄存器；3. sret 返回用户态</span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);<br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%E6%8B%86%E8%A7%A3">关键逻辑拆解</span></h3><ol>
<li><strong>stvec 切换</strong>：<code>TRAMPOLINE</code> 是蹦床页的固定地址（所有进程共享），<code>uservec - trampoline</code> 是 <code>uservec</code> 在蹦床页内的偏移；设置后，用户态触发的陷阱会跳转到蹦床页的 <code>uservec</code>。</li>
<li><strong>trapframe 填充</strong>：<code>trapframe</code> 是进程私有、映射在用户页表中的内存，<code>uservec</code> 后续需要这些字段来：<ul>
<li><code>kernel_satp</code>：切换回内核页表；</li>
<li><code>kernel_sp</code>：切换到进程的内核栈；</li>
<li><code>kernel_trap</code>：跳转到 <code>usertrap</code> 处理陷阱。</li>
</ul>
</li>
<li><strong>sstatus 配置</strong>：<ul>
<li><code>~SSTATUS_SPP</code>：清除「上一级特权级」为用户态；</li>
<li><code>SSTATUS_SPIE</code>：开启用户态中断（用户程序可响应外设/计时器中断）。</li>
</ul>
</li>
<li><strong>跳转到 userret</strong>：<ul>
<li><code>TRAPFRAME</code> 是 <code>trapframe</code> 的用户虚拟地址；</li>
<li><code>satp</code> 是用户页表的地址；</li>
<li><code>userret</code> 汇编函数会：切换到用户页表 → 恢复用户寄存器 → 执行 <code>sret</code>（将 <code>sepc</code> 写入 PC，回到用户态）。</li>
</ul>
</li>
</ol>
<h2><span id="%E5%85%AD%E5%86%85%E6%A0%B8%E6%80%81%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86kerneltrap">六、内核态陷阱处理：kerneltrap</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <br><span class="hljs-title function_">kerneltrap</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br>  uint64 sepc = r_sepc();    <span class="hljs-comment">// 触发陷阱的内核指令地址</span><br>  uint64 sstatus = r_sstatus(); <span class="hljs-comment">// 陷阱触发时的 sstatus</span><br>  uint64 scause = r_scause();   <span class="hljs-comment">// 陷阱原因</span><br>  <br>  <span class="hljs-comment">// 校验：必须来自内核态（SSTATUS_SPP=1）</span><br>  <span class="hljs-keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">"kerneltrap: not from supervisor mode"</span>);<br>  <span class="hljs-comment">// 校验：中断必须关闭（内核陷阱不支持嵌套）</span><br>  <span class="hljs-keyword">if</span>(intr_get() != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">"kerneltrap: interrupts enabled"</span>);<br><br>  <span class="hljs-comment">// 处理设备中断</span><br>  <span class="hljs-keyword">if</span>((which_dev = devintr()) == <span class="hljs-number">0</span>){<br>    <span class="hljs-comment">// 未识别的陷阱（内核态异常，如页面错误、非法指令）→ panic</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"scause %p\n"</span>, scause);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());<br>    panic(<span class="hljs-string">"kerneltrap"</span>);<br>  }<br><br>  <span class="hljs-comment">// 若为计时器中断，且当前进程正在运行 → 让出 CPU</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span> &amp;&amp; myproc() != <span class="hljs-number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)<br>    yield();<br><br>  <span class="hljs-comment">// 恢复 sepc 和 sstatus（yield 可能修改这些寄存器）</span><br>  w_sepc(sepc);<br>  w_sstatus(sstatus);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%E6%8B%86%E8%A7%A3">关键逻辑拆解</span></h3><ol>
<li><strong>内核态校验</strong>：内核态陷阱必须满足 <code>SSTATUS_SPP=1</code>，且中断关闭（<code>intr_get()=0</code>），否则 panic（内核代码不应出现这种错误）。</li>
<li><strong>异常处理</strong>：内核态的非设备中断（如页面错误、非法指令）是致命错误，直接 panic（xv6 不处理内核态异常）。</li>
<li><strong>计时器中断调度</strong>：和 <code>usertrap</code> 逻辑一致，触发 <code>yield()</code> 调度进程。</li>
<li><strong>寄存器恢复</strong>：<code>yield()</code> 可能切换线程，修改 <code>sepc</code>/<code>sstatus</code>，需恢复到陷阱触发时的状态，确保返回后继续执行被中断的内核代码。</li>
</ol>
<h2><span id="%E4%B8%83%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86clockintr">七、时钟中断处理：clockintr</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">clockintr</span><span class="hljs-params">()</span><br>{<br>  acquire(&amp;tickslock); <span class="hljs-comment">// 加锁：多核心安全</span><br>  ticks++;             <span class="hljs-comment">// 时钟滴答数+1</span><br>  wakeup(&amp;ticks);      <span class="hljs-comment">// 唤醒所有等待 ticks 的进程（如 sleep 系统调用）</span><br>  release(&amp;tickslock); <span class="hljs-comment">// 解锁</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>ticks</code> 是全局计时基准，<code>sleep</code>/<code>wait</code> 等系统调用会等待 <code>ticks</code> 增加；</li>
<li>自旋锁 <code>tickslock</code> 确保多核心同时触发计时器中断时，<code>ticks</code> 不会被并发修改。</li>
</ul>
<h2><span id="%E5%85%AB%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%AD%E8%AF%86%E5%88%ABdevintr">八、设备中断识别：devintr</span></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">devintr</span><span class="hljs-params">()</span><br>{<br>  uint64 scause = r_scause();<br><br>  <span class="hljs-comment">// 场景1：PLIC 外部中断（scause 最高位=1 表示中断，低8位=9 表示 supervisor 外部中断）</span><br>  <span class="hljs-keyword">if</span>((scause &amp; <span class="hljs-number">0x8000000000000000L</span>) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>){<br>    <span class="hljs-comment">// 向 PLIC（平台级中断控制器）申请中断号（识别哪个设备触发）</span><br>    <span class="hljs-type">int</span> irq = plic_claim();<br><br>    <span class="hljs-comment">// 处理 UART 中断（串口输入）</span><br>    <span class="hljs-keyword">if</span>(irq == UART0_IRQ){<br>      uartintr();<br>    } <br>    <span class="hljs-comment">// 处理 virtio 磁盘中断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq == VIRTIO0_IRQ){<br>      virtio_disk_intr();<br>    } <br>    <span class="hljs-comment">// 未知外设中断</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq){<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"unexpected interrupt irq=%d\n"</span>, irq);<br>    }<br><br>    <span class="hljs-comment">// 通知 PLIC：该设备中断已处理，可再次触发</span><br>    <span class="hljs-keyword">if</span>(irq)<br>      plic_complete(irq);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记为“外设中断”</span><br>  } <br>  <span class="hljs-comment">// 场景2：软件中断（计时器中断，scause=0x8000000000000001）</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8000000000000001L</span>){<br>    <span class="hljs-comment">// 仅核心0处理全局时钟（避免多核心重复累加 ticks）</span><br>    <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>){<br>      clockintr();<br>    }<br>    <br>    <span class="hljs-comment">// 清除软件中断标记（SSIP 位），允许下次计时器中断</span><br>    w_sip(r_sip() &amp; ~<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 标记为“计时器中断”</span><br>  } <br>  <span class="hljs-comment">// 场景3：未识别的陷阱（异常）</span><br>  <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3><span id="%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%E6%8B%86%E8%A7%A3">关键逻辑拆解</span></h3><ol>
<li><strong>RISC-V 中断编码</strong>：<code>scause</code> 最高位为 1 表示「中断」（可恢复），为 0 表示「异常」（不可恢复）；</li>
<li><strong>PLIC 控制器</strong>：RISC-V 处理外设中断的核心组件，<code>plic_claim()</code> 获取中断源，<code>plic_complete()</code> 确认处理完成；</li>
<li><strong>计时器中断</strong>：属于「软件中断」（由机器模式的时钟触发，转发到监督模式），仅核心0处理全局 <code>ticks</code>；</li>
<li>返回值约定：<ul>
<li>2：计时器中断（触发调度）；</li>
<li>1：其他外设中断（UART/磁盘）；</li>
<li>0：未识别（异常）。</li>
</ul>
</li>
</ol>
<h2><span id="%E4%B9%9D%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">九、核心设计思路总结</span></h2><table>
<thead>
<tr>
<th>模块</th>
<th>核心设计目标</th>
<th>关键技巧</th>
</tr>
</thead>
<tbody><tr>
<td>usertrap/usertrapret</td>
<td>安全切换用户/内核态，处理系统调用/中断</td>
<td>蹦床页+页表切换、trapframe 保存上下文</td>
</tr>
<tr>
<td>kerneltrap</td>
<td>处理内核态中断，异常直接 panic</td>
<td>寄存器恢复、禁止中断嵌套</td>
</tr>
<tr>
<td>devintr</td>
<td>识别中断源，解耦外设中断处理</td>
<td>PLIC 申请/确认、中断类型分类</td>
</tr>
<tr>
<td>自旋锁（tickslock）</td>
<td>多核心下的全局变量安全</td>
<td>加锁/解锁保护 ticks 累加</td>
</tr>
</tbody></table>
<h3><span id="%E4%B8%8E%E7%9C%9F%E5%AE%9Eos%E7%9A%84%E5%B7%AE%E5%BC%82%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9F%A5%E8%AF%86%E7%82%B9">与真实OS的差异（回顾之前知识点）</span></h3><ol>
<li>xv6 对用户态异常直接终止进程，真实OS会处理页面错误（COW/惰性分配）；</li>
<li>xv6 内核态异常直接 panic，真实OS会尝试恢复（如换入磁盘页）；</li>
<li>xv6 依赖蹦床页切换页表，真实OS将内核映射到用户页表，避免页表切换开销。</li>
</ol>
<p>该文件是 xv6 特权级管理的“心脏”，所有用户态到内核态的交互（系统调用、中断）都通过这里完成，其极简的设计（牺牲效率换简洁）也正是教学OS的核心特点。</p>
<hr>
<h1><span id="xv6-trampolines-%E6%BA%90%E7%A0%81%E5%85%A8%E8%A7%A3%E6%9E%90%E7%94%A8%E6%88%B7%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E6%B1%87%E7%BC%96%E6%A1%A5%E6%A2%81">xv6 trampoline.S 源码全解析：用户/内核态切换的汇编桥梁</span></h1><p><code>trampoline.S</code> 是 xv6 实现「用户态↔内核态」切换的核心汇编代码，映射在所有进程的用户页表和内核页表的<strong>同一虚拟地址（TRAMPOLINE）</strong>，解决了「页表切换时代码连续性」的关键问题。文件核心包含 <code>uservec</code>（用户态陷阱入口）和 <code>userret</code>（内核态返回用户态）两个函数，以下逐行拆解逻辑、寄存器操作和设计原理。</p>
<h2><span id="%E4%B8%80%E6%A0%B8%E5%BF%83%E8%83%8C%E6%99%AF%E8%B9%A6%E5%BA%8A%E9%A1%B5trampoline%E7%9A%84%E6%84%8F%E4%B9%89">一、核心背景：蹦床页（Trampoline）的意义</span></h2><ol>
<li><strong>地址一致性</strong>：TRAMPOLINE 是固定虚拟地址（如 <code>0xFFFF000000000000</code>），同时映射到「用户页表」和「内核页表」，且权限为「S模式可执行」，因此切换页表后代码仍能继续执行；</li>
<li><strong>无数据依赖</strong>：蹦床页仅包含汇编代码，不访问任何进程私有数据，仅依赖 <code>trapframe</code>（进程私有、映射在用户页表的 TRAPFRAME 地址）；</li>
<li><strong>核心作用</strong>：<ul>
<li><code>uservec</code>：用户态触发陷阱（ecall/中断/异常）后，完成「用户寄存器保存→切换到内核页表→跳转到 usertrap()」；</li>
<li><code>userret</code>：内核态返回用户态时，完成「切换到用户页表→恢复用户寄存器→sret 返回用户态」。</li>
</ul>
</li>
</ol>
<h2><span id="%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E4%B8%8E%E5%89%8D%E7%BD%AE%E7%BA%A6%E5%AE%9A">二、代码结构与前置约定</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 标记段为 trampsec（链接脚本 kernel.ld 会将其对齐到页边界）<br>.section trampsec<br>.globl trampoline<br>trampoline:<br>.align 4  # 4字节对齐（RISC-V 指令长度）<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>.section trampsec</code>：自定义段，确保蹦床页代码被链接到独立的页；</li>
<li><code>.globl</code>：导出符号，让内核 C 代码（如 trap.c）能引用 <code>trampoline/uservec/userret</code>；</li>
<li><code>.align 4</code>：RISC-V 指令是 4 字节，对齐后保证指令正确执行。</li>
</ul>
<h2><span id="%E4%B8%89%E6%A0%B8%E5%BF%831uservec%E7%94%A8%E6%88%B7%E6%80%81%E2%86%92%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E9%99%B7%E9%98%B1%E5%85%A5%E5%8F%A3">三、核心1：uservec（用户态→内核态的陷阱入口）</span></h2><p><code>uservec</code> 是用户态陷阱的第一个入口（stvec 指向此处），执行时 CPU 处于「S模式、用户页表」，最终切换到内核页表并跳转到 <code>usertrap()</code>。</p>
<h3><span id="%E9%80%90%E8%A1%8C%E6%8B%86%E8%A7%A3--%E9%80%BB%E8%BE%91%E6%B3%A8%E9%87%8A">逐行拆解 &amp; 逻辑注释</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl uservec<br>uservec:    <br>        # 背景：<br>        # 1. 触发陷阱后，CPU 进入 S 模式，sepc 保存用户态陷阱指令地址；<br>        # 2. sscratch 预先设置为 TRAPFRAME（进程 trapframe 的用户虚拟地址）；<br>        # 3. 此时仍使用用户页表，仅能访问用户空间 + TRAMPOLINE + TRAPFRAME。<br><br>        # 步骤1：交换 a0 和 sscratch，让 a0 = TRAPFRAME（trapframe 地址）<br>        # csrrw：原子读+写 sscratch，将 sscratch 原值写入 a0，a0 原值写入 sscratch<br>        csrrw a0, sscratch, a0<br><br>        # 步骤2：保存所有用户态通用寄存器到 trapframe（TRAPFRAME 偏移对应字段）<br>        # 注：trapframe 是进程私有结构，映射在用户页表的 TRAPFRAME 地址<br>        sd ra, 40(a0)   # 保存返回地址 ra 到 trapframe+40<br>        sd sp, 48(a0)   # 保存用户栈指针 sp 到 trapframe+48<br>        sd gp, 56(a0)   # 保存全局指针 gp 到 trapframe+56<br>        sd tp, 64(a0)   # 保存线程指针 tp 到 trapframe+64<br>        sd t0, 72(a0)   # 临时寄存器 t0-t6 依次保存<br>        sd t1, 80(a0)<br>        sd t2, 88(a0)<br>        sd s0, 96(a0)   # 保存寄存器 s0-s11（保存寄存器）<br>        sd s1, 104(a0)<br>        sd a1, 120(a0)  # 保存 a1-a7（系统调用参数寄存器）<br>        sd a2, 128(a0)<br>        sd a3, 136(a0)<br>        sd a4, 144(a0)<br>        sd a5, 152(a0)<br>        sd a6, 160(a0)<br>        sd a7, 168(a0)<br>        sd s2, 176(a0)<br>        sd s3, 184(a0)<br>        sd s4, 192(a0)<br>        sd s5, 200(a0)<br>        sd s6, 208(a0)<br>        sd s7, 216(a0)<br>        sd s8, 224(a0)<br>        sd s9, 232(a0)<br>        sd s10, 240(a0)<br>        sd s11, 248(a0)<br>        sd t3, 256(a0)<br>        sd t4, 264(a0)<br>        sd t5, 272(a0)<br>        sd t6, 280(a0)<br><br>        # 步骤3：保存用户态 a0 到 trapframe+112<br>        # 此前 csrrw 交换了 a0 和 sscratch，sscratch 中是原用户态 a0（系统调用参数）<br>        csrr t0, sscratch  # 读取 sscratch（原用户 a0）到 t0<br>        sd t0, 112(a0)     # 写入 trapframe+112（a0 字段）<br><br>        # 步骤4：切换到进程的内核栈（从 trapframe 读取 kernel_sp）<br>        # trapframe+8 存储的是进程内核栈顶地址（kernel_sp）<br>        ld sp, 8(a0)<br><br>        # 步骤5：设置 tp 寄存器为当前核心 ID（hartid）<br>        # trapframe+32 存储 kernel_hartid（核心 ID），tp 用于 cpuid()<br>        ld tp, 32(a0)<br><br>        # 步骤6：加载 usertrap() 的地址（trapframe+16 存储 kernel_trap）<br>        ld t0, 16(a0)<br><br>        # 步骤7：切换到内核页表（关键！）<br>        # 1. 从 trapframe+0 读取 kernel_satp（内核页表的 satp 值）<br>        ld t1, 0(a0)<br>        # 2. 写入 satp 寄存器，切换到内核页表<br>        csrw satp, t1<br>        # 3. 刷新 TLB，确保页表切换生效（zero 表示刷新所有地址）<br>        sfence.vma zero, zero<br><br>        # 注意：切换内核页表后，TRAPFRAME（用户虚拟地址）不再有效，a0 失效<br>        # 内核页表不映射用户态的 trapframe，因此后续不能访问 a0 指向的地址<br><br>        # 步骤8：跳转到 usertrap()（C 函数），不再返回<br>        jr t0<br></code></pre></td></tr></tbody></table></figure>

<h3><span id="uservec-%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87%E6%80%BB%E7%BB%93">uservec 核心目标总结</span></h3><table>
<thead>
<tr>
<th>操作阶段</th>
<th>核心成果</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器保存</td>
<td>所有用户态寄存器存入 trapframe，不丢失上下文</td>
</tr>
<tr>
<td>栈切换</td>
<td>sp 从用户栈切换到进程私有内核栈</td>
</tr>
<tr>
<td>页表切换</td>
<td>satp 从用户页表切换到内核页表</td>
</tr>
<tr>
<td>入口跳转</td>
<td>从汇编跳转到 C 层的 usertrap() 处理陷阱</td>
</tr>
</tbody></table>
<h2><span id="%E5%9B%9B%E6%A0%B8%E5%BF%832userret%E5%86%85%E6%A0%B8%E6%80%81%E2%86%92%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E8%BF%94%E5%9B%9E%E5%85%A5%E5%8F%A3">四、核心2：userret（内核态→用户态的返回入口）</span></h2><p><code>userret</code> 由 <code>usertrapret()</code> 调用，执行时 CPU 处于「S模式、内核页表」，最终切换到用户页表并通过 <code>sret</code> 返回用户态。</p>
<h3><span id="%E9%80%90%E8%A1%8C%E6%8B%86%E8%A7%A3--%E9%80%BB%E8%BE%91%E6%B3%A8%E9%87%8A">逐行拆解 &amp; 逻辑注释</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl userret<br>userret:<br>        # 背景：<br>        # 1. usertrapret() 调用 userret，传入两个参数：<br>        #    a0 = TRAPFRAME（trapframe 的用户虚拟地址）<br>        #    a1 = 用户页表的 satp 值（MAKE_SATP(p-&gt;pagetable)）<br>        # 2. 此时仍使用内核页表，需先切换到用户页表才能访问 TRAPFRAME。<br><br>        # 步骤1：切换到用户页表（关键！）<br>        # 1. 写入 satp 寄存器，切换到用户页表<br>        csrw satp, a1<br>        # 2. 刷新 TLB，确保页表切换生效<br>        sfence.vma zero, zero<br><br>        # 步骤2：恢复用户态 a0 到 sscratch（为最后一步交换做准备）<br>        # 从 trapframe+112 读取保存的用户 a0，写入 sscratch<br>        ld t0, 112(a0)<br>        csrw sscratch, t0<br><br>        # 步骤3：从 trapframe 恢复所有用户态寄存器（除 a0）<br>        ld ra, 40(a0)   # 恢复返回地址 ra<br>        ld sp, 48(a0)   # 恢复用户栈指针 sp（关键！回到用户栈）<br>        ld gp, 56(a0)   # 恢复全局指针 gp<br>        ld tp, 64(a0)   # 恢复线程指针 tp<br>        ld t0, 72(a0)   # 恢复临时寄存器 t0-t6<br>        ld t1, 80(a0)<br>        ld t2, 88(a0)<br>        ld s0, 96(a0)   # 恢复保存寄存器 s0-s11<br>        ld s1, 104(a0)<br>        ld a1, 120(a0)  # 恢复参数寄存器 a1-a7<br>        ld a2, 128(a0)<br>        ld a3, 136(a0)<br>        ld a4, 144(a0)<br>        ld a5, 152(a0)<br>        ld a6, 160(a0)<br>        ld a7, 168(a0)<br>        ld s2, 176(a0)<br>        ld s3, 184(a0)<br>        ld s4, 192(a0)<br>        ld s5, 200(a0)<br>        ld s6, 208(a0)<br>        ld s7, 216(a0)<br>        ld s8, 224(a0)<br>        ld s9, 232(a0)<br>        ld s10, 240(a0)<br>        ld s11, 248(a0)<br>        ld t3, 256(a0)<br>        ld t4, 264(a0)<br>        ld t5, 272(a0)<br>        ld t6, 280(a0)<br><br>        # 步骤4：恢复用户态 a0，同时将 TRAPFRAME 写回 sscratch<br>        # csrrw：交换 a0 和 sscratch，a0 恢复为用户态原值，sscratch 保存 TRAPFRAME<br>        csrrw a0, sscratch, a0<br>        <br>        # 步骤5：返回用户态（关键！）<br>        # sret 指令：<br>        # 1. 将 sepc 写入 PC，跳转到用户态陷阱指令的下一条；<br>        # 2. 将 sstatus.SPP 置为 0（用户态），恢复中断使能；<br>        # 3. 特权级从 S 模式切回 U 模式。<br>        # 注：sstatus 和 sepc 已由 usertrapret() 提前设置好。<br>        sret<br></code></pre></td></tr></tbody></table></figure>

<h3><span id="userret-%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87%E6%80%BB%E7%BB%93">userret 核心目标总结</span></h3><table>
<thead>
<tr>
<th>操作阶段</th>
<th>核心成果</th>
</tr>
</thead>
<tbody><tr>
<td>页表切换</td>
<td>satp 从内核页表切换到用户页表</td>
</tr>
<tr>
<td>寄存器恢复</td>
<td>所有用户态寄存器从 trapframe 恢复</td>
</tr>
<tr>
<td>特权级切换</td>
<td>sret 切回 U 模式，从 sepc 继续执行用户代码</td>
</tr>
</tbody></table>
<h2><span id="%E4%BA%94%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82%E4%B8%8E%E7%AD%94%E7%96%91">五、关键设计细节与答疑</span></h2><h3><span id="1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-csrrw-%E4%BA%A4%E6%8D%A2-a0-%E5%92%8C-sscratch">1. 为什么需要 csrrw 交换 a0 和 sscratch？</span></h3><ul>
<li><code>sscratch</code> 是 RISC-V 为陷阱处理设计的「临时寄存器」，专门用于存储 trapframe 地址；</li>
<li>用户态执行时，<code>a0</code> 可能存储系统调用参数（如 exec 的 path），直接覆盖会丢失数据；</li>
<li><code>csrrw</code> 是原子操作，确保「trapframe 地址获取」和「用户 a0 保存」一步完成，无数据丢失。</li>
</ul>
<h3><span id="2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%87%E6%8D%A2%E9%A1%B5%E8%A1%A8%E5%90%8E%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE-a0trapframe">2. 为什么切换页表后不能访问 a0（TRAPFRAME）？</span></h3><ul>
<li>TRAPFRAME 是「用户虚拟地址」，仅在用户页表中有效；</li>
<li>内核页表仅映射「内核空间 + TRAMPOLINE」，不映射用户态的 trapframe，因此切换后 a0 指向的地址无效。</li>
</ul>
<h3><span id="3-sfencevma-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">3. sfence.vma 的作用是什么？</span></h3><ul>
<li>RISC-V 的 TLB 会缓存「虚拟地址→物理地址」映射，页表切换后 TLB 缓存失效；</li>
<li><code>sfence.vma zero, zero</code> 表示「刷新所有核心、所有地址的 TLB」，确保后续内存访问使用新页表。</li>
</ul>
<h3><span id="4-%E4%B8%BA%E4%BB%80%E4%B9%88-trampoline-%E8%A6%81%E6%98%A0%E5%B0%84%E5%88%B0%E5%90%8C%E4%B8%80%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80">4. 为什么 trampoline 要映射到同一虚拟地址？</span></h3><ul>
<li>切换页表的过程中，CPU 仍在执行 trampoline 的代码；</li>
<li>若 trampoline 在用户/内核页表的虚拟地址不同，切换页表后 PC 会指向无效地址，导致崩溃；</li>
<li>同一地址映射保证了「页表切换时代码执行的连续性」。</li>
</ul>
<h2><span id="%E5%85%AD%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93">六、核心设计思路总结</span></h2><table>
<thead>
<tr>
<th>模块</th>
<th>核心挑战</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>uservec</td>
<td>用户页表→内核页表切换，寄存器保存</td>
<td>先保存寄存器到 trapframe，再切换页表/栈</td>
</tr>
<tr>
<td>userret</td>
<td>内核页表→用户页表切换，上下文恢复</td>
<td>先切换页表，再恢复寄存器，sret 切回用户态</td>
</tr>
<tr>
<td>整体</td>
<td>页表切换时代码不中断</td>
<td>蹦床页映射到统一地址，仅用汇编执行切换</td>
</tr>
</tbody></table>
<h3><span id="%E4%B8%8E%E7%9C%9F%E5%AE%9Eos%E7%9A%84%E5%B7%AE%E5%BC%82">与真实OS的差异</span></h3><ol>
<li>xv6 用蹦床页+显式页表切换，真实OS（如Linux）将内核映射到用户页表，无需切换页表；</li>
<li>xv6 保存所有寄存器，真实OS仅保存「调用约定中需要保留的寄存器」，减少开销；</li>
<li>xv6 陷阱处理路径极简，真实OS会处理页面错误、COW等复杂场景。</li>
</ol>
<h2><span id="%E4%B8%83%E5%85%B3%E9%94%AE%E5%85%B3%E8%81%94%E4%B8%8E-trapc-%E7%9A%84%E5%8D%8F%E4%BD%9C">七、关键关联（与 trap.c 的协作）</span></h2><table>
<thead>
<tr>
<th>trampoline.S 操作</th>
<th>trap.c 对应操作</th>
</tr>
</thead>
<tbody><tr>
<td>uservec 跳转到 usertrap()</td>
<td>usertrap() 处理系统调用/中断/异常</td>
</tr>
<tr>
<td>userret 被 usertrapret() 调用</td>
<td>usertrapret() 配置 sstatus/sepc 等寄存器</td>
</tr>
<tr>
<td>trapframe 字段读写</td>
<td>usertrap()/usertrapret() 填充 trapframe</td>
</tr>
</tbody></table>
<p><code>trampoline.S</code> 是「纯汇编的硬件层切换」，<code>trap.c</code> 是「C 层的逻辑处理」，两者协作完成了 xv6 最核心的特权级切换流程。</p>
</body></html>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>本文作者：</strong>Ivan-FYF<br>
        <strong>本文链接：</strong><a href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/trap-c%E8%AF%A6%E8%A7%A3/" title="https:&#x2F;&#x2F;hellonnnnn.github.io&#x2F;2025&#x2F;12&#x2F;29&#x2F;第四章&#x2F;trap-c详解&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;hellonnnnn.github.io&#x2F;2025&#x2F;12&#x2F;29&#x2F;第四章&#x2F;trap-c详解&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			          
			<!-- 先找到与当前文字相同的目录 -->
			                                                                              
			<!-- 在找到当前文章所在的 index -->
			                                                                                                    
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E9%A1%B5%E9%9D%A2%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%EF%BC%9Axv6-%E6%9E%81%E7%AE%80%E5%A4%84%E7%90%86-vs-%E7%9C%9F%E5%AE%9E-OS-%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"> 页面错误异常：xv6 极简处理 vs 真实 OS 的高级应用</a>
			</div>
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2026/01/21/%E7%AC%AC%E4%B8%80%E7%AB%A0/unbuntu%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E4%B8%8D%E8%B6%B3/"> unbuntu系统存储不足</a>
			</div>
			                 
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/os%E9%A1%B9%E7%9B%AE/">os项目</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/xv6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%AA%8C%E5%9B%9B/" rel="tag">xv6操作系统项目实验四</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="hellonnnnn/hellonnnnn.github.io"
      data-repo-id="R_kgDOQqLdWw"
      data-category="Announcements"
      data-category-id="DIC_kwDOQqLdW84C1Rqg"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="zh-CN"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
