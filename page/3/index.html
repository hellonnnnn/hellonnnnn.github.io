<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hellonnnnn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="记录 C++、Linux、系统方向学习与项目">
<meta property="og:type" content="website">
<meta property="og:title" content="Ivan&#39;s Tech Blog">
<meta property="og:url" content="https://hellonnnnn.github.io/page/3/index.html">
<meta property="og:site_name" content="Ivan&#39;s Tech Blog">
<meta property="og:description" content="记录 C++、Linux、系统方向学习与项目">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ivan-FYF">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hellonnnnn.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ivan's Tech Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ivan's Tech Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">C++ / Linux / System Programming</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ivan-FYF</p>
  <div class="site-description" itemprop="description">记录 C++、Linux、系统方向学习与项目</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">第二章面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-22 19:20:08 / 修改时间：21:50:03" itemprop="dateCreated datePublished" datetime="2025-12-22T19:20:08+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h3><p>这段聊天围绕“系统调用的匹配机制”展开：</p>
<ul>
<li>用户iris分享了腾讯一面的问题：系统调用如何确定对应关系、是否仅依赖系统调用号；</li>
<li>用户“焕、心”回应：内核通过维护系统调用号表实现匹配，并给出系统调用的核心流程（用户态调用库函数→切换至内核态（保存用户态状态）→通过系统调用号查表调用对应函数→返回用户态），同时邀请加入操作系统内核答疑群。</li>
</ul>
<h3 id="面试问题的深层细节解析"><a href="#面试问题的深层细节解析" class="headerlink" title="面试问题的深层细节解析"></a>面试问题的深层细节解析</h3><p>该面试问题的核心是“系统调用的匹配并非仅依赖系统调用号，而是‘号+映射表+特权链路+合法性校验’的组合机制”，以xv6（你之前讨论的系统）为例：</p>
<ol>
<li><strong>核心标识：系统调用号</strong><br>系统调用号是唯一标识（如xv6中<code>SYS_trace</code>对应编号22），是匹配的基础。</li>
<li><strong>映射载体：系统调用号表</strong><br>内核维护“系统调用号-函数指针”映射表（如xv6的<code>syscalls</code>数组），号作为数组下标直接映射到对应处理函数（如<code>SYS_trace</code>对应<code>sys_trace</code>函数）。</li>
<li><strong>特权链路保障匹配有效性</strong><br>用户态无法直接访问内核函数，需通过汇编存根（如xv6的<code>usys.S</code>）触发<code>ecall</code>指令切换至内核态；内核的trap处理程序会读取寄存器（如RISC-V的<code>a7</code>）中的系统调用号，再通过号表查表匹配。</li>
<li><strong>合法性校验避免错误</strong><br>内核会校验系统调用号的合法性（如xv6中检查<code>num &lt; NELEM(syscalls)</code>），防止非法编号导致的内存越界或错误调用。</li>
</ol>
<hr>
<p>其实针对<strong>xv6系统调用</strong>以及<strong>操作系统中系统调用的核心考点</strong>，我们已经覆盖了<strong>绝大部分面试高频问题</strong>（尤其是校招&#x2F;初级内核岗、嵌入式岗的面试）。不过面试中还会有一些**更偏向“综合对比”“底层原理延伸”“场景分析”**的问题，我帮你梳理一下：</p>
<h3 id="一、已经完全覆盖的面试高频考点（对应我们聊过的内容）"><a href="#一、已经完全覆盖的面试高频考点（对应我们聊过的内容）" class="headerlink" title="一、已经完全覆盖的面试高频考点（对应我们聊过的内容）"></a>一、已经完全覆盖的面试高频考点（对应我们聊过的内容）</h3><p>这些都是面试中大概率会问到的，且我们已经掰开揉碎聊过了：</p>
<table>
<thead>
<tr>
<th>面试高频问题</th>
<th>对应我们聊过的内容</th>
</tr>
</thead>
<tbody><tr>
<td>xv6中系统调用的完整流程？</td>
<td>用户态封装（usys.pl生成的汇编存根）→ecall→内核trap处理→syscall()分发→sys_xxx→核心函数→返回</td>
</tr>
<tr>
<td>sys_xxx和xxx（如sys_exec和exec）的区别？</td>
<td>分层结构：sys_xxx是入口（参数解析），xxx是核心逻辑（功能实现），sys_xxx调用xxx</td>
</tr>
<tr>
<td>用户态如何传递参数给内核？</td>
<td>RISC-V寄存器（a0-a5传参数，a7传系统调用号）+copyin&#x2F;copyout（数据拷贝）+argint&#x2F;argstr等封装</td>
</tr>
<tr>
<td>为什么需要copyin&#x2F;copyout？</td>
<td>地址空间隔离，内核不能直接访问用户态地址，且校验地址合法性，防止内核崩溃&#x2F;安全漏洞</td>
</tr>
<tr>
<td>你如何在xv6中添加一个系统调用（如trace&#x2F;sysinfo）？</td>
<td>四步：usys.pl加entry→定义系统调用号→实现sys_xxx→添加到分发表</td>
</tr>
<tr>
<td>trace系统调用的实现思路？</td>
<td>进程级掩码（proc结构体加字段）+sys_trace设置掩码+syscall()函数后置检查掩码并打印日志</td>
</tr>
<tr>
<td>系统调用和中断的区别？</td>
<td>系统调用是用户态主动触发的trap（ecall），中断是硬件被动触发的（如时钟）</td>
</tr>
<tr>
<td>usys.pl的作用是什么？</td>
<td>自动生成用户态系统调用的汇编存根，避免手动编写重复的ecall指令代码</td>
</tr>
<tr>
<td>系统调用的返回值如何传递？</td>
<td>内核写入trapframe的a0寄存器，用户态从a0获取</td>
</tr>
</tbody></table>
<h3 id="二、面试中还可能问到的补充考点（偏延伸-综合，我们聊过但未展开）"><a href="#二、面试中还可能问到的补充考点（偏延伸-综合，我们聊过但未展开）" class="headerlink" title="二、面试中还可能问到的补充考点（偏延伸&#x2F;综合，我们聊过但未展开）"></a>二、面试中还可能问到的<strong>补充考点</strong>（偏延伸&#x2F;综合，我们聊过但未展开）</h3><p>这些问题是面试中“拔高”的点，需要结合原理做简要回答：</p>
<h4 id="1-xv6中系统调用的陷阱（Trap）处理细节？（高频延伸题）"><a href="#1-xv6中系统调用的陷阱（Trap）处理细节？（高频延伸题）" class="headerlink" title="1. xv6中系统调用的陷阱（Trap）处理细节？（高频延伸题）"></a>1. <strong>xv6中系统调用的陷阱（Trap）处理细节？</strong>（高频延伸题）</h4><p><strong>核心回答思路</strong>（我们之前提到过trap，但未展开流程）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 用户态执行ecall指令，CPU自动切换到内核态（S-mode），并跳转到内核预设的陷阱入口（trapvec，在kernel/trampoline.S中）；</span><br><span class="line">2. 保存用户态的寄存器到进程的trapframe（包括a0-a7、epc等）；</span><br><span class="line">3. 调用kernel/trap.c中的trap()函数，判断陷阱类型：</span><br><span class="line">   - 如果是ecall（系统调用），则调用syscall()函数处理；</span><br><span class="line">   - 如果是页故障/非法指令，則处理异常；</span><br><span class="line">4. 处理完成后，恢复用户态寄存器，执行sret指令回到用户态，从epc指向的下一条指令继续执行。</span><br></pre></td></tr></table></figure>

<h4 id="2-系统调用和普通函数调用的本质区别？（通用OS面试题）"><a href="#2-系统调用和普通函数调用的本质区别？（通用OS面试题）" class="headerlink" title="2. 系统调用和普通函数调用的本质区别？（通用OS面试题）"></a>2. <strong>系统调用和普通函数调用的本质区别？</strong>（通用OS面试题）</h4><p><strong>核心回答思路</strong>：</p>
<ul>
<li><strong>执行权限</strong>：普通函数调用在用户态执行，系统调用会切换到内核态（特权级提升）；</li>
<li><strong>调用方式</strong>：普通函数调用是call指令（跳转到函数地址），系统调用是ecall指令（触发陷阱）；</li>
<li><strong>地址空间</strong>：普通函数调用在同一地址空间，系统调用涉及用户&#x2F;内核地址空间切换；</li>
<li><strong>开销</strong>：系统调用有上下文切换、地址转换的开销，比普通函数调用慢1-2个数量级。</li>
</ul>
<h4 id="3-xv6中如果用户传入非法的系统调用号，内核会如何处理？（场景题）"><a href="#3-xv6中如果用户传入非法的系统调用号，内核会如何处理？（场景题）" class="headerlink" title="3. xv6中如果用户传入非法的系统调用号，内核会如何处理？（场景题）"></a>3. <strong>xv6中如果用户传入非法的系统调用号，内核会如何处理？</strong>（场景题）</h4><p><strong>核心回答思路</strong>（对应我们聊过的syscall()函数逻辑）：</p>
<ul>
<li>内核在syscall()函数中会检查：<code>num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]</code>；</li>
<li>如果不满足（非法号），则打印错误日志（<code>unknown sys call</code>），并将trapframe-&gt;a0设为-1返回；</li>
<li>这样用户态会收到-1的返回值，知道系统调用失败。</li>
</ul>
<h4 id="4-xv6中系统调用的进程上下文是什么？（内核岗高频题）"><a href="#4-xv6中系统调用的进程上下文是什么？（内核岗高频题）" class="headerlink" title="4. xv6中系统调用的进程上下文是什么？（内核岗高频题）"></a>4. <strong>xv6中系统调用的进程上下文是什么？</strong>（内核岗高频题）</h4><p><strong>核心回答思路</strong>：</p>
<ul>
<li>系统调用执行时，内核处于<strong>当前进程的上下文</strong>中：可以访问当前进程的proc结构体、trapframe、用户页表；</li>
<li>因此sys_getpid能直接返回myproc()-&gt;pid，sys_trace能直接修改当前进程的掩码字段；</li>
<li>内核不能直接访问其他进程的资源，除非通过进程表遍历（如sys_kill）。</li>
</ul>
<h4 id="5-为什么xv6的系统调用参数最多6个？（架构相关题）"><a href="#5-为什么xv6的系统调用参数最多6个？（架构相关题）" class="headerlink" title="5. 为什么xv6的系统调用参数最多6个？（架构相关题）"></a>5. <strong>为什么xv6的系统调用参数最多6个？</strong>（架构相关题）</h4><p><strong>核心回答思路</strong>：</p>
<ul>
<li>因为RISC-V架构规定，系统调用的参数通过a0-a5寄存器传递（共6个）；</li>
<li>如果需要传递更多参数，需要将参数打包成结构体，通过指针传递（如sys_exec的argv），再用copyin解析。</li>
</ul>
<h3 id="三、面试中还可能问到的通用OS系统调用考点（超出xv6，但面试常问）"><a href="#三、面试中还可能问到的通用OS系统调用考点（超出xv6，但面试常问）" class="headerlink" title="三、面试中还可能问到的通用OS系统调用考点（超出xv6，但面试常问）"></a>三、面试中还可能问到的<strong>通用OS系统调用考点</strong>（超出xv6，但面试常问）</h3><p>如果面试涉及Linux等主流系统，还会问这些（可以简单了解思路）：</p>
<ol>
<li><strong>Linux中的系统调用是如何实现的？</strong>（和xv6的区别：x86用int 0x80&#x2F;syscall指令，RISC-V用ecall；Linux有vDSO优化）</li>
<li><strong>什么是vDSO？为什么要引入？</strong>（虚拟动态共享对象，把部分系统调用（如gettimeofday）放到用户态执行，减少上下文切换开销，xv6没有但面试常问）</li>
<li><strong>系统调用的性能优化手段有哪些？</strong>（批量操作（如write缓冲）、vDSO、减少拷贝（如零拷贝sendfile））</li>
<li><strong>Linux中系统调用的返回值为什么通常是-1表示失败，而不是0？</strong>（因为0是合法的返回值（如write返回写入的字节数），用-1表示失败，再通过errno存错误码）</li>
</ol>
<h3 id="四、面试答题小技巧（结合我们聊的xv6）"><a href="#四、面试答题小技巧（结合我们聊的xv6）" class="headerlink" title="四、面试答题小技巧（结合我们聊的xv6）"></a>四、面试答题小技巧（结合我们聊的xv6）</h3><p>面试中回答问题时，<strong>尽量结合xv6的实际实现举例</strong>，会比泛泛而谈更有说服力：</p>
<ul>
<li>比如被问“用户态和内核态如何交互数据”，不要只说“用copyin&#x2F;copyout”，还要补充“比如我在实现sys_sysinfo时，就是先填充内核态的sysinfo结构体，再用copyout拷贝到用户态地址”；</li>
<li>被问“如何添加系统调用”，可以说“我在xv6中实现trace系统调用时，分了四步：首先在usys.pl中添加entry，然后定义SYS_trace，实现sys_trace函数，最后添加到syscalls数组”。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果面试的是<strong>xv6相关的操作系统岗、嵌入式岗、校招OS方向</strong>，我们聊过的内容已经<strong>完全覆盖了核心考点</strong>，甚至超出了基础要求（比如copyin的逐页转换、trace的进程级掩码）；如果是面试<strong>Linux内核岗</strong>，只需要补充上述几个通用考点即可。</p>
<p>你可以放心，现在你对xv6系统调用的理解深度，应对面试已经足够了～</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/22/%E7%AC%AC%E4%B8%80%E7%AB%A0/shell%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/22/%E7%AC%AC%E4%B8%80%E7%AB%A0/shell%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">shell的运行过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-22 17:54:59 / 修改时间：19:20:31" itemprop="dateCreated datePublished" datetime="2025-12-22T17:54:59+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在xv6中，<strong>Shell是一个运行在用户态的程序</strong>（对应<code>user/sh.c</code>），它的核心逻辑是“<strong>命令解析→进程管理→等待执行结果</strong>”的循环，依赖<code>fork</code>、<code>exec</code>、<code>wait</code>等系统调用与内核交互。以下是它的完整运行流程：</p>
<h3 id="一、Shell的启动：内核初始化后的第一个用户程序"><a href="#一、Shell的启动：内核初始化后的第一个用户程序" class="headerlink" title="一、Shell的启动：内核初始化后的第一个用户程序"></a>一、Shell的启动：内核初始化后的第一个用户程序</h3><p>xv6启动时，内核完成初始化（内存、进程、文件系统）后，会通过<code>exec</code>系统调用启动<strong>第一个用户程序——Shell</strong>（对应<code>user/sh.c</code>编译后的可执行文件）。此时Shell成为xv6系统中第一个运行的用户进程。</p>
<h3 id="二、Shell的核心循环：“读命令→解析→执行→等待”"><a href="#二、Shell的核心循环：“读命令→解析→执行→等待”" class="headerlink" title="二、Shell的核心循环：“读命令→解析→执行→等待”"></a>二、Shell的核心循环：“读命令→解析→执行→等待”</h3><p>Shell启动后，会进入一个<strong>无限循环</strong>，持续处理用户输入的命令，直到系统关闭。核心流程分为4步：</p>
<h4 id="1-读取用户输入（读命令行）"><a href="#1-读取用户输入（读命令行）" class="headerlink" title="1. 读取用户输入（读命令行）"></a>1. 读取用户输入（读命令行）</h4><p>Shell通过<code>read</code>系统调用，从“标准输入”（默认是终端<code>/dev/console</code>）读取用户输入的一行命令（比如<code>ls</code>、<code>trace 32 grep hello README</code>）。</p>
<p>xv6的Shell中，这一步由<code>readline</code>函数实现（封装了<code>read</code>系统调用），会等待用户输入并处理换行符，最终得到一个字符串形式的命令行。</p>
<h4 id="2-解析命令行（拆分命令与参数）"><a href="#2-解析命令行（拆分命令与参数）" class="headerlink" title="2. 解析命令行（拆分命令与参数）"></a>2. 解析命令行（拆分命令与参数）</h4><p>Shell将读取到的命令行字符串拆分为<strong>命令名</strong>和<strong>参数列表</strong>：</p>
<ul>
<li>比如输入<code>trace 32 grep hello README</code>，会被拆分为：<ul>
<li>命令名：<code>trace</code></li>
<li>参数列表：<code>[&quot;trace&quot;, &quot;32&quot;, &quot;grep&quot;, &quot;hello&quot;, &quot;README&quot;]</code></li>
</ul>
</li>
</ul>
<p>xv6的Shell中，这一步由<code>parsecmd</code>函数实现（字符串分割逻辑），最终生成一个命令结构（包含命令类型、参数等）。</p>
<h4 id="3-执行命令：区分“内置命令”和“外部命令”"><a href="#3-执行命令：区分“内置命令”和“外部命令”" class="headerlink" title="3. 执行命令：区分“内置命令”和“外部命令”"></a>3. 执行命令：区分“内置命令”和“外部命令”</h4><p>Shell会根据命令类型，选择不同的执行方式：</p>
<h5 id="（1）内置命令：直接在Shell进程中执行（不创建子进程）"><a href="#（1）内置命令：直接在Shell进程中执行（不创建子进程）" class="headerlink" title="（1）内置命令：直接在Shell进程中执行（不创建子进程）"></a>（1）内置命令：直接在Shell进程中执行（不创建子进程）</h5><p>内置命令是<strong>Shell自身实现的功能</strong>，无法通过“启动外部程序”完成，因此必须在Shell进程中直接执行（依赖对应的系统调用）。</p>
<p>xv6中典型的内置命令是<code>cd</code>（切换工作目录）：</p>
<ul>
<li>原因：如果<code>cd</code>在子进程中执行，子进程的工作目录会改变，但<strong>父进程（Shell）的工作目录不会受影响</strong>（进程的工作目录是独立的），所以必须由Shell自己调用<code>chdir</code>系统调用完成切换。</li>
</ul>
<p>执行逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以cd为例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123; <span class="comment">/* 处理参数不足 */</span> &#125;</span><br><span class="line">  <span class="comment">// 直接在Shell进程中调用chdir系统调用</span></span><br><span class="line">  <span class="keyword">if</span> (chdir(argv[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123; <span class="comment">/* 处理错误 */</span> &#125;</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 执行完后回到Shell循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="（2）外部命令：创建子进程执行（依赖fork-exec）"><a href="#（2）外部命令：创建子进程执行（依赖fork-exec）" class="headerlink" title="（2）外部命令：创建子进程执行（依赖fork+exec）"></a>（2）外部命令：创建子进程执行（依赖fork+exec）</h5><p>外部命令是<strong>独立的用户程序</strong>（如<code>ls</code>、<code>grep</code>、<code>sysinfotest</code>），需要通过“创建子进程+替换程序镜像”的方式执行：</p>
<p>执行逻辑分为3步：</p>
<ol>
<li><strong><code>fork</code>创建子进程</strong>：Shell调用<code>fork</code>系统调用，创建一个与自己完全相同的子进程（复制内存、上下文）；</li>
<li><strong>子进程中<code>exec</code>替换程序</strong>：子进程调用<code>exec</code>系统调用，将自己的程序镜像替换为目标命令对应的可执行文件（比如<code>exec(&quot;ls&quot;, argv)</code>会加载<code>/bin/ls</code>并执行）；</li>
<li><strong>父进程<code>wait</code>等待子进程结束</strong>：Shell（父进程）调用<code>wait</code>系统调用，阻塞等待子进程执行完毕，然后继续下一轮循环。</li>
</ol>
<h4 id="4-等待子进程结束，回到循环"><a href="#4-等待子进程结束，回到循环" class="headerlink" title="4. 等待子进程结束，回到循环"></a>4. 等待子进程结束，回到循环</h4><p>外部命令执行时，Shell会阻塞在<code>wait</code>调用中，直到子进程执行完毕（无论是正常退出还是出错）。子进程结束后，Shell会清理子进程的资源，然后回到循环的第一步，等待下一个用户命令。</p>
<h3 id="三、xv6-Shell的执行示例（以trace-32-grep-hello-README为例）"><a href="#三、xv6-Shell的执行示例（以trace-32-grep-hello-README为例）" class="headerlink" title="三、xv6 Shell的执行示例（以trace 32 grep hello README为例）"></a>三、xv6 Shell的执行示例（以<code>trace 32 grep hello README</code>为例）</h3><ol>
<li>用户在终端输入<code>trace 32 grep hello README</code>，Shell通过<code>read</code>读取该命令行；</li>
<li><code>parsecmd</code>将其拆分为命令名<code>trace</code>和参数列表<code>[&quot;trace&quot;, &quot;32&quot;, &quot;grep&quot;, &quot;hello&quot;, &quot;README&quot;]</code>；</li>
<li>Shell判断<code>trace</code>是外部命令，调用<code>fork</code>创建子进程；</li>
<li>子进程调用<code>exec(&quot;trace&quot;, argv)</code>，加载并执行<code>trace</code>程序（<code>trace</code>内部会调用<code>trace</code>系统调用设置掩码，再<code>exec</code>执行<code>grep</code>）；</li>
<li>Shell（父进程）调用<code>wait</code>，等待<code>trace</code>进程执行完毕；</li>
<li><code>trace</code>执行完成后，Shell回到循环，等待下一个命令。</li>
</ol>
<h3 id="四、Shell的核心特点"><a href="#四、Shell的核心特点" class="headerlink" title="四、Shell的核心特点"></a>四、Shell的核心特点</h3><ol>
<li><strong>Shell是用户程序</strong>：它本身不具备内核权限，所有功能（如创建进程、切换目录）都依赖系统调用；</li>
<li><strong>内置命令的必要性</strong>：部分操作（如<code>cd</code>、<code>exit</code>）必须在Shell进程中执行，否则无法影响Shell自身的状态；</li>
<li><strong>依赖进程管理系统调用</strong>：<code>fork</code>、<code>exec</code>、<code>wait</code>是Shell实现“多命令执行”的核心基础。</li>
</ol>
<p>总结来说，xv6的Shell是一个“<strong>命令解释器+进程管理器</strong>”，通过“读取-解析-执行-等待”的循环，借助内核的进程管理能力，实现用户命令的执行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/xv6%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/xv6%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">xv6内核架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-22 17:45:42 / 修改时间：19:20:29" itemprop="dateCreated datePublished" datetime="2025-12-22T17:45:42+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>xv6是MIT开发的<strong>类Unix教学操作系统</strong>（复刻Unix V6），核心用于讲解操作系统的基础架构与核心机制。它采用<strong>单内核架构</strong>（所有内核功能在同一特权级地址空间运行），整体分为**内核态（kernel目录）<strong>和</strong>用户态（user目录）**两大部分，对应你截图中的核心目录结构。</p>
<h3 id="一、xv6的核心目录与文件功能（对应你的截图）"><a href="#一、xv6的核心目录与文件功能（对应你的截图）" class="headerlink" title="一、xv6的核心目录与文件功能（对应你的截图）"></a>一、xv6的核心目录与文件功能（对应你的截图）</h3><p>从你的截图可以看到xv6的根目录结构，核心目录&#x2F;文件的作用如下：</p>
<table>
<thead>
<tr>
<th>目录&#x2F;文件</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>kernel/</code></td>
<td>内核态代码：包含操作系统的核心功能模块（进程、内存、文件系统等）</td>
</tr>
<tr>
<td><code>user/</code></td>
<td>用户态代码：包含用户程序（如<code>cat</code>、<code>echo</code>）、系统调用封装、shell等</td>
</tr>
<tr>
<td><code>Makefile</code></td>
<td>编译配置文件：定义内核、用户程序的编译规则，控制xv6镜像的生成</td>
</tr>
<tr>
<td><code>fs.img</code></td>
<td>xv6的文件系统镜像：存储用户程序、系统文件的虚拟磁盘</td>
</tr>
<tr>
<td><code>grade-lab-syscall</code></td>
<td>实验评分脚本：用于验证系统调用类实验（如你之前的<code>trace</code>&#x2F;<code>sysinfo</code>）的正确性</td>
</tr>
<tr>
<td><code>xv6.out</code></td>
<td>编译生成的xv6内核镜像文件</td>
</tr>
</tbody></table>
<h3 id="二、xv6的系统架构（分模块）"><a href="#二、xv6的系统架构（分模块）" class="headerlink" title="二、xv6的系统架构（分模块）"></a>二、xv6的系统架构（分模块）</h3><p>xv6的架构围绕“<strong>用户态程序请求内核服务</strong>”的核心逻辑展开，内核态分为多个功能模块，用户态通过系统调用与内核交互。</p>
<h4 id="1-内核态（kernel目录）：操作系统核心功能"><a href="#1-内核态（kernel目录）：操作系统核心功能" class="headerlink" title="1. 内核态（kernel目录）：操作系统核心功能"></a>1. 内核态（kernel目录）：操作系统核心功能</h4><p>内核态是xv6的“服务提供者”，包含以下核心模块（对应<code>kernel/</code>下的文件）：</p>
<ul>
<li><p><strong>进程管理模块</strong>（<code>proc.c</code>、<code>proc.h</code>）</p>
<ul>
<li>管理进程的生命周期（创建<code>fork</code>、执行<code>exec</code>、终止<code>exit</code>、等待<code>wait</code>）；</li>
<li>维护进程结构体<code>struct proc</code>（包含进程状态、地址空间、内核栈等）；</li>
<li>实现进程调度（基于时间片的轮转调度）。</li>
</ul>
</li>
<li><p><strong>内存管理模块</strong>（<code>kalloc.c</code>、<code>vm.c</code>、<code>memlayout.h</code>）</p>
<ul>
<li>物理内存分配：通过空闲页链表管理物理内存（<code>kalloc</code>分配、<code>kfree</code>释放）；</li>
<li>虚拟内存管理：为每个进程维护独立的虚拟地址空间（通过页表<code>pagetable_t</code>实现）；</li>
<li>地址空间隔离：用户态与内核态地址空间分离，内核态有独立的地址区域。</li>
</ul>
</li>
<li><p><strong>文件系统模块</strong>（<code>fs.c</code>、<code>file.c</code>、<code>inode.c</code>）</p>
<ul>
<li>实现类Unix的文件系统：基于inode（索引节点）管理文件&#x2F;目录，支持硬链接、目录遍历；</li>
<li>统一文件接口：将“文件、目录、设备”抽象为“文件描述符”，用户态通过<code>open/read/write/close</code>操作所有资源。</li>
</ul>
</li>
<li><p><strong>设备驱动模块</strong>（<code>console.c</code>、<code>uart.c</code>、<code>disk.c</code>）</p>
<ul>
<li>对接硬件设备：实现终端（console）、串口（uart）、磁盘（disk）的驱动逻辑；</li>
<li>设备抽象为文件：将设备映射为特殊文件（如<code>/dev/console</code>），通过文件系统接口访问。</li>
</ul>
</li>
<li><p><strong>系统调用模块</strong>（<code>syscall.c</code>、<code>sys_*.c</code>）</p>
<ul>
<li>提供系统调用的“入口与映射”：维护<code>syscalls</code>数组（系统调用号→内核函数的映射）；</li>
<li>处理用户态请求：从<code>trapframe</code>提取参数，调用对应内核函数（如<code>sys_trace</code>&#x2F;<code>sysinfo</code>），并返回结果。</li>
</ul>
</li>
<li><p><strong>中断&#x2F;陷阱处理模块</strong>（<code>trap.c</code>、<code>entry.S</code>）</p>
<ul>
<li>处理特权级切换：用户态通过<code>ecall</code>指令触发“陷阱”，进入内核态；</li>
<li>保存&#x2F;恢复上下文：将用户态寄存器保存到<code>trapframe</code>，内核处理完后恢复寄存器并返回用户态。</li>
</ul>
</li>
<li><p><strong>启动模块</strong>（<code>entry.S</code>、<code>start.c</code>）</p>
<ul>
<li>硬件启动后，先执行汇编代码<code>entry.S</code>（初始化CPU状态、跳转到C代码）；</li>
<li><code>start.c</code>完成内核初始化（内存、进程、文件系统），最终启动第一个用户程序（shell）。</li>
</ul>
</li>
</ul>
<h4 id="2-用户态（user目录）：应用程序与接口"><a href="#2-用户态（user目录）：应用程序与接口" class="headerlink" title="2. 用户态（user目录）：应用程序与接口"></a>2. 用户态（user目录）：应用程序与接口</h4><p>用户态是xv6的“服务使用者”，包含以下部分（对应<code>user/</code>下的文件）：</p>
<ul>
<li><p><strong>用户程序</strong>（如<code>cat.c</code>、<code>echo.c</code>、<code>sysinfotest.c</code>）</p>
<ul>
<li>实现具体功能的应用程序，通过系统调用请求内核服务（如<code>echo</code>调用<code>write</code>输出内容）。</li>
</ul>
</li>
<li><p><strong>系统调用封装</strong>（<code>usys.S</code>、<code>user.h</code>）</p>
<ul>
<li><code>usys.S</code>：由<code>usys.pl</code>生成的汇编存根，将系统调用封装为用户态函数（如<code>sysinfo</code>对应汇编指令<code>ecall</code>）；</li>
<li><code>user.h</code>：声明用户态可调用的系统调用接口（如<code>int sysinfo(struct sysinfo *si)</code>）。</li>
</ul>
</li>
<li><p><strong>Shell（<code>sh.c</code>）</strong></p>
<ul>
<li>命令解释器：解析用户输入的命令，启动对应的用户程序（如输入<code>ls</code>则启动<code>ls</code>程序）；</li>
<li>本身是一个用户程序，通过系统调用与内核交互（如<code>fork</code>创建子进程、<code>exec</code>执行命令）。</li>
</ul>
</li>
</ul>
<h3 id="三、xv6的核心运行逻辑（用户态→内核态交互）"><a href="#三、xv6的核心运行逻辑（用户态→内核态交互）" class="headerlink" title="三、xv6的核心运行逻辑（用户态→内核态交互）"></a>三、xv6的核心运行逻辑（用户态→内核态交互）</h3><p>xv6的核心流程是“<strong>用户程序发起系统调用→内核处理请求→返回用户态</strong>”，以<code>sysinfo</code>为例：</p>
<ol>
<li>用户程序调用<code>sysinfo(&amp;si)</code>（<code>user.h</code>中声明的接口）；</li>
<li>执行<code>usys.S</code>中的汇编存根：将系统调用号<code>SYS_sysinfo</code>存入<code>a7</code>，执行<code>ecall</code>陷入内核；</li>
<li>内核<code>trap</code>处理程序保存用户态寄存器到<code>trapframe</code>，调用<code>syscall()</code>；</li>
<li><code>syscall()</code>通过<code>syscalls</code>数组找到<code>sys_sysinfo</code>函数，执行内存&#x2F;进程统计；</li>
<li>内核通过<code>copyout</code>将结果拷贝到用户态指针<code>&amp;si</code>；</li>
<li>执行<code>sret</code>返回用户态，用户程序获取结果并继续运行。</li>
</ol>
<h3 id="四、xv6架构的特点（教学定位）"><a href="#四、xv6架构的特点（教学定位）" class="headerlink" title="四、xv6架构的特点（教学定位）"></a>四、xv6架构的特点（教学定位）</h3><p>xv6作为教学操作系统，架构设计<strong>简洁且覆盖核心原理</strong>：</p>
<ul>
<li>单内核架构：所有内核功能在同一地址空间，简化了模块间的交互（适合教学）；</li>
<li>功能精简：仅保留Unix的核心机制（进程、内存、文件系统、系统调用），去除了复杂特性（如网络、多CPU）；</li>
<li>接口与Unix兼容：用户态接口（系统调用、文件系统）与Unix一致，便于理解实际OS的工作方式。</li>
</ul>
<p>总结来说，xv6的架构是“<strong>内核态提供核心服务模块，用户态通过统一的系统调用接口请求服务</strong>”，其目录结构（<code>kernel</code>&#x2F;<code>user</code>）直接对应了“内核-用户”的分层逻辑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">添加系统调用的过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-22 16:07:09 / 修改时间：17:25:29" itemprop="dateCreated datePublished" datetime="2025-12-22T16:07:09+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>详细介绍添加一个新系统调用的完整流程</strong>（我们仍以之前的<code>trace</code>系统调用为例，这样能和你之前的代码、问题紧密结合，更易理解）。</p>
<h3 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h3><p>xv6是一个简化的类Unix内核，添加系统调用的核心是打通<strong>用户态程序</strong>到<strong>内核态函数</strong>的调用链路，整个过程需要修改内核的多个文件和用户态代码，且<strong>系统调用编号的一致性</strong>、<strong>内核&#x2F;用户态的接口匹配</strong>是关键。</p>
<p>以下步骤基于<strong>xv6-riscv</strong>（xv6-x86流程几乎一致，仅汇编语法略有差异）展开。</p>
<hr>
<h2 id="一、添加系统调用的完整步骤（以trace为例）"><a href="#一、添加系统调用的完整步骤（以trace为例）" class="headerlink" title="一、添加系统调用的完整步骤（以trace为例）"></a>一、添加系统调用的完整步骤（以<code>trace</code>为例）</h2><p>我们将整个过程分为<strong>8个核心步骤</strong>，每个步骤明确修改的文件、代码和原因：</p>
<h3 id="步骤1：定义系统调用编号（关键：全局唯一）"><a href="#步骤1：定义系统调用编号（关键：全局唯一）" class="headerlink" title="步骤1：定义系统调用编号（关键：全局唯一）"></a>步骤1：定义系统调用编号（关键：全局唯一）</h3><p>系统调用编号是内核识别不同系统调用的“身份证”，需要在公共头文件中定义，确保内核和用户态都能访问。</p>
<p><strong>修改文件</strong>：<code>kernel/syscall.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先看原有系统调用的编号，在最后添加新的编号（比如SYS_trace=22）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="comment">// ... 省略原有其他系统调用编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close   21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace   22  <span class="comment">// 新增：trace系统调用的编号（必须连续/唯一，不能重复）</span></span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：xv6的系统调用编号从1开始（部分版本从0开始），需紧跟原有编号的最后一位，避免空缺或重复。</p>
<h3 id="步骤2：修改进程结构体（按需：存储系统调用的上下文数据）"><a href="#步骤2：修改进程结构体（按需：存储系统调用的上下文数据）" class="headerlink" title="步骤2：修改进程结构体（按需：存储系统调用的上下文数据）"></a>步骤2：修改进程结构体（按需：存储系统调用的上下文数据）</h3><p><code>trace</code>系统调用需要将<strong>跟踪掩码</strong>存储到进程的结构体中，因此需要扩展<code>struct proc</code>。</p>
<p><strong>修改文件</strong>：<code>kernel/proc.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_context</span> <span class="title">context</span>;</span>  <span class="comment">// 线程上下文（原有）</span></span><br><span class="line">  uint64 kstack;                  <span class="comment">// 内核栈地址（原有）</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>           <span class="comment">// 进程状态（原有）</span></span><br><span class="line">  <span class="comment">// ... 省略其他原有成员</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];                  <span class="comment">// 进程名（原有）</span></span><br><span class="line">  <span class="comment">// 新增：存储trace的位掩码（名称和你之前的kama_syscall_trace一致即可）</span></span><br><span class="line">  uint64 kama_syscall_trace;      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：如果新系统调用不需要存储进程相关的持久数据（比如<code>getpid</code>只返回pid，无需存储），此步骤可跳过。</p>
<h3 id="步骤3：声明系统调用函数原型（内核内的函数接口）"><a href="#步骤3：声明系统调用函数原型（内核内的函数接口）" class="headerlink" title="步骤3：声明系统调用函数原型（内核内的函数接口）"></a>步骤3：声明系统调用函数原型（内核内的函数接口）</h3><p>需要在头文件中声明内核态的系统调用实现函数，确保其他内核文件能调用。</p>
<p><strong>修改文件</strong>：<code>kernel/syscall.h</code>（或新建<code>kernel/sys_trace.h</code>，推荐前者更简洁）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在syscall.h的末尾添加函数原型</span></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明sys_trace函数（返回值为uint64，无参数）</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：xv6的系统调用函数统一返回<code>uint64</code>类型，参数通过寄存器传递（而非函数参数）。</p>
<h3 id="步骤4：实现内核态的系统调用函数（核心逻辑）"><a href="#步骤4：实现内核态的系统调用函数（核心逻辑）" class="headerlink" title="步骤4：实现内核态的系统调用函数（核心逻辑）"></a>步骤4：实现内核态的系统调用函数（核心逻辑）</h3><p>这是系统调用的<strong>功能实现部分</strong>，需要处理用户态传入的参数，并完成核心逻辑（比如<code>trace</code>的逻辑是获取掩码并设置到进程结构体中）。</p>
<h4 id="子步骤4-1：创建-编写系统调用实现代码"><a href="#子步骤4-1：创建-编写系统调用实现代码" class="headerlink" title="子步骤4.1：创建&#x2F;编写系统调用实现代码"></a>子步骤4.1：创建&#x2F;编写系统调用实现代码</h4><p><strong>新建文件</strong>：<code>kernel/sys_trace.c</code>（也可写在<code>kernel/sysfile.c</code>等现有文件中，推荐单独文件更清晰）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含必要的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysdefs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sys_trace函数：获取用户态传入的掩码，设置到当前进程的kama_syscall_trace</span></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 mask;  <span class="comment">// 存储用户态传入的掩码值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关键：从用户态获取参数（xv6提供了argint/argaddr等函数处理参数）</span></span><br><span class="line">  <span class="comment">// argaddr(0, &amp;mask)：获取第0个参数（用户态传入的第一个参数），存储到mask中</span></span><br><span class="line">  <span class="comment">// 如果参数获取失败，返回-1（错误码）</span></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前进程的结构体指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 将掩码设置到进程的kama_syscall_trace成员中</span></span><br><span class="line">  p-&gt;kama_syscall_trace = mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回0表示成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键函数说明</strong>：</p>
<ul>
<li><code>myproc()</code>：xv6提供的函数，返回当前正在执行的进程结构体指针。</li>
<li><code>argaddr(n, &amp;val)</code>&#x2F;<code>argint(n, &amp;val)</code>：获取用户态传入的第<code>n</code>个参数（<code>argint</code>用于int类型，<code>argaddr</code>用于64位地址&#x2F;数值类型），失败返回-1。</li>
</ul>
<h4 id="子步骤4-2：修改Makefile（编译新的内核文件）"><a href="#子步骤4-2：修改Makefile（编译新的内核文件）" class="headerlink" title="子步骤4.2：修改Makefile（编译新的内核文件）"></a>子步骤4.2：修改Makefile（编译新的内核文件）</h4><p>如果新建了<code>sys_trace.c</code>，需要将其添加到内核编译列表中，否则编译器会忽略该文件。</p>
<p><strong>修改文件</strong>：<code>kernel/Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到OBJ变量，添加sys_trace.o</span></span><br><span class="line">OBJ = \</span><br><span class="line">  entry.o \</span><br><span class="line">  start.o \</span><br><span class="line">  main.o \</span><br><span class="line">  <span class="comment"># ... 省略其他原有.o文件</span></span><br><span class="line">  sys_trace.o \  <span class="comment"># 新增：添加sys_trace的目标文件</span></span><br><span class="line">  <span class="comment"># ... 其他文件</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：如果系统调用函数写在现有文件中（比如sysfile.c），此子步骤可跳过。</p>
<h3 id="步骤5：更新系统调用表（内核的“系统调用映射表”）"><a href="#步骤5：更新系统调用表（内核的“系统调用映射表”）" class="headerlink" title="步骤5：更新系统调用表（内核的“系统调用映射表”）"></a>步骤5：更新系统调用表（内核的“系统调用映射表”）</h3><p>xv6通过一个函数指针数组<code>syscalls</code>来映射系统调用编号和对应的实现函数，必须将新系统调用添加到这个数组中，否则内核无法找到函数实现。</p>
<p><strong>修改文件</strong>：<code>kernel/syscall.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先声明syscalls数组和sys_trace函数（如果未包含头文件，需手动声明）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 声明sys_trace函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义系统调用函数指针数组（关键：编号要和syscall.h中的一致）</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  [SYS_fork]    sys_fork,</span><br><span class="line">  [SYS_exit]    sys_exit,</span><br><span class="line">  [SYS_wait]    sys_wait,</span><br><span class="line">  <span class="comment">// ... 省略其他原有系统调用的映射</span></span><br><span class="line">  [SYS_close]   sys_close,</span><br><span class="line">  [SYS_trace]   sys_trace,  <span class="comment">// 新增：映射SYS_trace到sys_trace函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. （可选，结合你之前的需求）更新系统调用名称数组（用于打印）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *kama_syscall_names[] = &#123;</span><br><span class="line">  [SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  [SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">  <span class="comment">// ... 省略其他原有名称</span></span><br><span class="line">  [SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">  [SYS_trace]   <span class="string">&quot;trace&quot;</span>,  <span class="comment">// 新增：添加trace的名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：数组的下标必须和<code>syscall.h</code>中定义的系统调用编号完全一致，否则内核会调用错误的函数。</p>
<h3 id="步骤6：添加用户态的系统调用封装（用户程序的调用接口）"><a href="#步骤6：添加用户态的系统调用封装（用户程序的调用接口）" class="headerlink" title="步骤6：添加用户态的系统调用封装（用户程序的调用接口）"></a>步骤6：添加用户态的系统调用封装（用户程序的调用接口）</h3><p>用户态程序无法直接调用内核态函数，需要通过<strong>汇编指令</strong>触发系统调用（ecall），xv6提供了<code>usys.S</code>文件来封装这些汇编逻辑，同时在<code>user.h</code>中提供C语言的函数声明，让用户程序可以像调用普通函数一样调用系统调用。</p>
<h4 id="子步骤6-1：添加汇编封装（触发系统调用）"><a href="#子步骤6-1：添加汇编封装（触发系统调用）" class="headerlink" title="子步骤6.1：添加汇编封装（触发系统调用）"></a>子步骤6.1：添加汇编封装（触发系统调用）</h4><p><strong>修改文件</strong>：<code>user/usys.S</code>（xv6-riscv）或<code>user/usys.pl</code>（xv6-x86）, 本实验修改usys.pl的entry</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># xv6-riscv的usys.S语法：通过ecall指令触发系统调用</span><br><span class="line"># 格式：</span><br><span class="line"># global 函数名</span><br><span class="line"># 函数名:</span><br><span class="line">#   li a7, 系统调用编号</span><br><span class="line">#   ecall</span><br><span class="line">#   ret</span><br><span class="line"></span><br><span class="line"># 新增：trace的汇编封装</span><br><span class="line">global trace</span><br><span class="line">trace:</span><br><span class="line">  li a7, SYS_trace  # 将SYS_trace编号加载到a7寄存器（xv6约定用a7存储系统调用编号）</span><br><span class="line">  ecall             # 触发系统调用，进入内核态</span><br><span class="line">  ret               # 返回用户态</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li>xv6约定：系统调用编号存储在<code>a7</code>寄存器（riscv）&#x2F;<code>eax</code>寄存器（x86），参数存储在<code>a0-a5</code>寄存器。</li>
<li><code>ecall</code>（riscv）&#x2F;<code>int 0x80</code>（x86）是触发系统调用的指令，会从用户态切换到内核态。</li>
</ul>
<h4 id="子步骤6-2：添加用户态函数声明"><a href="#子步骤6-2：添加用户态函数声明" class="headerlink" title="子步骤6.2：添加用户态函数声明"></a>子步骤6.2：添加用户态函数声明</h4><p><strong>修改文件</strong>：<code>user/user.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在user.h中添加trace函数的声明，让用户程序可以调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;  <span class="comment">// 声明trace函数（参数为掩码，返回值为0表示成功，-1表示失败）</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：函数的参数和返回值类型要和内核态的实现逻辑匹配（比如<code>trace</code>的参数是掩码，类型为int&#x2F;uint64）。</p>
<h3 id="步骤7：实现用户态的应用程序（测试新系统调用）"><a href="#步骤7：实现用户态的应用程序（测试新系统调用）" class="headerlink" title="步骤7：实现用户态的应用程序（测试新系统调用）"></a>步骤7：实现用户态的应用程序（测试新系统调用）</h3><p>编写一个用户态程序（比如<code>trace.c</code>），调用新的<code>trace</code>系统调用，完成功能测试。</p>
<p><strong>新建文件</strong>：<code>user/trace.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="type">char</span> *cmd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查参数：trace mask command [args...]</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: trace mask command [args...]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析掩码参数（将字符串转换为整数）</span></span><br><span class="line">  mask = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  cmd = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用trace系统调用，设置掩码</span></span><br><span class="line">  trace(mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行指定的命令（比如grep hello README）</span></span><br><span class="line">  exec(cmd, &amp;argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果exec失败，打印错误信息</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;trace: exec %s failed\n&quot;</span>, cmd);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li><code>exec(cmd, &amp;argv[2])</code>：执行指定的命令，是xv6中执行外部程序的核心函数。</li>
<li><code>fprintf(2, ...)</code>：向标准错误输出打印信息（2是标准错误的文件描述符）。</li>
</ul>
<h3 id="步骤8：修改Makefile（编译用户态程序）"><a href="#步骤8：修改Makefile（编译用户态程序）" class="headerlink" title="步骤8：修改Makefile（编译用户态程序）"></a>步骤8：修改Makefile（编译用户态程序）</h3><p>将新的用户态程序<code>trace</code>添加到编译列表中，确保xv6启动时能加载该程序。</p>
<p><strong>修改文件</strong>：<code>Makefile</code>（根目录的Makefile）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到UPROGS变量，添加_trace（前缀下划线是xv6的约定）</span></span><br><span class="line">UPROGS = \</span><br><span class="line">  _cat \</span><br><span class="line">  _echo \</span><br><span class="line">  _grep \</span><br><span class="line">  <span class="comment"># ... 省略其他原有用户程序</span></span><br><span class="line">  _trace \  <span class="comment"># 新增：添加trace程序</span></span><br><span class="line">  <span class="comment"># ... 其他程序</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、编译并测试新系统调用"><a href="#二、编译并测试新系统调用" class="headerlink" title="二、编译并测试新系统调用"></a>二、编译并测试新系统调用</h2><p>完成以上步骤后，执行以下命令编译并运行xv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理旧的编译文件</span></span><br><span class="line">make clean</span><br><span class="line"><span class="comment"># 编译并运行xv6（qemu模拟器）</span></span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>
<p>在xv6的终端中执行测试命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trace 32 grep hello README（32=1&lt;&lt;5，对应SYS_kill的编号）</span></span><br><span class="line">trace 32 grep hello README</span><br></pre></td></tr></table></figure>
<p>此时，内核会跟踪<code>grep</code>进程的<code>kill</code>系统调用，并打印对应的信息，不再出现之前的乱码和编译错误。</p>
<hr>
<h3 id="xv6系统调用的完整流程（以trace为例）"><a href="#xv6系统调用的完整流程（以trace为例）" class="headerlink" title="xv6系统调用的完整流程（以trace为例）"></a>xv6系统调用的完整流程（以<code>trace</code>为例）</h3><ol>
<li><p><strong>用户程序调用系统调用封装函数</strong><br>用户程序（如<code>trace</code>）中调用<code>trace(mask)</code>——这个函数是<code>user.h</code>中声明的接口，实际对应<code>usys.S</code>里的<strong>汇编存根</strong>（由<code>usys.pl</code>自动生成）。</p>
</li>
<li><p><strong>汇编存根触发特权级切换（陷入内核）</strong><br>汇编存根中执行两个关键操作：</p>
<ul>
<li>将系统调用编号（如<code>SYS_trace</code>）存入<code>a7</code>寄存器；</li>
<li>执行<code>ecall</code>指令——这是RISC-V的“环境调用”指令，会直接触发<strong>特权级切换</strong>（从用户态切换到内核态），同时跳转到内核预设的异常处理入口。</li>
</ul>
</li>
<li><p><strong>内核trap处理程序接管</strong><br>内核的<code>trap</code>处理函数（<code>kernel/trap.c</code>中的<code>trap()</code>）会：</p>
<ul>
<li>将用户态的所有寄存器（包括<code>a0~a7</code>，即参数和系统调用号）保存到当前进程的<strong>trapframe</strong>（进程结构体的成员）中；</li>
<li>判断陷阱类型为“系统调用”后，调用<code>syscall()</code>函数处理。</li>
</ul>
</li>
<li><p><strong>通过syscalls数组查表，执行系统调用函数</strong><br><code>syscall()</code>函数的核心逻辑：</p>
<ul>
<li>从trapframe中读取<code>a7</code>寄存器的值（即系统调用编号）；</li>
<li>以编号为下标，在<code>syscalls</code>数组（内核维护的“系统调用号→函数指针”映射表）中找到对应的内核函数（如<code>SYS_trace</code>对应<code>sys_trace()</code>）；</li>
<li>调用该内核函数，同时通过<code>arg</code>系列函数（如<code>argaddr()</code>）从trapframe的<code>a0~a5</code>中提取用户态参数。</li>
</ul>
</li>
<li><p><strong>执行内核函数，返回结果</strong><br>内核函数（如<code>sys_trace()</code>）完成逻辑后，将返回值存入trapframe的<code>a0</code>寄存器（用户态的返回值寄存器）。</p>
</li>
<li><p><strong>恢复用户态上下文，返回用户程序</strong><br>内核<code>trap</code>处理程序恢复trapframe中保存的用户态寄存器，执行<code>sret</code>指令（RISC-V的“从异常返回”指令），回到用户程序的汇编存根；汇编存根执行<code>ret</code>指令，回到用户程序的调用点，用户程序从<code>a0</code>中读取返回值，继续执行。</p>
</li>
</ol>
<h3 id="总结：系统调用的核心链路"><a href="#总结：系统调用的核心链路" class="headerlink" title="总结：系统调用的核心链路"></a>总结：系统调用的核心链路</h3><p><code>用户程序调用系统调用接口 → 汇编存根执行ecall → 陷入内核（trap处理） → syscalls查表执行内核函数 → 保存返回值 → sret回到用户态 → 用户程序获取返回值</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/21/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/21/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">第二章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-21 19:39:52" itemprop="dateCreated datePublished" datetime="2025-12-21T19:39:52+08:00">2025-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-22 16:25:47" itemprop="dateModified" datetime="2025-12-22T16:25:47+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>“为什么需要操作系统”——本质是<strong>通过抽象与隔离解决多程序运行的安全、协作问题</strong>，同时提供更易用的接口。我为你拆解关键逻辑和细节：</p>
<h3 id="一、“库函数替代操作系统”的思路：可行但有致命缺陷"><a href="#一、“库函数替代操作系统”的思路：可行但有致命缺陷" class="headerlink" title="一、“库函数替代操作系统”的思路：可行但有致命缺陷"></a>一、“库函数替代操作系统”的思路：可行但有致命缺陷</h3><h4 id="1-思路本质"><a href="#1-思路本质" class="headerlink" title="1. 思路本质"></a>1. 思路本质</h4><p>把系统调用（如文件操作、硬件交互）做成库，应用程序直接链接使用，甚至定制库；应用程序直接访问硬件，按自己需求优化性能（比如嵌入式&#x2F;实时系统会这么做）。</p>
<h4 id="2-核心缺陷：依赖“合作式分时”，无法应对现实场景"><a href="#2-核心缺陷：依赖“合作式分时”，无法应对现实场景" class="headerlink" title="2. 核心缺陷：依赖“合作式分时”，无法应对现实场景"></a>2. 核心缺陷：依赖“合作式分时”，无法应对现实场景</h4><p>这种方案的前提是：<strong>所有运行的应用程序都“表现良好”</strong> ——比如主动放弃CPU让其他程序运行、不恶意占用硬件资源、没有bug。<br>但现实中：</p>
<ul>
<li>应用程序互不信任（比如恶意程序会抢占资源）；</li>
<li>程序必然存在bug（比如死循环会霸占CPU，导致其他程序无法运行）；</li>
<li>最终会出现资源抢占、程序崩溃互相影响的问题，无法实现可靠的多程序并发。</li>
</ul>
<h3 id="二、操作系统的核心价值：强隔离-资源抽象服务"><a href="#二、操作系统的核心价值：强隔离-资源抽象服务" class="headerlink" title="二、操作系统的核心价值：强隔离 + 资源抽象服务"></a>二、操作系统的核心价值：强隔离 + 资源抽象服务</h3><p>为了解决上述问题，操作系统的设计思路是：<strong>禁止应用程序直接访问敏感硬件，将硬件资源抽象为标准化服务</strong>，核心实现两个目标：</p>
<h4 id="1-强隔离：避免程序互相干扰"><a href="#1-强隔离：避免程序互相干扰" class="headerlink" title="1. 强隔离：避免程序互相干扰"></a>1. 强隔离：避免程序互相干扰</h4><p>操作系统作为“中间层”，接管所有硬件资源的直接访问权，应用程序只能通过系统调用间接使用资源：</p>
<ul>
<li>比如Unix程序不直接读写磁盘，而是通过<code>open/read/write/close</code>操作文件——操作系统统一管理磁盘，防止某个程序恶意改写磁盘数据，或错误操作导致其他程序数据丢失；</li>
<li>比如操作系统透明切换CPU（保存&#x2F;恢复进程寄存器），即使某个程序无限循环，也不会霸占CPU，其他程序仍能运行（这是“抢占式分时”，区别于库方案的“合作式分时”）；</li>
<li>比如进程通过<code>exec</code>构建内存映像，而非直接操作物理内存——操作系统决定进程的内存位置，甚至在内存不足时将数据换出到磁盘，避免程序直接操作内存导致的越界访问、数据冲突。</li>
</ul>
<h4 id="2-易用抽象：降低开发复杂度"><a href="#2-易用抽象：降低开发复杂度" class="headerlink" title="2. 易用抽象：降低开发复杂度"></a>2. 易用抽象：降低开发复杂度</h4><p>操作系统的抽象接口比直接操作硬件更友好，即使不考虑隔离，也能提升开发效率：</p>
<ul>
<li>路径名（如<code>/a/b/c</code>）比直接操作磁盘扇区更易理解和使用；</li>
<li>文件描述符统一抽象文件、管道、设备等资源——程序无需关心数据存在磁盘还是管道中，只需调用统一的<code>read/write</code>接口；</li>
<li>自动处理异常场景（如流水线中某个程序崩溃，内核会向下游进程发送EOF），无需程序员手动处理跨程序的错误传递。</li>
</ul>
<h3 id="三、Unix系统调用接口的设计精髓"><a href="#三、Unix系统调用接口的设计精髓" class="headerlink" title="三、Unix系统调用接口的设计精髓"></a>三、Unix系统调用接口的设计精髓</h3><p>Unix的系统调用接口（如图1.2）是“便利性”与“强隔离”的平衡：</p>
<ul>
<li>对程序员：接口简单统一（文件描述符、进程管理等核心抽象），无需关注硬件细节；</li>
<li>对系统：通过内核接管硬件实现隔离，保证多程序安全并发；</li>
<li>这不是抽象资源的唯一方式，但经过实践验证是高效、可靠的设计（也是Xv6复刻Unix接口的原因）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>操作系统的核心必要性：</p>
<ol>
<li>解决多程序运行的<strong>隔离与安全</strong>问题（避免互相干扰、恶意抢占）；</li>
<li>提供<strong>易用的资源抽象</strong>（降低硬件操作复杂度）；</li>
<li>实现<strong>可靠的资源调度</strong>（抢占式分时、内存管理等）。</li>
</ol>
<p>而“库函数替代操作系统”的方案，仅适用于单程序、高信任度（如专用嵌入式）场景，无法满足通用计算机的多程序并发需求。</p>
<hr>
<p>你想要我为你详细解释<strong>强隔离的硬件实现基础</strong>——包括CPU的特权模式（以RISC-V为例）、用户态与内核态的隔离机制，以及系统调用的安全切换流程，这些内容是操作系统实现强隔离的核心硬件支撑。</p>
<p>我会从“为什么需要硬件支持”入手，逐步拆解这些关键机制：</p>
<h3 id="一、强隔离的硬边界：必须的硬件保障"><a href="#一、强隔离的硬边界：必须的硬件保障" class="headerlink" title="一、强隔离的硬边界：必须的硬件保障"></a>一、强隔离的硬边界：必须的硬件保障</h3><p>强隔离的核心目标是：<strong>应用程序的错误或恶意行为，不能影响内核和其他应用程序</strong>。要实现这个目标，仅靠软件（比如库函数、规则约束）是不够的，必须有<strong>CPU硬件层面的强制限制</strong>，因为软件可以被绕过，但硬件指令的权限控制是底层的、无法被应用程序篡改的。</p>
<p>具体来说，硬件需要阻止应用程序做两件事：</p>
<ol>
<li>执行只有操作系统才能用的<strong>特权指令</strong>（比如操作中断、修改页表地址）；</li>
<li>访问（读&#x2F;写）内核或其他进程的内存数据&#x2F;指令。</li>
</ol>
<h3 id="二、RISC-V的三种执行模式：特权分级的硬件基础"><a href="#二、RISC-V的三种执行模式：特权分级的硬件基础" class="headerlink" title="二、RISC-V的三种执行模式：特权分级的硬件基础"></a>二、RISC-V的三种执行模式：特权分级的硬件基础</h3><p>RISC-V通过<strong>三种CPU执行模式</strong>来实现特权分级，不同模式拥有不同的指令执行权限，这是强隔离的硬件核心：</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>英文缩写</th>
<th>特权级别</th>
<th>核心作用</th>
<th>Xv6的使用方式</th>
</tr>
</thead>
<tbody><tr>
<td>机器模式</td>
<td>M-Mode</td>
<td>最高（完全特权）</td>
<td>负责初始化硬件、配置计算机（如设置内存、中断控制器），可以执行所有指令。</td>
<td>仅在启动时执行少量初始化代码，之后立即切换到管理模式。</td>
</tr>
<tr>
<td>管理模式</td>
<td>S-Mode</td>
<td>次高</td>
<td>执行操作系统内核代码，允许执行<strong>特权指令</strong>（如开关中断、修改页表）。</td>
<td>内核（Xv6）的运行模式，即<strong>内核空间</strong>。</td>
</tr>
<tr>
<td>用户模式</td>
<td>U-Mode</td>
<td>最低</td>
<td>执行应用程序代码，<strong>禁止执行任何特权指令</strong>。</td>
<td>应用程序的运行模式，即<strong>用户空间</strong>。</td>
</tr>
</tbody></table>
<h4 id="关键机制：特权指令的硬件拦截"><a href="#关键机制：特权指令的硬件拦截" class="headerlink" title="关键机制：特权指令的硬件拦截"></a>关键机制：特权指令的硬件拦截</h4><p>当应用程序在<strong>用户模式</strong>下试图执行特权指令时，CPU不会执行该指令，而是会：</p>
<ol>
<li>自动切换到<strong>管理模式</strong>（内核态）；</li>
<li>让内核代码处理这个“违规行为”（通常是直接终止该应用程序）。</li>
</ol>
<p>这种硬件级别的拦截，从根本上杜绝了应用程序擅自操作硬件或内核资源的可能。</p>
<h3 id="三、系统调用的安全切换：从用户态到内核态的唯一合法路径"><a href="#三、系统调用的安全切换：从用户态到内核态的唯一合法路径" class="headerlink" title="三、系统调用的安全切换：从用户态到内核态的唯一合法路径"></a>三、系统调用的安全切换：从用户态到内核态的唯一合法路径</h3><p>应用程序（用户态）需要调用内核功能（比如<code>read</code>、<code>write</code>系统调用）时，不能直接跳转到内核代码，必须通过CPU提供的<strong>专用指令</strong>完成安全切换，这个流程是操作系统安全的关键：</p>
<h4 id="1-RISC-V的ecall指令：唯一的入口"><a href="#1-RISC-V的ecall指令：唯一的入口" class="headerlink" title="1. RISC-V的ecall指令：唯一的入口"></a>1. RISC-V的<code>ecall</code>指令：唯一的入口</h4><p>应用程序想要进入内核，必须执行<code>ecall</code>指令（其他架构如x86是<code>int 0x80</code>或<code>syscall</code>）。这个指令的作用是：</p>
<ul>
<li>触发CPU从<strong>用户模式</strong>切换到<strong>管理模式</strong>；</li>
<li>强制跳转到<strong>内核预先指定的入口点</strong>（内核提前设置好的一段验证代码）。</li>
</ul>
<h4 id="2-内核的安全验证流程"><a href="#2-内核的安全验证流程" class="headerlink" title="2. 内核的安全验证流程"></a>2. 内核的安全验证流程</h4><p>当内核通过<code>ecall</code>入口点被唤醒后，会执行以下步骤，确保操作安全：</p>
<ol>
<li><strong>验证系统调用参数</strong>：检查应用程序传入的参数是否合法（比如文件描述符是否存在、内存地址是否属于该进程的合法空间）；</li>
<li><strong>权限检查</strong>：判断应用程序是否有权执行该操作（比如是否有权读写某个文件）；</li>
<li><strong>执行或拒绝</strong>：如果验证通过，内核执行请求的操作（比如读取文件数据）；如果验证失败，内核拒绝操作并返回错误（甚至终止应用）。</li>
</ol>
<h4 id="3-为什么入口点必须由内核控制？"><a href="#3-为什么入口点必须由内核控制？" class="headerlink" title="3. 为什么入口点必须由内核控制？"></a>3. 为什么入口点必须由内核控制？</h4><p>这是一个至关重要的安全设计：</p>
<ul>
<li>如果应用程序可以随意指定内核的入口点，恶意程序可以跳过参数验证步骤，直接执行内核的核心函数（比如修改内核的权限数据），从而突破隔离限制；</li>
<li>内核控制入口点，相当于给内核加了一道“安检门”，所有进入内核的请求都必须经过这道安检，确保安全。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>操作系统的<strong>强隔离</strong>需要<strong>CPU硬件的特权模式</strong>作为基础，RISC-V通过机器模式、管理模式、用户模式实现了特权分级，禁止用户态程序执行特权指令。</li>
<li>应用程序调用内核功能时，必须通过CPU的专用指令（如RISC-V的<code>ecall</code>），从用户态切换到内核态，且入口点由内核控制，确保所有请求都经过内核的安全验证。</li>
<li>硬件层面的权限控制+软件层面的安全验证，共同构成了应用程序与内核之间的硬边界，保证了单个应用的错误不会影响内核和其他应用。</li>
</ol>
<hr>
<p>RISC-V（发音为 “risk-five”）是一种开源免费的精简指令集（RISC）处理器指令集架构（ISA），由加州大学伯克利分校于 2010 年发起，核心目标是打造无专利壁垒、模块化、可灵活扩展的通用处理器架构标准，现已成为全球主流的处理器架构之一。<br>什么是 “指令集架构（ISA）”？<br>ISA 是软件（比如操作系统、应用程序）和硬件（处理器）之间的 “沟通语言”—— 它定义了处理器能识别执行的指令（比如加法、内存读写）、可用的寄存器、数据存储方式、硬件资源访问规则等。简单说：ISA 决定了程序员能 “指挥” 处理器做什么，以及怎么指挥；处理器则必须严格实现 ISA 定义的规则，才能运行对应的软件。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/21/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/21/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-21 19:20:42" itemprop="dateCreated datePublished" datetime="2025-12-21T19:20:42+08:00">2025-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-22 16:25:50" itemprop="dateModified" datetime="2025-12-22T16:25:50+08:00">2025-12-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>你想要我为你详细解释这段关于Xv6文件系统的核心概念和设计细节，包括文件、目录、inode、系统调用以及相关工具程序的设计逻辑，尤其是<code>cd</code>内置在shell的原因。</p>
<p>我会从核心概念入手，由浅入深地为你拆解这些内容：</p>
<h3 id="一、Xv6文件系统的核心结构与概念"><a href="#一、Xv6文件系统的核心结构与概念" class="headerlink" title="一、Xv6文件系统的核心结构与概念"></a>一、Xv6文件系统的核心结构与概念</h3><h4 id="1-目录与路径的逻辑"><a href="#1-目录与路径的逻辑" class="headerlink" title="1. 目录与路径的逻辑"></a>1. 目录与路径的逻辑</h4><p>Xv6的文件系统是<strong>树形结构</strong>，核心特点如下：</p>
<ul>
<li><strong>根目录</strong>：整个文件系统的起点（<code>/</code>），所有文件和目录都依附于这个根节点。</li>
<li><strong>绝对路径</strong>：以<code>/</code>开头（如<code>/a/b/c</code>），从根目录开始逐层查找。</li>
<li><strong>相对路径</strong>：不以<code>/</code>开头（如<code>b/c</code>），从进程的<strong>当前工作目录</strong>开始查找。</li>
<li><strong>当前工作目录</strong>：进程的一个属性，可通过<code>chdir</code>系统调用修改，这也是为什么代码中先<code>chdir(&quot;/a&quot;)</code>再<code>chdir(&quot;b&quot;)</code>后，<code>open(&quot;c&quot;)</code>能找到<code>/a/b/c</code>的原因。</li>
</ul>
<h4 id="2-三种核心文件类型与创建方式"><a href="#2-三种核心文件类型与创建方式" class="headerlink" title="2. 三种核心文件类型与创建方式"></a>2. 三种核心文件类型与创建方式</h4><p>Xv6将文件分为三类，各自有对应的创建系统调用：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>作用</th>
<th>创建方式</th>
</tr>
</thead>
<tbody><tr>
<td>数据文件</td>
<td>存储字节数组（无格式的原始数据）</td>
<td><code>open</code> + <code>O_CREATE</code>标志</td>
</tr>
<tr>
<td>目录</td>
<td>存储文件名与inode的映射关系</td>
<td><code>mkdir</code>系统调用</td>
</tr>
<tr>
<td>设备文件</td>
<td>关联内核设备（而非磁盘数据）</td>
<td><code>mknod</code>系统调用（需主&#x2F;次设备号）</td>
</tr>
</tbody></table>
<p>其中<strong>设备文件</strong>是特殊的：它不存储实际数据，而是通过主、次设备号关联内核中的设备驱动，当读写设备文件时，内核会调用对应的设备驱动的<code>read/write</code>函数，而非操作磁盘。</p>
<h4 id="3-inode（索引结点）与链接（link）：文件的本质与命名"><a href="#3-inode（索引结点）与链接（link）：文件的本质与命名" class="headerlink" title="3. inode（索引结点）与链接（link）：文件的本质与命名"></a>3. inode（索引结点）与链接（link）：文件的本质与命名</h4><p>这是Unix&#x2F;Linux（包括Xv6）文件系统的核心设计，需要重点理解：</p>
<ul>
<li><strong>文件名≠文件本身</strong>：文件名只是目录中一个<strong>指向inode的引用</strong>（链接），而<strong>inode才是文件的本质</strong>。</li>
<li><strong>inode的作用</strong>：存储文件的元数据，包括：<ul>
<li>文件类型（目录&#x2F;数据&#x2F;设备）、链接数（<code>nlink</code>）、大小、数据在磁盘的位置、inode编号（唯一标识）。</li>
</ul>
</li>
<li><strong>硬链接（link）</strong>：<code>link</code>系统调用会为同一个inode创建新的文件名，此时：<ul>
<li>两个文件名的<code>fstat</code>结果中，<strong>inode编号（ino）相同</strong>，<code>nlink</code>（链接数）会加1。</li>
<li>读写任意一个文件名，操作的都是同一个inode对应的内容。</li>
</ul>
</li>
<li><strong>解除链接（unlink）</strong>：<code>unlink</code>会删除一个文件名（链接），此时<code>nlink</code>减1。<strong>只有当<code>nlink=0</code>且没有文件描述符引用该inode时，inode和磁盘空间才会被释放</strong>。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件a，对应一个inode（nlink=1）</span></span><br><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line"><span class="comment">// 为该inode创建新链接b（nlink=2）</span></span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 删除链接a（nlink=1），此时inode仍存在，可通过b访问</span></span><br><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而临时文件的惯用写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件并得到文件描述符fd</span></span><br><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line"><span class="comment">// 删除文件名，此时inode仍被fd引用，不会释放</span></span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br><span class="line"><span class="comment">// 进程关闭fd或退出时，fd引用消失，inode被释放</span></span><br></pre></td></tr></table></figure>

<h3 id="二、文件工具程序的设计：用户级程序-vs-shell内置"><a href="#二、文件工具程序的设计：用户级程序-vs-shell内置" class="headerlink" title="二、文件工具程序的设计：用户级程序 vs shell内置"></a>二、文件工具程序的设计：用户级程序 vs shell内置</h3><p>Xv6（和Unix）的设计哲学是：<strong>将文件操作的工具（如mkdir、ln、rm）实现为用户级程序</strong>，而非内置在shell或内核中。这样做的好处是：</p>
<ol>
<li><strong>扩展性强</strong>：任何人都可以编写新的用户级程序来扩展命令行功能，无需修改shell或内核。</li>
<li><strong>简化设计</strong>：shell只需要负责解析命令、创建子进程执行用户级程序即可，无需内置大量命令逻辑。</li>
</ol>
<h4 id="例外：cd为什么是shell内置命令？"><a href="#例外：cd为什么是shell内置命令？" class="headerlink" title="例外：cd为什么是shell内置命令？"></a>例外：<code>cd</code>为什么是shell内置命令？</h4><p>这是一个关键的设计细节，原因如下：</p>
<ul>
<li>进程的<strong>当前工作目录</strong>是进程的私有属性，子进程无法修改父进程的属性。</li>
<li>如果<code>cd</code>是普通用户级程序：shell会创建一个子进程来执行<code>cd</code>，子进程执行<code>chdir</code>后，只会修改自己的当前工作目录，而父进程（shell）的当前工作目录完全不变，这会导致<code>cd</code>命令失去作用。</li>
<li>因此，<code>cd</code>必须作为shell的<strong>内置命令</strong>：执行<code>cd</code>时，不会创建子进程，而是直接在shell进程中调用<code>chdir</code>系统调用，修改shell自身的当前工作目录，这样才能达到预期效果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Xv6文件系统是树形结构，通过<strong>绝对路径&#x2F;相对路径</strong>定位文件，进程的当前工作目录可通过<code>chdir</code>修改。</li>
<li><strong>inode是文件的核心</strong>，文件名只是指向inode的链接；<code>link</code>创建硬链接（增加nlink），<code>unlink</code>删除链接（减少nlink），只有nlink&#x3D;0且无文件描述符引用时，inode才会被释放。</li>
<li>大部分文件工具是用户级程序，而<code>cd</code>必须内置在shell中，因为子进程无法修改父进程（shell）的当前工作目录。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/20/%E7%AC%AC%E4%B8%80%E7%AB%A0/git%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/20/%E7%AC%AC%E4%B8%80%E7%AB%A0/git%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">git使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-20 20:55:07 / 修改时间：20:59:26" itemprop="dateCreated datePublished" datetime="2025-12-20T20:55:07+08:00">2025-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Git 与 GitHub 使用指南（MIT 6.S081 课程专用）</p>
<p>目录</p>
<p>• #git-基础知识</p>
<p>• #远程仓库管理</p>
<p>• #mit-6s081-实验工作流程</p>
<p>• #常见问题与解决方案</p>
<p>• #高级技巧与最佳实践</p>
<p>Git 基础知识</p>
<ol>
<li>Git 是什么？</li>
</ol>
<p>Git 是一个分布式版本控制系统，用于跟踪代码的变更历史。每个开发者都有完整的仓库副本，支持多人协作开发。</p>
<ol start="2">
<li>Git 的三种状态</li>
</ol>
<p>工作目录 → 暂存区 → 本地仓库<br>    ↓          ↓         ↓<br> 已修改     已暂存     已提交</p>
<ol start="3">
<li>基础命令速查</li>
</ol>
<p>3.1 配置 Git</p>
<h1 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h1><p>git config –global user.name “你的名字”<br>git config –global user.email “你的邮箱”</p>
<h1 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h1><p>git config –list</p>
<p>3.2 仓库操作</p>
<h1 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h1><p>git init</p>
<h1 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h1><p>git clone &lt;仓库地址&gt;</p>
<h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><p>git status</p>
<p>3.3 提交工作流</p>
<h1 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h1><p>git add &lt;文件名&gt;    # 添加特定文件<br>git add .          # 添加所有修改</p>
<h1 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h1><p>git commit -m “提交说明”</p>
<h1 id="推送更改"><a href="#推送更改" class="headerlink" title="推送更改"></a>推送更改</h1><p>git push &lt;远程名&gt; &lt;分支名&gt;</p>
<h1 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h1><p>git pull &lt;远程名&gt; &lt;分支名&gt;</p>
<p>3.4 分支管理</p>
<h1 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h1><p>git branch          # 本地分支<br>git branch -a       # 所有分支<br>git branch -r       # 远程分支</p>
<h1 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h1><p>git branch &lt;分支名&gt;<br>git checkout -b &lt;分支名&gt;   # 创建并切换<br>git switch -c &lt;分支名&gt;     # Git 2.23+ 推荐</p>
<h1 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h1><p>git checkout &lt;分支名&gt;<br>git switch &lt;分支名&gt;</p>
<h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><p>git checkout 目标分支<br>git merge 源分支</p>
<h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><p>git branch -d &lt;分支名&gt;    # 安全删除<br>git branch -D &lt;分支名&gt;    # 强制删除</p>
<p>3.5 查看历史</p>
<p>git log                 # 详细历史<br>git log –oneline       # 简洁历史<br>git log –graph         # 图形化显示<br>git log -p              # 显示具体更改<br>git log –stat          # 统计信息</p>
<p>3.6 撤销操作</p>
<h1 id="撤销工作目录修改"><a href="#撤销工作目录修改" class="headerlink" title="撤销工作目录修改"></a>撤销工作目录修改</h1><p>git checkout – &lt;文件名&gt;</p>
<h1 id="撤销暂存区修改"><a href="#撤销暂存区修改" class="headerlink" title="撤销暂存区修改"></a>撤销暂存区修改</h1><p>git reset HEAD &lt;文件名&gt;</p>
<h1 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h1><p>git reset –soft HEAD<del>1    # 保留修改<br>git reset –hard HEAD</del>1    # 丢弃修改</p>
<p>远程仓库管理</p>
<ol>
<li>远程仓库概念</li>
</ol>
<p>在 MIT 6.S081 实验中，需要配置两个远程仓库：</p>
<h1 id="查看当前远程配置"><a href="#查看当前远程配置" class="headerlink" title="查看当前远程配置"></a>查看当前远程配置</h1><p>git remote -v</p>
<h1 id="典型输出："><a href="#典型输出：" class="headerlink" title="典型输出："></a>典型输出：</h1><p>github  <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">git@github.com</a>:hellonnnnn&#x2F;xv6-labs-2020.git (fetch)<br>github  <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#x6f;&#109;">git@github.com</a>:hellonnnnn&#x2F;xv6-labs-2020.git (push)<br>origin  git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020 (fetch)<br>origin  git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020 (push)</p>
<ol start="2">
<li>两个远程仓库的区别</li>
</ol>
<p>特性 github (你的仓库) origin (MIT 仓库)</p>
<p>地址 <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">git@github.com</a>:你的用户名&#x2F;仓库.git git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020</p>
<p>权限 读写权限 只读权限</p>
<p>用途 备份你的代码，提交作业 获取官方更新</p>
<p>操作 push, pull, fetch 只能 pull, fetch</p>
<p>内容 你的实验成果 原始实验代码</p>
<p>分支 你的实验分支 MIT 官方分支</p>
<ol start="3">
<li>远程仓库操作</li>
</ol>
<p>3.1 添加远程仓库</p>
<h1 id="添加-MIT-官方仓库"><a href="#添加-MIT-官方仓库" class="headerlink" title="添加 MIT 官方仓库"></a>添加 MIT 官方仓库</h1><p>git remote add origin git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020</p>
<h1 id="添加你的-GitHub-仓库"><a href="#添加你的-GitHub-仓库" class="headerlink" title="添加你的 GitHub 仓库"></a>添加你的 GitHub 仓库</h1><p>git remote add github <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;">git@github.com</a>:你的用户名&#x2F;仓库名.git</p>
<p>3.2 修改远程地址</p>
<h1 id="修改远程地址"><a href="#修改远程地址" class="headerlink" title="修改远程地址"></a>修改远程地址</h1><p>git remote set-url origin 新地址</p>
<h1 id="重命名远程"><a href="#重命名远程" class="headerlink" title="重命名远程"></a>重命名远程</h1><p>git remote rename 旧名称 新名称</p>
<h1 id="删除远程"><a href="#删除远程" class="headerlink" title="删除远程"></a>删除远程</h1><p>git remote remove 远程名</p>
<p>3.3 推送与拉取</p>
<h1 id="从-MIT-获取代码"><a href="#从-MIT-获取代码" class="headerlink" title="从 MIT 获取代码"></a>从 MIT 获取代码</h1><p>git fetch origin<br>git pull origin 分支名</p>
<h1 id="向-GitHub-推送代码"><a href="#向-GitHub-推送代码" class="headerlink" title="向 GitHub 推送代码"></a>向 GitHub 推送代码</h1><p>git push github 分支名:分支名<br>git push -u github 分支名  # 设置上游分支</p>
<h1 id="从-GitHub-拉取代码"><a href="#从-GitHub-拉取代码" class="headerlink" title="从 GitHub 拉取代码"></a>从 GitHub 拉取代码</h1><p>git pull github 分支名</p>
<ol start="4">
<li>记忆口诀</li>
</ol>
<p>“从官(origin)方拿，往自(github)己存”</p>
<p>MIT 6.S081 实验工作流程</p>
<ol>
<li>环境初始化</li>
</ol>
<p>步骤 1: 克隆 MIT 官方仓库</p>
<p>git clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020<br>cd xv6-labs-2020</p>
<p>步骤 2: 添加 GitHub 远程</p>
<p>git remote add github <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;">git@github.com</a>:你的用户名&#x2F;xv6-labs-2020.git</p>
<p>步骤 3: 验证配置</p>
<p>git remote -v</p>
<h1 id="应该显示两个远程仓库"><a href="#应该显示两个远程仓库" class="headerlink" title="应该显示两个远程仓库"></a>应该显示两个远程仓库</h1><ol start="2">
<li>实验分支结构</li>
</ol>
<p>main&#x2F;master (基础分支，可保持空)<br>├── util (实验1: 用户工具)<br>├── syscall (实验2: 系统调用)<br>├── pgtbl (实验3: 页表)<br>├── traps (实验4: 中断处理)<br>├── lazy (实验5: 惰性分配)<br>├── cow (实验6: 写时复制)<br>└── thread (实验7: 多线程)</p>
<ol start="3">
<li>开始一个新实验</li>
</ol>
<p>方法 A: 使用测试分支（推荐）</p>
<h1 id="1-切换到实验分支"><a href="#1-切换到实验分支" class="headerlink" title="1. 切换到实验分支"></a>1. 切换到实验分支</h1><p>git checkout syscall</p>
<h1 id="2-创建测试分支"><a href="#2-创建测试分支" class="headerlink" title="2. 创建测试分支"></a>2. 创建测试分支</h1><p>git checkout -b syscall_test</p>
<h1 id="3-完成实验任务"><a href="#3-完成实验任务" class="headerlink" title="3. 完成实验任务"></a>3. 完成实验任务</h1><h1 id="…-修改代码-…"><a href="#…-修改代码-…" class="headerlink" title="… 修改代码 …"></a>… 修改代码 …</h1><p>make qemu</p>
<h1 id="…-测试-…"><a href="#…-测试-…" class="headerlink" title="… 测试 …"></a>… 测试 …</h1><h1 id="4-提交更改"><a href="#4-提交更改" class="headerlink" title="4. 提交更改"></a>4. 提交更改</h1><p>git add .<br>git commit -m “完成 trace 系统调用”</p>
<h1 id="5-合并到主实验分支"><a href="#5-合并到主实验分支" class="headerlink" title="5. 合并到主实验分支"></a>5. 合并到主实验分支</h1><p>git checkout syscall<br>git merge syscall_test</p>
<h1 id="6-推送到-GitHub"><a href="#6-推送到-GitHub" class="headerlink" title="6. 推送到 GitHub"></a>6. 推送到 GitHub</h1><p>git push github syscall:syscall</p>
<p>方法 B: 直接在实验分支工作</p>
<h1 id="1-切换到实验分支-1"><a href="#1-切换到实验分支-1" class="headerlink" title="1. 切换到实验分支"></a>1. 切换到实验分支</h1><p>git checkout syscall</p>
<h1 id="2-获取-MIT-最新代码"><a href="#2-获取-MIT-最新代码" class="headerlink" title="2. 获取 MIT 最新代码"></a>2. 获取 MIT 最新代码</h1><p>git pull origin syscall</p>
<h1 id="3-直接修改提交"><a href="#3-直接修改提交" class="headerlink" title="3. 直接修改提交"></a>3. 直接修改提交</h1><h1 id="…-完成一个任务-…"><a href="#…-完成一个任务-…" class="headerlink" title="… 完成一个任务 …"></a>… 完成一个任务 …</h1><p>git add .<br>git commit -m “完成第一个任务”</p>
<h1 id="4-完成后推送到-GitHub"><a href="#4-完成后推送到-GitHub" class="headerlink" title="4. 完成后推送到 GitHub"></a>4. 完成后推送到 GitHub</h1><p>git push github syscall:syscall</p>
<ol start="4">
<li>每日工作流程</li>
</ol>
<h1 id="开始工作前"><a href="#开始工作前" class="headerlink" title="开始工作前"></a>开始工作前</h1><p>git checkout syscall_test<br>git status</p>
<h1 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h1><h1 id="…-修改代码-…-1"><a href="#…-修改代码-…-1" class="headerlink" title="… 修改代码 …"></a>… 修改代码 …</h1><p>git add .<br>git commit -m “进度更新”</p>
<h1 id="结束工作时"><a href="#结束工作时" class="headerlink" title="结束工作时"></a>结束工作时</h1><p>git checkout syscall<br>git merge syscall_test<br>git push github syscall:syscall</p>
<ol start="5">
<li>实验完成后的整理</li>
</ol>
<h1 id="1-清理测试分支"><a href="#1-清理测试分支" class="headerlink" title="1. 清理测试分支"></a>1. 清理测试分支</h1><p>git branch -d syscall_test</p>
<h1 id="2-确保主分支是最新状态"><a href="#2-确保主分支是最新状态" class="headerlink" title="2. 确保主分支是最新状态"></a>2. 确保主分支是最新状态</h1><p>git checkout syscall<br>git log –oneline</p>
<h1 id="3-创建标签（可选）"><a href="#3-创建标签（可选）" class="headerlink" title="3. 创建标签（可选）"></a>3. 创建标签（可选）</h1><p>git tag lab-syscall-complete<br>git push github –tags</p>
<ol start="6">
<li>多设备同步</li>
</ol>
<h1 id="在新设备上"><a href="#在新设备上" class="headerlink" title="在新设备上"></a>在新设备上</h1><p>git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">git@github.com</a>:你的用户名&#x2F;xv6-labs-2020.git<br>cd xv6-labs-2020<br>git remote add origin git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020<br>git checkout syscall<br>git pull github syscall</p>
<p>常见问题与解决方案</p>
<ol>
<li>分支相关错误</li>
</ol>
<p>问题: 分支不存在</p>
<p>error: pathspec ‘syscall’ did not match any file(s) known to git</p>
<p>解决方案:</p>
<h1 id="从-MIT-获取分支"><a href="#从-MIT-获取分支" class="headerlink" title="从 MIT 获取分支"></a>从 MIT 获取分支</h1><p>git fetch origin<br>git checkout -b syscall origin&#x2F;syscall</p>
<p>问题: 分支已存在</p>
<p>fatal: A branch named ‘syscall’ already exists.</p>
<p>解决方案:</p>
<h1 id="先切换到其他分支"><a href="#先切换到其他分支" class="headerlink" title="先切换到其他分支"></a>先切换到其他分支</h1><p>git checkout util</p>
<h1 id="删除已有分支"><a href="#删除已有分支" class="headerlink" title="删除已有分支"></a>删除已有分支</h1><p>git branch -d syscall</p>
<h1 id="或强制删除"><a href="#或强制删除" class="headerlink" title="或强制删除"></a>或强制删除</h1><p>git branch -D syscall</p>
<h1 id="重新创建"><a href="#重新创建" class="headerlink" title="重新创建"></a>重新创建</h1><p>git checkout -b syscall origin&#x2F;syscall</p>
<ol start="2">
<li>推送相关错误</li>
</ol>
<p>问题: 无上游分支</p>
<p>fatal: The current branch util has no upstream branch.</p>
<p>解决方案:<br>git push -u github util:util</p>
<p>问题: 权限被拒绝</p>
<p>remote: Permission to … denied to …<br>fatal: unable to access …</p>
<p>解决方案:</p>
<ol>
<li><p>检查 SSH 密钥配置</p>
</li>
<li><p>使用 HTTPS 和 token</p>
</li>
<li><p>确认有仓库的写入权限</p>
</li>
<li><p>合并冲突</p>
</li>
</ol>
<p>解决步骤:</p>
<ol>
<li><p>查看冲突文件<br>git status</p>
</li>
<li><p>手动编辑冲突文件</p>
<h1 id="HEAD"><a href="#HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD你的代码"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>你的代码</h1><p>他人代码</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>branch-name</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>标记冲突已解决<br>git add 冲突文件<br>git commit</p>
</li>
<li><p>误操作恢复</p>
</li>
</ol>
<p>恢复误删的分支</p>
<h1 id="查看引用日志"><a href="#查看引用日志" class="headerlink" title="查看引用日志"></a>查看引用日志</h1><p>git reflog</p>
<h1 id="找到删除前的提交"><a href="#找到删除前的提交" class="headerlink" title="找到删除前的提交"></a>找到删除前的提交</h1><p>git checkout -b 分支名 提交哈希</p>
<p>撤销错误的提交</p>
<h1 id="撤销但保留更改"><a href="#撤销但保留更改" class="headerlink" title="撤销但保留更改"></a>撤销但保留更改</h1><p>git reset –soft HEAD~1</p>
<h1 id="完全撤销"><a href="#完全撤销" class="headerlink" title="完全撤销"></a>完全撤销</h1><p>git reset –hard HEAD~1</p>
<ol start="5">
<li>MIT 仓库连接问题</li>
</ol>
<h1 id="如果-git-协议被阻挡"><a href="#如果-git-协议被阻挡" class="headerlink" title="如果 git:&#x2F;&#x2F; 协议被阻挡"></a>如果 git:&#x2F;&#x2F; 协议被阻挡</h1><p>git remote set-url origin <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv.git">https://github.com/mit-pdos/xv6-riscv.git</a></p>
<h1 id="或"><a href="#或" class="headerlink" title="或"></a>或</h1><p>git remote set-url origin <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-labs-2020.git">https://github.com/mit-pdos/xv6-labs-2020.git</a></p>
<p>高级技巧与最佳实践</p>
<ol>
<li>.gitignore 配置示例</li>
</ol>
<h1 id="针对-xv6-项目的-gitignore"><a href="#针对-xv6-项目的-gitignore" class="headerlink" title="针对 xv6 项目的 .gitignore"></a>针对 xv6 项目的 .gitignore</h1><p>*.o<br>*.ko<br>*.so<br>*.a<br>*.la<br>*.lo<br>*.d<br>*.dylib<br>*.dSYM&#x2F;<br>*.mod<br>*.mod.c<br>*.symvers<br>*.order<br>*.tar<br>*.tar.gz<br>*.tgz<br>*.zip<br>*.iso<br>*.img<br>*.elf</p>
<h1 id="编译输出"><a href="#编译输出" class="headerlink" title="编译输出"></a>编译输出</h1><p>xv6.img<br>fs.img<br>kernel<br>user&#x2F;usys.S<br>user&#x2F;_*<br>mkfs<br>initcode<br>initcode.out</p>
<h1 id="编辑器文件"><a href="#编辑器文件" class="headerlink" title="编辑器文件"></a>编辑器文件</h1><p>*.swp<br>*~<br>.DS_Store<br>.vscode&#x2F;<br>.idea&#x2F;</p>
<h1 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h1><p>*.log<br>*.tmp</p>
<ol start="2">
<li>Git 别名设置</li>
</ol>
<h1 id="添加到-gitconfig"><a href="#添加到-gitconfig" class="headerlink" title="添加到 ~&#x2F;.gitconfig"></a>添加到 ~&#x2F;.gitconfig</h1><p>[alias]<br>  st &#x3D; status<br>  co &#x3D; checkout<br>  br &#x3D; branch<br>  ci &#x3D; commit<br>  df &#x3D; diff<br>  lg &#x3D; log –graph –pretty&#x3D;format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit</p>
<ol start="3">
<li>自动化脚本</li>
</ol>
<p>实验初始化脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<h1 id="init-xv6-lab-sh"><a href="#init-xv6-lab-sh" class="headerlink" title="init-xv6-lab.sh"></a>init-xv6-lab.sh</h1><p>echo “&#x3D;&#x3D;&#x3D; 初始化 MIT 6.S081 实验环境 &#x3D;&#x3D;&#x3D;”</p>
<h1 id="克隆-MIT-仓库"><a href="#克隆-MIT-仓库" class="headerlink" title="克隆 MIT 仓库"></a>克隆 MIT 仓库</h1><p>git clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;xv6-labs-2020<br>cd xv6-labs-2020</p>
<h1 id="添加-GitHub-远程"><a href="#添加-GitHub-远程" class="headerlink" title="添加 GitHub 远程"></a>添加 GitHub 远程</h1><p>read -p “请输入 GitHub 仓库地址: “ github_url<br>git remote add github $github_url</p>
<h1 id="创建基础分支"><a href="#创建基础分支" class="headerlink" title="创建基础分支"></a>创建基础分支</h1><p>git checkout –orphan base<br>git commit –allow-empty -m “基础分支”<br>git branch -M main</p>
<p>echo “环境初始化完成！”</p>
<p>实验进度检查脚本</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<h1 id="check-progress-sh"><a href="#check-progress-sh" class="headerlink" title="check-progress.sh"></a>check-progress.sh</h1><p>echo “&#x3D;&#x3D;&#x3D; 实验进度检查 &#x3D;&#x3D;&#x3D;”<br>echo “”</p>
<p>branches&#x3D;(“util” “syscall” “pgtbl” “traps” “lazy” “cow” “thread”)</p>
<p>for branch in “${branches[@]}”; do<br>    echo “分支: $branch”<br>    if git show-ref –verify –quiet refs&#x2F;heads&#x2F;$branch; then<br>        git log –oneline -1 $branch<br>    else<br>        echo “  尚未开始”<br>    fi<br>    echo “—“<br>done</p>
<ol start="4">
<li>高效工作技巧</li>
</ol>
<p>4.1 分步提交</p>
<h1 id="每个小功能完成后提交"><a href="#每个小功能完成后提交" class="headerlink" title="每个小功能完成后提交"></a>每个小功能完成后提交</h1><p>git add .<br>git commit -m “功能: 实现系统调用框架”</p>
<h1 id="测试通过后"><a href="#测试通过后" class="headerlink" title="测试通过后"></a>测试通过后</h1><p>git add .<br>git commit -m “测试: 系统调用基本功能通过”</p>
<h1 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h1><p>git add .<br>git commit -m “优化: 改进系统调用性能”</p>
<p>4.2 使用暂存</p>
<h1 id="临时保存当前工作"><a href="#临时保存当前工作" class="headerlink" title="临时保存当前工作"></a>临时保存当前工作</h1><p>git stash</p>
<h1 id="查看暂存列表"><a href="#查看暂存列表" class="headerlink" title="查看暂存列表"></a>查看暂存列表</h1><p>git stash list</p>
<h1 id="恢复暂存"><a href="#恢复暂存" class="headerlink" title="恢复暂存"></a>恢复暂存</h1><p>git stash pop</p>
<p>4.3 选择性提交</p>
<h1 id="交互式添加"><a href="#交互式添加" class="headerlink" title="交互式添加"></a>交互式添加</h1><p>git add -p</p>
<h1 id="只提交部分文件"><a href="#只提交部分文件" class="headerlink" title="只提交部分文件"></a>只提交部分文件</h1><p>git add 文件1 文件2<br>git commit -m “只提交特定文件”</p>
<ol start="5">
<li>协作与备份</li>
</ol>
<p>设置多个备份仓库</p>
<h1 id="添加-Gitee-作为国内备份"><a href="#添加-Gitee-作为国内备份" class="headerlink" title="添加 Gitee 作为国内备份"></a>添加 Gitee 作为国内备份</h1><p>git remote add gitee <a target="_blank" rel="noopener" href="https://gitee.com/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93.git">https://gitee.com/你的用户名/仓库.git</a></p>
<h1 id="推送到所有远程"><a href="#推送到所有远程" class="headerlink" title="推送到所有远程"></a>推送到所有远程</h1><p>git push –all github<br>git push –all gitee</p>
<p>定期同步</p>
<h1 id="从-MIT-获取更新"><a href="#从-MIT-获取更新" class="headerlink" title="从 MIT 获取更新"></a>从 MIT 获取更新</h1><p>git fetch origin</p>
<h1 id="合并到本地分支"><a href="#合并到本地分支" class="headerlink" title="合并到本地分支"></a>合并到本地分支</h1><p>git checkout syscall<br>git merge origin&#x2F;syscall</p>
<h1 id="推送到所有备份"><a href="#推送到所有备份" class="headerlink" title="推送到所有备份"></a>推送到所有备份</h1><p>git push github syscall:syscall<br>git push gitee syscall:syscall</p>
<ol start="6">
<li>调试与诊断</li>
</ol>
<p>查看仓库状态</p>
<h1 id="完整诊断"><a href="#完整诊断" class="headerlink" title="完整诊断"></a>完整诊断</h1><p>git status<br>git log –oneline -5<br>git branch -a<br>git remote -v</p>
<p>清理仓库</p>
<h1 id="移除未跟踪文件"><a href="#移除未跟踪文件" class="headerlink" title="移除未跟踪文件"></a>移除未跟踪文件</h1><p>git clean -n  # 预览<br>git clean -f  # 执行</p>
<h1 id="压缩仓库"><a href="#压缩仓库" class="headerlink" title="压缩仓库"></a>压缩仓库</h1><p>git gc</p>
<p>总结备忘单</p>
<p>基本工作流</p>
<h1 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h1><p>git pull origin 分支名</p>
<h1 id="保存工作"><a href="#保存工作" class="headerlink" title="保存工作"></a>保存工作</h1><p>git add .<br>git commit -m “描述”<br>git push github 分支名:分支名</p>
<h1 id="切换实验"><a href="#切换实验" class="headerlink" title="切换实验"></a>切换实验</h1><p>git checkout 实验分支名</p>
<p>紧急恢复</p>
<h1 id="查看所有操作记录"><a href="#查看所有操作记录" class="headerlink" title="查看所有操作记录"></a>查看所有操作记录</h1><p>git reflog</p>
<h1 id="恢复到任意状态"><a href="#恢复到任意状态" class="headerlink" title="恢复到任意状态"></a>恢复到任意状态</h1><p>git reset –hard 提交哈希</p>
<p>获取帮助</p>
<h1 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h1><p>git help 命令<br>git 命令 –help</p>
<h1 id="查看具体使用"><a href="#查看具体使用" class="headerlink" title="查看具体使用"></a>查看具体使用</h1><p>git 命令 -h</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/20/%E7%AC%AC%E4%B8%80%E7%AB%A0/Unix-Linux-%E7%AE%A1%E9%81%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/20/%E7%AC%AC%E4%B8%80%E7%AB%A0/Unix-Linux-%E7%AE%A1%E9%81%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Unix/Linux 管道的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-20 16:08:59 / 修改时间：16:16:03" itemprop="dateCreated datePublished" datetime="2025-12-20T16:08:59+08:00">2025-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="管道（Pipe）原理与Xv6-shell实现笔记"><a href="#管道（Pipe）原理与Xv6-shell实现笔记" class="headerlink" title="管道（Pipe）原理与Xv6 shell实现笔记"></a>管道（Pipe）原理与Xv6 shell实现笔记</h1><h2 id="一、管道核心概念"><a href="#一、管道核心概念" class="headerlink" title="一、管道核心概念"></a>一、管道核心概念</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>管道是内核提供的小型缓冲区，通过一对文件描述符（读端<code>p[0]</code>、写端<code>p[1]</code>）暴露给进程，数据从写端写入、读端读取，实现进程间通信（IPC）。</p>
<h3 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2. 核心特性"></a>2. 核心特性</h3><ul>
<li><strong>半双工</strong>：数据仅能从写端流向读端，无法反向传输。</li>
<li><strong>阻塞机制</strong>：<ul>
<li>管道为空时，<code>read</code>操作阻塞，直到有数据写入或所有写端关闭（此时<code>read</code>返回0，类似文件末尾）。</li>
<li>管道满时（内核缓冲区有限，通常几KB），<code>write</code>操作阻塞，直到数据被读取。</li>
</ul>
</li>
<li><strong>字节流传输</strong>：数据无边界，读取方需自行处理分割（如按行、按空格）。</li>
<li><strong>生命周期</strong>：所有关联文件描述符关闭后，内核释放管道缓冲区，管道销毁。</li>
</ul>
<h2 id="二、管道使用示例代码解析"><a href="#二、管道使用示例代码解析" class="headerlink" title="二、管道使用示例代码解析"></a>二、管道使用示例代码解析</h2><h3 id="1-完整代码（Unix-Linux环境）"><a href="#1-完整代码（Unix-Linux环境）" class="headerlink" title="1. 完整代码（Unix&#x2F;Linux环境）"></a>1. 完整代码（Unix&#x2F;Linux环境）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>]; <span class="comment">// 管道描述符：p[0]读端，p[1]写端</span></span><br><span class="line">    <span class="type">char</span> *argv[<span class="number">2</span>]; <span class="comment">// wc命令参数数组</span></span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>; <span class="comment">// 命令名</span></span><br><span class="line">    argv[<span class="number">1</span>] = <span class="literal">NULL</span>; <span class="comment">// 参数数组以NULL结尾（exec要求）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(p) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程：执行wc，从管道读数据</span></span><br><span class="line">        close(<span class="number">0</span>); <span class="comment">// 关闭标准输入（默认终端）</span></span><br><span class="line">        dup(p[<span class="number">0</span>]); <span class="comment">// 复制管道读端到最小未用描述符（0，即标准输入）</span></span><br><span class="line">        close(p[<span class="number">0</span>]); <span class="comment">// 关闭原始读端（已重定向，无需保留）</span></span><br><span class="line">        close(p[<span class="number">1</span>]); <span class="comment">// 必须关闭写端（否则wc认为有进程可能写数据，永久阻塞）</span></span><br><span class="line">        execvp(<span class="string">&quot;wc&quot;</span>, argv); <span class="comment">// 执行wc，标准输入绑定管道读端</span></span><br><span class="line">        perror(<span class="string">&quot;execvp&quot;</span>); <span class="comment">// exec失败时执行</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程：向管道写数据</span></span><br><span class="line">        close(p[<span class="number">0</span>]); <span class="comment">// 关闭读端（父进程仅写）</span></span><br><span class="line">        write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">// 写入数据</span></span><br><span class="line">        close(p[<span class="number">1</span>]); <span class="comment">// 关闭写端（让子进程感知数据结束）</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束，避免僵尸进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关键步骤说明"><a href="#2-关键步骤说明" class="headerlink" title="2. 关键步骤说明"></a>2. 关键步骤说明</h3><table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>pipe(p)</code></td>
<td>创建管道，内核分配缓冲区，返回读&#x2F;写描述符</td>
</tr>
<tr>
<td><code>fork()</code></td>
<td>子进程复制父进程文件描述符表，父子共享管道描述符</td>
</tr>
<tr>
<td>子进程<code>close(0) + dup(p[0])</code></td>
<td>将管道读端绑定到标准输入（wc从管道读取数据）</td>
</tr>
<tr>
<td>子进程<code>close(p[1])</code></td>
<td>关闭写端，避免wc永久阻塞</td>
</tr>
<tr>
<td>父进程<code>close(p[0])</code></td>
<td>关闭读端，避免资源泄漏</td>
</tr>
<tr>
<td>父进程<code>close(p[1])</code></td>
<td>关闭写端，触发子进程wc的EOF检测</td>
</tr>
</tbody></table>
<h3 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1       2      12  # 1行、2个单词、12个字符（包含换行符）</span><br></pre></td></tr></table></figure>

<h2 id="三、Xv6-shell管道实现"><a href="#三、Xv6-shell管道实现" class="headerlink" title="三、Xv6 shell管道实现"></a>三、Xv6 shell管道实现</h2><h3 id="1-进程树结构"><a href="#1-进程树结构" class="headerlink" title="1. 进程树结构"></a>1. 进程树结构</h3><p>Xv6 shell处理<code>cmd1 | cmd2 | cmd3</code>时，会构建<strong>进程树</strong>：</p>
<ul>
<li><strong>叶子节点</strong>：执行具体命令（如<code>grep</code>、<code>wc</code>）的进程。</li>
<li><strong>内部节点</strong>：每个管道<code>|</code>对应一个进程，作用为：<ol>
<li>创建管道连接左右命令；</li>
<li>fork两个子进程分别运行左右命令；</li>
<li>等待子进程完成后退出。</li>
</ol>
</li>
</ul>
<h3 id="2-设计取舍：为何保留内部节点进程？"><a href="#2-设计取舍：为何保留内部节点进程？" class="headerlink" title="2. 设计取舍：为何保留内部节点进程？"></a>2. 设计取舍：为何保留内部节点进程？</h3><p>理论上可让内部节点直接运行左&#x2F;右命令（减少进程创建），但会导致逻辑复杂：</p>
<ul>
<li>若内部进程运行左命令（如<code>echo hi</code>），命令退出后内部进程也退出，无法运行右命令（如<code>wc</code>）；</li>
<li>若内部进程运行右命令（如<code>echo hi</code>），右命令不会等待左命令（如<code>sleep 10</code>）完成，导致时序错误（<code>sleep 10 | echo hi</code>立即输出）。</li>
</ul>
<p>为保证代码简洁，Xv6 shell选择保留内部节点进程，牺牲少量性能换取逻辑正确性。</p>
<h2 id="四、核心要点总结"><a href="#四、核心要点总结" class="headerlink" title="四、核心要点总结"></a>四、核心要点总结</h2><ol>
<li>管道通过内核缓冲区实现进程间通信，依赖文件描述符重定向；</li>
<li>必须关闭无用的管道描述符（尤其是写端），否则读取进程会永久阻塞；</li>
<li>Xv6 shell通过进程树实现多管道命令，内部节点进程负责管道管理和等待子进程；</li>
<li>管道是字节流、半双工，阻塞特性由内核控制。</li>
</ol>
<h1 id="管道-vs-临时文件：核心优势解析"><a href="#管道-vs-临时文件：核心优势解析" class="headerlink" title="管道 vs 临时文件：核心优势解析"></a>管道 vs 临时文件：核心优势解析</h1><p>管道与临时文件都能实现“前序命令输出作为后序命令输入”的效果，但管道在自动化、性能、并行性和语义适配性上具备显著优势，以下是详细对比：管道看起来并不比临时文件更强大：下面的管道命令行<br>echo hello world | wc<br>可以不通过管道实现，如下<br>echo hello world &gt; &#x2F;tmp&#x2F;xyz; wc &lt; &#x2F;tmp&#x2F;xyz<br>区别在于：</p>
<h2 id="一、自动清理，无残留风险"><a href="#一、自动清理，无残留风险" class="headerlink" title="一、自动清理，无残留风险"></a>一、自动清理，无残留风险</h2><ul>
<li><strong>临时文件</strong>：使用后需手动删除（如<code>rm /tmp/xyz</code>），若程序异常退出（如被中断、崩溃），临时文件会残留，长期积累会占用磁盘空间，甚至导致同名文件覆盖、权限冲突等问题（例如多个进程同时使用<code>/tmp/xyz</code>）。</li>
<li><strong>管道</strong>：管道的生命周期与关联进程绑定——当所有读写进程退出、管道描述符全部关闭时，内核会自动释放管道缓冲区，无需人工干预，不存在残留垃圾，也避免了临时文件的命名冲突问题。</li>
</ul>
<h2 id="二、无需磁盘空间，支持流式传输"><a href="#二、无需磁盘空间，支持流式传输" class="headerlink" title="二、无需磁盘空间，支持流式传输"></a>二、无需磁盘空间，支持流式传输</h2><ul>
<li><strong>临时文件</strong>：必须将完整数据写入磁盘文件后，后续程序才能读取，依赖磁盘空闲空间。若传输超大数据流（如GB级日志、视频流），磁盘空间不足会导致操作失败；且磁盘I&#x2F;O速度远低于内存，数据写入&#x2F;读取会产生显著延迟。</li>
<li><strong>管道</strong>：数据存储在内核缓冲区（内存中），采用“流式传输”——前序进程写入一部分数据，后序进程即可读取一部分，无需等待完整数据生成。即使传输TB级数据流，只要内核缓冲区能周转，就无需依赖磁盘空间，且内存I&#x2F;O速度远快于磁盘，效率更高。</li>
</ul>
<h2 id="三、支持并行执行，提升整体效率"><a href="#三、支持并行执行，提升整体效率" class="headerlink" title="三、支持并行执行，提升整体效率"></a>三、支持并行执行，提升整体效率</h2><ul>
<li><strong>临时文件</strong>：必须严格串行执行——前序命令（如<code>echo hello world &gt; /tmp/xyz</code>）完全执行并将所有数据写入文件后，后序命令（如<code>wc &lt; /tmp/xyz</code>）才能启动，总耗时为两个命令耗时之和（<code>T总 = T1 + T2</code>）。</li>
<li><strong>管道</strong>：前后命令可并行执行——前序进程（<code>echo</code>）写入数据的同时，后序进程（<code>wc</code>）可立即读取并处理，无需等待前序进程结束。例如<code>大型日志生成 | grep 关键词</code>场景中，日志生成到一半时，<code>grep</code>已开始匹配，总耗时接近较慢进程的耗时（<code>T总 ≈ max(T1, T2)</code>），大幅缩短执行时间。</li>
</ul>
<h2 id="四、阻塞式语义适配进程通信，更高效"><a href="#四、阻塞式语义适配进程通信，更高效" class="headerlink" title="四、阻塞式语义适配进程通信，更高效"></a>四、阻塞式语义适配进程通信，更高效</h2><ul>
<li><strong>临时文件</strong>：文件操作的核心语义是“非阻塞”——写入文件后数据持久化，读取时只需从磁盘加载，无需等待写入方；但进程间通信时，若后序进程读取速度快于前序进程写入速度，会出现“读空”（需轮询文件是否有新数据），若前序进程写入速度快，会占用大量磁盘空间，轮询和磁盘I&#x2F;O都会产生额外开销。</li>
<li><strong>管道</strong>：管道的阻塞式读写语义完全适配进程间通信需求：<ul>
<li>读端阻塞：若管道为空，读进程（如<code>wc</code>）会自动阻塞，直到写进程（如<code>echo</code>）写入数据或所有写端关闭，无需轮询，减少CPU消耗；</li>
<li>写端阻塞：若管道缓冲区满，写进程会阻塞，直到读进程读取数据，避免数据溢出，天然实现“生产-消费”的速率匹配；<br>这种阻塞机制由内核实现，无需用户态代码干预，比文件的轮询&#x2F;非阻塞处理更高效、更简洁。</li>
</ul>
</li>
</ul>
<h2 id="补充：管道的隐藏优势——无磁盘I-O损耗"><a href="#补充：管道的隐藏优势——无磁盘I-O损耗" class="headerlink" title="补充：管道的隐藏优势——无磁盘I&#x2F;O损耗"></a>补充：管道的隐藏优势——无磁盘I&#x2F;O损耗</h2><p>临时文件的所有数据都需经过“内存→磁盘→内存”的两次拷贝（前序进程写磁盘、后序进程读磁盘），而管道数据仅在“进程内存→内核缓冲区→进程内存”之间拷贝，全程无磁盘参与，对于高频、小数据量的进程通信（如shell命令链、程序模块间交互），管道的延迟和资源占用远低于临时文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/18/%E7%AC%AC%E4%B8%80%E7%AB%A0/fork+exec%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/18/%E7%AC%AC%E4%B8%80%E7%AB%A0/fork+exec%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">xv6-labs-2020 lab1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-18 20:27:43 / 修改时间：20:55:11" itemprop="dateCreated datePublished" datetime="2025-12-18T20:27:43+08:00">2025-12-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="fork-exec：Unix-Linux（xv6）执行程序的核心模式"><a href="#fork-exec：Unix-Linux（xv6）执行程序的核心模式" class="headerlink" title="fork + exec：Unix &#x2F; Linux（xv6）执行程序的核心模式"></a>fork + exec：Unix &#x2F; Linux（xv6）执行程序的核心模式</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># fork + exec：Unix / xv6 执行程序的核心模型</span></span><br><span class="line"></span><br><span class="line">先明确一个核心概念：<span class="strong">**fork + exec 是 Unix / Linux（包括 xv6）执行程序的经典模式**</span>。</span><br><span class="line"></span><br><span class="line">你给出的代码片段中，<span class="code">`exec`</span> 会用目标程序（如 <span class="code">`/bin/echo`</span>）<span class="strong">**替换当前进程的代码和数据**</span>，但需要特别注意的是：</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; <span class="strong">**exec 本身不会创建新进程**</span></span></span><br><span class="line"></span><br><span class="line">因此，实际使用中必须先通过 <span class="code">`fork`</span> 创建子进程，再在子进程中调用 <span class="code">`exec`</span>。  </span><br><span class="line">这样既能保留父进程（shell），又能让子进程执行新程序，这正是 <span class="strong">**xv6 shell 的核心逻辑**</span>。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">## xv6 shell 执行 `echo hello` 的完整流程（结合源码）</span></span><br><span class="line"></span><br><span class="line">下面以用户在 xv6 shell 中输入：</span><br><span class="line"></span><br><span class="line"><span class="code">```text</span></span><br><span class="line"><span class="code">echo hello</span></span><br></pre></td></tr></table></figure>

<p>为例，结合 <code>user/sh.c</code> 的关键位置，拆解整个执行过程。</p>
<hr>
<h2 id="步骤-1：shell-主循环等待用户输入"><a href="#步骤-1：shell-主循环等待用户输入" class="headerlink" title="步骤 1：shell 主循环等待用户输入"></a>步骤 1：shell 主循环等待用户输入</h2><p><strong>位置：<code>main()</code>（<code>user/sh.c:145</code>）</strong></p>
<p>xv6 的 shell 运行在一个无限循环中，主要完成两件事：</p>
<ol>
<li>打印命令提示符（如 <code>$ </code>）</li>
<li>调用 <code>getcmd()</code> 读取用户输入的一行命令</li>
</ol>
<p>此时：</p>
<ul>
<li>shell 是<strong>父进程</strong></li>
<li>处于前台运行状态</li>
<li>等待用户输入命令</li>
</ul>
<hr>
<h2 id="步骤-2：创建子进程（fork）"><a href="#步骤-2：创建子进程（fork）" class="headerlink" title="步骤 2：创建子进程（fork）"></a>步骤 2：创建子进程（<code>fork</code>）</h2><p>当用户输入 <code>echo hello</code> 并回车后，shell 调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br></pre></td></tr></table></figure>

<p><code>fork()</code> 会创建一个与当前进程几乎完全相同的子进程：</p>
<ul>
<li><p><strong>父进程（shell）</strong></p>
<ul>
<li><code>fork()</code> 返回子进程的 PID</li>
<li>随后调用 <code>wait()</code> 或 <code>waitpid()</code>，进入阻塞状态</li>
</ul>
</li>
<li><p><strong>子进程</strong></p>
<ul>
<li><code>fork()</code> 返回 <code>0</code></li>
<li>继续执行后续的命令处理逻辑</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>关键点：</strong></p>
<ul>
<li><code>fork</code> 是“复制”，不是重新创建</li>
<li>子进程在 <code>exec</code> 之前与父进程共享相同的代码和数据</li>
</ul>
</blockquote>
<hr>
<h2 id="步骤-3：子进程调用-runcmd-处理命令"><a href="#步骤-3：子进程调用-runcmd-处理命令" class="headerlink" title="步骤 3：子进程调用 runcmd 处理命令"></a>步骤 3：子进程调用 <code>runcmd</code> 处理命令</h2><p><strong>位置：<code>runcmd()</code>（<code>user/sh.c:58</code>）</strong></p>
<p>子进程会解析用户输入的命令：</p>
<ul>
<li>命令名：<code>echo</code></li>
<li>参数：<code>hello</code></li>
</ul>
<p>并构造参数数组 <code>argv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;   <span class="comment">// 程序名</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 参数</span></span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;       <span class="comment">// 参数数组必须以 NULL 结尾</span></span><br></pre></td></tr></table></figure>

<p>同时，<code>runcmd</code> 会确定可执行文件路径，例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/echo</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="步骤-4：子进程调用-exec-替换程序"><a href="#步骤-4：子进程调用-exec-替换程序" class="headerlink" title="步骤 4：子进程调用 exec 替换程序"></a>步骤 4：子进程调用 <code>exec</code> 替换程序</h2><p><strong>位置：<code>user/sh.c:78</code></strong></p>
<p>子进程调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br></pre></td></tr></table></figure>

<p><code>exec</code> 的行为是：</p>
<ul>
<li>丢弃当前子进程的代码和数据</li>
<li>加载 <code>/bin/echo</code> 的代码和数据</li>
<li>从 <code>echo</code> 程序的 <code>main</code> 函数开始执行</li>
</ul>
<blockquote>
<p>如果 <code>exec</code> 调用成功：</p>
<ul>
<li>当前进程将不再是 shell 的副本</li>
<li>之前的 <code>runcmd</code> 代码不会再执行</li>
<li><code>printf(&quot;exec error\n&quot;)</code> 不会被执行</li>
</ul>
</blockquote>
<hr>
<h2 id="步骤-5：echo-程序执行并调用-exit"><a href="#步骤-5：echo-程序执行并调用-exit" class="headerlink" title="步骤 5：echo 程序执行并调用 exit"></a>步骤 5：<code>echo</code> 程序执行并调用 <code>exit</code></h2><p><code>echo</code> 程序运行后：</p>
<ol>
<li><p>向标准输出打印：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure></li>
<li><p>调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>子进程终止，并通知父进程。</p>
<hr>
<h2 id="步骤-6：父进程（shell）从-wait-返回"><a href="#步骤-6：父进程（shell）从-wait-返回" class="headerlink" title="步骤 6：父进程（shell）从 wait 返回"></a>步骤 6：父进程（shell）从 <code>wait</code> 返回</h2><p>父进程中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>返回后：</p>
<ul>
<li>shell 回收子进程资源</li>
<li>清除僵尸进程</li>
<li>重新回到主循环</li>
<li>再次打印提示符，等待下一条命令</li>
</ul>
<hr>
<h2 id="exec-失败时会发生什么？"><a href="#exec-失败时会发生什么？" class="headerlink" title="exec 失败时会发生什么？"></a>exec 失败时会发生什么？</h2><p>如果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br></pre></td></tr></table></figure>

<p>执行失败（如文件不存在），则：</p>
<ul>
<li>当前进程不会被替换</li>
<li>会继续执行后续代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>随后子进程退出，父进程依然会从 <code>wait()</code> 返回。</p>
<hr>
<h2 id="为什么-argv-0-是程序名？"><a href="#为什么-argv-0-是程序名？" class="headerlink" title="为什么 argv[0] 是程序名？"></a>为什么 <code>argv[0]</code> 是程序名？</h2><p>原因包括：</p>
<ol>
<li><p><strong>Unix 规范约定</strong></p>
<ul>
<li><code>argv[0]</code> 表示程序名</li>
<li><code>argv[1]</code> 及以后才是实际参数</li>
</ul>
</li>
<li><p><strong>程序自身可能使用 <code>argv[0]</code></strong></p>
<ul>
<li>同一个程序根据启动名执行不同逻辑（如 <code>busybox</code>）</li>
</ul>
</li>
<li><p><strong>xv6 的简化实现</strong></p>
<ul>
<li>多数 xv6 程序忽略 <code>argv[0]</code></li>
<li>但依然遵循该参数规范</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="核心结论"><a href="#核心结论" class="headerlink" title="核心结论"></a>核心结论</h3><ul>
<li><strong>fork + exec 是 Unix &#x2F; xv6 执行程序的标准模式</strong></li>
<li><code>fork</code> 负责创建进程</li>
<li><code>exec</code> 负责加载并运行新程序</li>
<li>shell 通过 <code>wait</code> 保持自身持续运行</li>
</ul>
<h3 id="echo-hello-的完整链路"><a href="#echo-hello-的完整链路" class="headerlink" title="echo hello 的完整链路"></a><code>echo hello</code> 的完整链路</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell 读取命令</span><br><span class="line">→ fork 创建子进程</span><br><span class="line">→ 子进程解析命令</span><br><span class="line">→ exec 加载 /bin/echo</span><br><span class="line">→ echo 输出 hello 并 exit</span><br><span class="line">→ 父进程 wait 返回</span><br><span class="line">→ shell 继续等待输入</span><br></pre></td></tr></table></figure>

<p>这一设计实现了 <strong>进程创建与程序执行的解耦</strong>，也是 Unix shell 能持续工作的根本原因。</p>
<p>以下是runcmd函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">backcmd</span> *<span class="title">bcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listcmd</span> *<span class="title">lcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    panic(<span class="string">&quot;runcmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> EXEC:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> REDIR:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> LIST:</span><br><span class="line">    lcmd = (<span class="keyword">struct</span> listcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(lcmd-&gt;left);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    runcmd(lcmd-&gt;right);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> PIPE:</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">1</span>);</span><br><span class="line">      dup(p[<span class="number">1</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">0</span>);</span><br><span class="line">      dup(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> BACK:</span><br><span class="line">    bcmd = (<span class="keyword">struct</span> backcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(bcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一、函数整体功能总结"><a href="#一、函数整体功能总结" class="headerlink" title="一、函数整体功能总结"></a>一、函数整体功能总结</h3><p><code>runcmd</code>是一个递归函数，它接收一个<code>struct cmd</code>类型的命令节点（这个节点是shell解析用户输入后生成的抽象语法树节点），通过<code>switch</code>判断命令的类型（<code>EXEC</code>&#x2F;<code>REDIR</code>&#x2F;<code>LIST</code>&#x2F;<code>PIPE</code>&#x2F;<code>BACK</code>），然后执行对应的逻辑。核心依赖<code>fork1</code>（xv6的<code>fork</code>封装）、<code>exec</code>、<code>pipe</code>、<code>dup</code>、<code>wait</code>等系统调用，实现了Unix shell的核心功能。</p>
<h3 id="二、关键数据结构说明"><a href="#二、关键数据结构说明" class="headerlink" title="二、关键数据结构说明"></a>二、关键数据结构说明</h3><p>代码中出现的<code>struct cmd</code>及其子结构体是xv6对不同命令的封装，每个子结构体对应一种命令类型：</p>
<ul>
<li><code>struct execcmd</code>：普通执行命令（如<code>echo hello</code>），包含命令参数数组<code>argv</code>；</li>
<li><code>struct redircmd</code>：重定向命令（如<code>echo hello &gt; file.txt</code>），包含重定向的文件描述符<code>fd</code>、文件名<code>file</code>、打开模式<code>mode</code>，以及被重定向的子命令<code>cmd</code>；</li>
<li><code>struct listcmd</code>：顺序执行命令（如<code>echo hello ; ls</code>），包含左命令<code>left</code>和右命令<code>right</code>；</li>
<li><code>struct pipecmd</code>：管道命令（如<code>ls | grep txt</code>），包含左命令<code>left</code>（管道写端）和右命令<code>right</code>（管道读端）；</li>
<li><code>struct backcmd</code>：后台运行命令（如<code>sleep 10 &amp;</code>），包含后台执行的子命令<code>cmd</code>；</li>
<li><code>cmd-&gt;type</code>：标识命令类型的枚举（<code>EXEC</code>&#x2F;<code>REDIR</code>等）。</li>
</ul>
<h3 id="三、逐模块解析代码逻辑"><a href="#三、逐模块解析代码逻辑" class="headerlink" title="三、逐模块解析代码逻辑"></a>三、逐模块解析代码逻辑</h3><h4 id="1-基础判断：空命令直接退出"><a href="#1-基础判断：空命令直接退出" class="headerlink" title="1. 基础判断：空命令直接退出"></a>1. 基础判断：空命令直接退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果命令节点为空（解析失败），子进程直接退出，返回错误状态。</p>
<hr>
<h4 id="2-EXEC：执行普通程序（核心分支，如echo-hello）"><a href="#2-EXEC：执行普通程序（核心分支，如echo-hello）" class="headerlink" title="2. EXEC：执行普通程序（核心分支，如echo hello）"></a>2. EXEC：执行普通程序（核心分支，如<code>echo hello</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EXEC:</span><br><span class="line">  ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑拆解</strong>：</p>
<ul>
<li>将<code>cmd</code>强转为<code>execcmd</code>（普通执行命令结构体），获取参数数组<code>argv</code>；</li>
<li>如果<code>argv[0]</code>为空（无命令名），直接退出；</li>
<li>调用<code>exec</code>系统调用，加载并执行<code>argv[0]</code>对应的程序（如<code>/bin/echo</code>），参数为<code>argv</code>；</li>
<li><strong>如果<code>exec</code>返回，说明执行失败</strong>（因为成功的<code>exec</code>会替换进程代码，不会返回），此时打印错误信息；</li>
<li>注意：这里的<code>exec</code>是xv6的封装，对应你之前看到的<code>exec(&quot;/bin/echo&quot;, argv)</code>逻辑。</li>
</ul>
<hr>
<h4 id="3-REDIR：处理输入输出重定向（如echo-hello-file-txt）"><a href="#3-REDIR：处理输入输出重定向（如echo-hello-file-txt）" class="headerlink" title="3. REDIR：处理输入输出重定向（如echo hello &gt; file.txt）"></a>3. REDIR：处理输入输出重定向（如<code>echo hello &gt; file.txt</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REDIR:</span><br><span class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑拆解（以<code>echo hello &gt; file.txt</code>为例）</strong>：</p>
<ul>
<li><code>rcmd-&gt;fd</code>：要重定向的文件描述符（如stdout是1，stdin是0，stderr是2）；</li>
<li><code>close(rcmd-&gt;fd)</code>：关闭原来的文件描述符（比如关闭stdout（1））；</li>
<li><code>open(rcmd-&gt;file, rcmd-&gt;mode)</code>：打开目标文件（如<code>file.txt</code>，写模式），此时系统会分配<strong>最小的可用文件描述符</strong>（也就是刚才关闭的1）；</li>
<li>递归调用<code>runcmd(rcmd-&gt;cmd)</code>：执行被重定向的命令（如<code>echo hello</code>），此时命令的输出（原本写向stdout（1））会被重定向到<code>file.txt</code>；</li>
<li><strong>核心原理</strong>：利用Unix文件描述符的“最小可用”规则，通过<code>close</code>+<code>open</code>实现重定向（xv6也支持<code>dup</code>实现，逻辑一致）。</li>
</ul>
<hr>
<h4 id="4-LIST：处理顺序执行命令（如echo-hello-ls）"><a href="#4-LIST：处理顺序执行命令（如echo-hello-ls）" class="headerlink" title="4. LIST：处理顺序执行命令（如echo hello ; ls）"></a>4. LIST：处理顺序执行命令（如<code>echo hello ; ls</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LIST:</span><br><span class="line">  lcmd = (<span class="keyword">struct</span> listcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(lcmd-&gt;left);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  runcmd(lcmd-&gt;right);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑拆解</strong>：</p>
<ul>
<li><code>lcmd-&gt;left</code>：左边的命令（如<code>echo hello</code>），<code>lcmd-&gt;right</code>：右边的命令（如<code>ls</code>）；</li>
<li><code>fork1()</code>创建子进程，子进程执行左命令；</li>
<li>父进程调用<code>wait(0)</code>，阻塞等待左命令执行完毕；</li>
<li>左命令执行完后，父进程再执行右命令；</li>
<li>特点：<strong>顺序执行</strong>，左命令完成后才会执行右命令。</li>
</ul>
<hr>
<h4 id="5-PIPE：处理管道命令（如ls-grep-txt）"><a href="#5-PIPE：处理管道命令（如ls-grep-txt）" class="headerlink" title="5. PIPE：处理管道命令（如ls | grep txt）"></a>5. PIPE：处理管道命令（如<code>ls | grep txt</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">  pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    dup(p[<span class="number">1</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  close(p[<span class="number">0</span>]);</span><br><span class="line">  close(p[<span class="number">1</span>]);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这是最复杂的分支，<strong>核心是利用<code>pipe</code>创建管道，将左命令的输出作为右命令的输入</strong>。</p>
<p><strong>逻辑拆解（以<code>ls | grep txt</code>为例）</strong>：</p>
<ol>
<li><strong>创建管道</strong>：<code>pipe(p)</code>创建一个管道，<code>p[0]</code>是<strong>读端</strong>，<code>p[1]</code>是<strong>写端</strong>；</li>
<li><strong>处理左命令（<code>ls</code>，管道写端）</strong>：<ul>
<li><code>fork1()</code>创建子进程1；</li>
<li><code>close(1)</code>：关闭子进程1的stdout（1）；</li>
<li><code>dup(p[1])</code>：复制管道写端<code>p[1]</code>到stdout（1）（因为1是最小可用描述符）；</li>
<li><code>close(p[0])</code>和<code>close(p[1])</code>：关闭多余的管道描述符（只保留重定向后的stdout）；</li>
<li>执行左命令<code>ls</code>，此时<code>ls</code>的输出会写入管道写端<code>p[1]</code>；</li>
</ul>
</li>
<li><strong>处理右命令（<code>grep txt</code>，管道读端）</strong>：<ul>
<li><code>fork1()</code>创建子进程2；</li>
<li><code>close(0)</code>：关闭子进程2的stdin（0）；</li>
<li><code>dup(p[0])</code>：复制管道读端<code>p[0]</code>到stdin（0）；</li>
<li><code>close(p[0])</code>和<code>close(p[1])</code>：关闭多余的管道描述符；</li>
<li>执行右命令<code>grep txt</code>，此时<code>grep</code>会从管道读端<code>p[0]</code>读取<code>ls</code>的输出；</li>
</ul>
</li>
<li><strong>父进程处理</strong>：<ul>
<li><code>close(p[0])</code>和<code>close(p[1])</code>：父进程关闭管道描述符（否则子进程退出后管道不会被释放）；</li>
<li><code>wait(0)</code>两次：等待两个子进程都执行完毕；</li>
</ul>
</li>
</ol>
<ul>
<li><strong>核心原理</strong>：管道是单向的，左进程写管道，右进程读管道，通过<code>dup</code>将管道描述符重定向到标准输入&#x2F;输出。</li>
</ul>
<hr>
<h4 id="6-BACK：处理后台运行命令（如sleep-10-）"><a href="#6-BACK：处理后台运行命令（如sleep-10-）" class="headerlink" title="6. BACK：处理后台运行命令（如sleep 10 &amp;）"></a>6. BACK：处理后台运行命令（如<code>sleep 10 &amp;</code>）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BACK:</span><br><span class="line">  bcmd = (<span class="keyword">struct</span> backcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">    runcmd(bcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑拆解</strong>：</p>
<ul>
<li><code>fork1()</code>创建子进程，子进程执行后台命令（如<code>sleep 10</code>）；</li>
<li><strong>父进程不调用<code>wait(0)</code></strong>：这是和普通命令的关键区别，父进程（shell）不会阻塞，直接返回继续处理下一条命令；</li>
<li>特点：命令在后台运行，shell无需等待，用户可以立即输入新命令；</li>
<li>注意：xv6的后台处理比较简化，没有处理僵尸进程（实际Unix shell会用信号处理）。</li>
</ul>
<hr>
<h4 id="7-函数末尾：退出进程"><a href="#7-函数末尾：退出进程" class="headerlink" title="7. 函数末尾：退出进程"></a>7. 函数末尾：退出进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>无论哪种命令类型执行完毕（除了<code>exec</code>成功的情况，因为<code>exec</code>会替换代码，不会走到这里），子进程都会调用<code>exit(0)</code>退出。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h3 id="关键点回顾"><a href="#关键点回顾" class="headerlink" title="关键点回顾"></a>关键点回顾</h3><ol>
<li><strong>核心逻辑</strong>：<code>runcmd</code>通过<strong>类型判断+递归调用</strong>，处理xv6 shell的所有命令类型，依赖<code>fork</code>+<code>exec</code>实现程序执行，依赖<code>pipe</code>+<code>dup</code>实现管道，依赖<code>close</code>+<code>open</code>实现重定向。</li>
<li><strong>各命令类型的核心差异</strong>：<ul>
<li><code>EXEC</code>：直接<code>exec</code>执行程序，失败则打印错误；</li>
<li><code>REDIR</code>：先重定向文件描述符，再递归执行命令；</li>
<li><code>LIST</code>：<code>fork</code>执行左命令，<code>wait</code>后执行右命令；</li>
<li><code>PIPE</code>：创建管道，两个子进程分别处理左右命令，实现数据传递；</li>
<li><code>BACK</code>：<code>fork</code>执行命令，父进程不<code>wait</code>，后台运行；</li>
</ul>
</li>
<li><strong>xv6的简化处理</strong>：相比实际Unix shell，xv6的<code>runcmd</code>省略了信号处理（如后台进程的僵尸回收）、通配符解析、环境变量等功能，但保留了shell的核心骨架。</li>
</ol>
<p>这个函数是xv6 shell的“心脏”，理解它的逻辑就能掌握xv6如何处理用户命令的本质。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ivan-FYF</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
