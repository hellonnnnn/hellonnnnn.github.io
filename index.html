<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hellonnnnn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="记录 C++、Linux、系统方向学习与项目">
<meta property="og:type" content="website">
<meta property="og:title" content="Ivan&#39;s Tech Blog">
<meta property="og:url" content="https://hellonnnnn.github.io/index.html">
<meta property="og:site_name" content="Ivan&#39;s Tech Blog">
<meta property="og:description" content="记录 C++、Linux、系统方向学习与项目">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ivan-FYF">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hellonnnnn.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ivan's Tech Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ivan's Tech Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">C++ / Linux / System Programming</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ivan-FYF</p>
  <div class="site-description" itemprop="description">记录 C++、Linux、系统方向学习与项目</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2026/01/22/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/22/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E5%A4%A9/" class="post-title-link" itemprop="url">算法训练营第一天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2026-01-22 11:29:44 / 修改时间：13:58:08" itemprop="dateCreated datePublished" datetime="2026-01-22T11:29:44+08:00">2026-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a><br>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</a><br>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715">https://www.bilibili.com/video/BV1fA4y1o715</a></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>左右初始化</th>
<th>while条件</th>
<th>mid是否加一</th>
</tr>
</thead>
<tbody><tr>
<td>左闭右开</td>
<td>left &#x3D; 0, right &#x3D; nums.size()</td>
<td>left &lt; right</td>
<td>right &#x3D; mid ， left &#x3D; mid + 1</td>
</tr>
<tr>
<td>左闭右闭</td>
<td>left &#x3D; 0, right &#x3D; nums.size() - 1</td>
<td>left &lt;&#x3D; right</td>
<td>right &#x3D; mid - 1， left &#x3D; mid + 1</td>
</tr>
</tbody></table>
<h2 id="1-左闭右开-left-right-区间"><a href="#1-左闭右开-left-right-区间" class="headerlink" title="1. 左闭右开 [left, right) 区间"></a>1. 左闭右开 [left, right) 区间</h2><h3 id="核心规则回顾"><a href="#核心规则回顾" class="headerlink" title="核心规则回顾"></a>核心规则回顾</h3><ul>
<li>初始化：<code>left = 0</code>，<code>right = nums.size()</code>（右边界是“开区间”，不包含，所以初始右边界是数组长度，而非最后一个元素的索引）</li>
<li><code>while</code>条件：<code>left &lt; right</code>（当<code>left == right</code>时，区间<code>[left, right)</code>是空的，没有元素需要检查）</li>
<li>区间划分：<ul>
<li>若<code>nums[mid] &gt; target</code>：目标在左半区，<code>right = mid</code>（右开区间，mid本身不包含在新的左半区里）</li>
<li>若<code>nums[mid] &lt; target</code>：目标在右半区，<code>left = mid + 1</code>（左闭区间，mid已检查过，需排除）</li>
</ul>
</li>
</ul>
<h3 id="循环结束后left的位置"><a href="#循环结束后left的位置" class="headerlink" title="循环结束后left的位置"></a>循环结束后<code>left</code>的位置</h3><p>循环结束时必然满足 <code>left == right</code>，这个位置的意义：</p>
<ul>
<li>如果<code>target</code>存在：循环中会提前<code>return mid</code>，不会走到循环结束；</li>
<li>如果<code>target</code>不存在：<code>left</code>（等于<code>right</code>）是<strong>target应该插入数组的位置</strong>（保证插入后数组仍有序）。</li>
</ul>
<h2 id="2-左闭右闭-left-right-区间"><a href="#2-左闭右闭-left-right-区间" class="headerlink" title="2. 左闭右闭 [left, right] 区间"></a>2. 左闭右闭 [left, right] 区间</h2><h3 id="核心规则回顾-1"><a href="#核心规则回顾-1" class="headerlink" title="核心规则回顾"></a>核心规则回顾</h3><ul>
<li>初始化：<code>left = 0</code>，<code>right = nums.size() - 1</code>（右边界是“闭区间”，包含，所以初始是最后一个元素的索引）</li>
<li><code>while</code>条件：<code>left &lt;= right</code>（当<code>left == right</code>时，区间<code>[left, right]</code>还有1个元素，需要检查）</li>
<li>区间划分：<ul>
<li>若<code>nums[mid] &gt; target</code>：目标在左半区，<code>right = mid - 1</code>（右闭区间，mid已检查过，需明确排除）</li>
<li>若<code>nums[mid] &lt; target</code>：目标在右半区，<code>left = mid + 1</code>（左闭区间，mid已检查过，需排除）</li>
</ul>
</li>
</ul>
<h3 id="循环结束后left的位置-1"><a href="#循环结束后left的位置-1" class="headerlink" title="循环结束后left的位置"></a>循环结束后<code>left</code>的位置</h3><p>循环结束时必然满足 <code>left = right + 1</code>，这个位置的意义和左闭右开一致：</p>
<ul>
<li>如果<code>target</code>存在：循环中提前<code>return mid</code>；</li>
<li>如果<code>target</code>不存在：<code>left</code>是<strong>target应该插入数组的位置</strong>。</li>
</ul>
<hr>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.size() || nums[left] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> begin = left;</span><br><span class="line">        left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;begin, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遇到边界问题，求左边界，等于target时，right &#x3D; mid - 1，求右边界时，left &#x3D; mid + 1。<br>求左边界时，left有可能越界，所以判断一下，如果left &gt;&#x3D; nums.size() || nums[left] !&#x3D; target，说明没有找到，返回{-1, -1}。<br>求右边界时，right不可能越界，left有可能越界，但不影响结果，所以直接返回right。</p>
<p>模版：<br>解决溢出问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> begin = left;</span><br><span class="line">        left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//不加一会死循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;begin,right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2026/01/21/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E8%B9%A6%E5%BA%8A%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/21/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E8%B9%A6%E5%BA%8A%E9%A1%B5/" class="post-title-link" itemprop="url">蹦床页</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2026-01-21 15:32:03 / 修改时间：15:32:16" itemprop="dateCreated datePublished" datetime="2026-01-21T15:32:03+08:00">2026-01-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 xv6 操作系统中，<strong>蹦床页（trampoline page）</strong> 是一段用于实现 <strong>用户态 ↔ 内核态安全切换</strong> 的特殊汇编代码页面，是连接用户空间与内核空间的「跳板」，核心解决了陷阱处理过程中<strong>页表切换时代码执行连续性</strong>的关键问题。</p>
<h3 id="一、蹦床页的核心特性"><a href="#一、蹦床页的核心特性" class="headerlink" title="一、蹦床页的核心特性"></a>一、蹦床页的核心特性</h3><ol>
<li><p><strong>地址一致性映射</strong><br> 蹦床页对应的物理页被同时映射到 <strong>所有用户进程的页表</strong> 和 <strong>内核页表</strong> 的 <strong>同一个固定虚拟地址</strong>（<code>TRAMPOLINE</code>，如 <code>0xFFFF000000000000</code>）。</p>
<ul>
<li>对用户页表：权限为<strong>用户态可执行</strong>，仅包含蹦床页代码，无其他内核数据；</li>
<li>对内核页表：权限为<strong>内核态可执行</strong>，与用户页表映射相同的物理页。<br> 这种设计的核心目的是：<strong>页表切换前后，CPU 能持续执行蹦床页的代码，不会因地址无效而崩溃</strong>。</li>
</ul>
</li>
<li><p><strong>代码极简且无状态依赖</strong><br> 蹦床页仅包含两段核心汇编代码，不存储任何进程私有数据：</p>
<ul>
<li><code>uservec</code>：用户态陷阱的入口函数，负责保存用户寄存器、切换到内核页表和内核栈；</li>
<li><code>userret</code>：内核态返回用户态的函数，负责切换回用户页表、恢复用户寄存器并执行 <code>sret</code> 指令。</li>
</ul>
</li>
<li><p><strong>安全隔离性</strong><br> 蹦床页代码不直接访问用户进程的私有数据，仅通过<strong>陷阱帧（trapframe）</strong> 交互——陷阱帧是每个进程的私有结构，映射在用户页表的 <code>TRAPFRAME</code> 地址，用于暂存用户寄存器和内核切换所需的信息（如内核页表地址、内核栈地址）。</p>
</li>
</ol>
<h3 id="二、蹦床页的核心作用（解决的关键问题）"><a href="#二、蹦床页的核心作用（解决的关键问题）" class="headerlink" title="二、蹦床页的核心作用（解决的关键问题）"></a>二、蹦床页的核心作用（解决的关键问题）</h3><p>xv6 设计蹦床页的根本原因是 <strong>RISC-V 硬件在陷阱触发时不会自动切换页表</strong>，而用户态陷阱处理需要跨越「用户页表→内核页表」的边界，具体问题和解决方案如下：</p>
<table>
<thead>
<tr>
<th>核心问题</th>
<th>蹦床页的解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>用户态陷阱入口代码需要在用户页表中可访问</td>
<td><code>stvec</code> 寄存器指向蹦床页的 <code>uservec</code>，用户页表已映射该地址，陷阱触发后 CPU 能直接执行</td>
</tr>
<tr>
<td>切换到内核页表后，代码需要继续执行</td>
<td>蹦床页在用户&#x2F;内核页表的虚拟地址相同，切换页表后 <code>PC</code> 指向的地址仍有效，代码不中断</td>
</tr>
<tr>
<td>用户态与内核态的栈、页表切换需要安全过渡</td>
<td>蹦床页的汇编代码完成「保存用户寄存器→切换内核栈→切换内核页表」的原子化操作，无数据丢失</td>
</tr>
</tbody></table>
<h3 id="三、蹦床页在陷阱处理中的工作流程"><a href="#三、蹦床页在陷阱处理中的工作流程" class="headerlink" title="三、蹦床页在陷阱处理中的工作流程"></a>三、蹦床页在陷阱处理中的工作流程</h3><p>以<strong>用户态触发系统调用（<code>ecall</code>）</strong> 为例，蹦床页的执行链路如下：</p>
<ol>
<li><strong>用户态触发陷阱</strong>：用户程序执行 <code>ecall</code>，CPU 切换到 S 模式，跳转到 <code>stvec</code> 指向的 <code>uservec</code>（蹦床页代码），此时仍使用<strong>用户页表</strong>。</li>
<li><strong><code>uservec</code> 执行（用户页表下）</strong>：<ul>
<li>交换 <code>a0</code> 与 <code>sscratch</code>，获取陷阱帧地址 <code>TRAPFRAME</code>；</li>
<li>将所有用户寄存器保存到陷阱帧；</li>
<li>从陷阱帧读取内核页表地址、内核栈地址，切换 <code>satp</code> 寄存器到<strong>内核页表</strong>，刷新 TLB。</li>
</ul>
</li>
<li><strong>跳转到内核 C 函数</strong>：<code>uservec</code> 跳转到 <code>usertrap()</code>，内核开始处理系统调用&#x2F;中断&#x2F;异常。</li>
<li><strong>内核返回用户态</strong>：<code>usertrapret()</code> 调用蹦床页的 <code>userret</code> 函数，切换回<strong>用户页表</strong>，从陷阱帧恢复所有用户寄存器。</li>
<li><strong><code>sret</code> 返回用户态</strong>：执行 <code>sret</code> 指令，CPU 切回 U 模式，从陷阱发生的下一条指令继续执行。</li>
</ol>
<h3 id="四、蹦床页的设计取舍（xv6-vs-真实OS）"><a href="#四、蹦床页的设计取舍（xv6-vs-真实OS）" class="headerlink" title="四、蹦床页的设计取舍（xv6 vs 真实OS）"></a>四、蹦床页的设计取舍（xv6 vs 真实OS）</h3><ul>
<li><strong>xv6 用蹦床页</strong>：为了<strong>教学简化</strong>和<strong>严格隔离</strong>，通过蹦床页的显式页表切换，直观展示用户态与内核态的边界，避免内核内存映射到用户页表带来的安全风险。</li>
<li><strong>真实OS（如 Linux）不用蹦床页</strong>：将内核核心代码映射到每个用户页表的高地址空间（用户态不可访问），陷阱处理时无需切换页表，直接执行内核代码，效率更高。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>蹦床页的本质是 <strong>xv6 为解决用户&#x2F;内核页表隔离下的陷阱处理连续性问题而设计的跳板代码页</strong>，通过「同一地址跨页表映射」和「极简汇编代码」，实现了用户态与内核态的安全、高效切换，是理解 xv6 特权级管理的核心概念。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2026/01/21/unbuntu%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E4%B8%8D%E8%B6%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/21/unbuntu%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E4%B8%8D%E8%B6%B3/" class="post-title-link" itemprop="url">unbuntu系统存储不足</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2026-01-21 14:37:06 / 修改时间：14:37:27" itemprop="dateCreated datePublished" datetime="2026-01-21T14:37:06+08:00">2026-01-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="长期维护建议"><a href="#长期维护建议" class="headerlink" title="长期维护建议"></a>长期维护建议</h3><p>为了避免以后再出现空间不足的问题，可以定期执行以下命令清理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一键清理 APT 缓存+无用依赖+Snap 旧版本</span></span><br><span class="line"><span class="built_in">sudo</span> apt clean &amp;&amp; <span class="built_in">sudo</span> apt autoremove --purge -y &amp;&amp; <span class="built_in">sudo</span> snap remove --purge $(snap list --all | awk <span class="string">&#x27;/disabled/&#123;print $1&quot; &quot;$3&#125;&#x27;</span>) 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/trap-c%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/trap-c%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">trap.c详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-29 21:06:03 / 修改时间：21:26:13" itemprop="dateCreated datePublished" datetime="2025-12-29T21:06:03+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="xv6-trap-c-源码全解析：陷阱（中断-异常-系统调用）处理核心"><a href="#xv6-trap-c-源码全解析：陷阱（中断-异常-系统调用）处理核心" class="headerlink" title="xv6 trap.c 源码全解析：陷阱（中断&#x2F;异常&#x2F;系统调用）处理核心"></a>xv6 trap.c 源码全解析：陷阱（中断&#x2F;异常&#x2F;系统调用）处理核心</h1><p><code>trap.c</code> 是 xv6 处理 RISC-V 架构<strong>陷阱（Trap）</strong> 的核心文件，负责接管所有「用户态→内核态」的切换（系统调用、用户态中断&#x2F;异常）和「内核态自身的中断&#x2F;异常」，是理解 xv6 特权级切换、中断处理、系统调用分发的关键。以下按「代码结构、核心函数、关键逻辑、设计思路」逐层解析。</p>
<h2 id="一、文件核心作用"><a href="#一、文件核心作用" class="headerlink" title="一、文件核心作用"></a>一、文件核心作用</h2><p>陷阱是 RISC-V CPU 对「中断（如计时器、外设）、异常（如页面错误、非法指令）、系统调用（ecall）」的统一响应机制。该文件实现：</p>
<ol>
<li>陷阱初始化（设置陷阱入口、自旋锁）；</li>
<li>用户态陷阱处理（<code>usertrap</code>）与返回（<code>usertrapret</code>）；</li>
<li>内核态陷阱处理（<code>kerneltrap</code>）；</li>
<li>设备中断识别（<code>devintr</code>）与时钟中断（<code>clockintr</code>）；</li>
<li>衔接蹦床页（trampoline）完成用户&#x2F;内核页表切换。</li>
</ol>
<h2 id="二、前置声明与全局变量"><a href="#二、前置声明与全局变量" class="headerlink" title="二、前置声明与全局变量"></a>二、前置声明与全局变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护 ticks 计数器的自旋锁（多核心安全）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line"><span class="comment">// 系统启动后的时钟滴答数（计时器中断累加）</span></span><br><span class="line">uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部声明：蹦床页的汇编函数（trampoline.S）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[], uservec[], userret[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部声明：kernelvec.S 中的内核陷阱入口，会调用 kerneltrap()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernelvec</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部声明：设备中断处理函数（识别并处理外设中断）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">devintr</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>trampoline/uservec/userret</code>：蹦床页的汇编代码，负责用户态陷阱的入口&#x2F;返回、页表切换；</li>
<li><code>kernelvec</code>：内核态陷阱的汇编入口，会保存寄存器后调用 <code>kerneltrap</code>；</li>
<li><code>ticks</code>：全局时钟计数器，用于系统计时、进程调度（计时器中断触发）。</li>
</ul>
<h2 id="三、初始化函数：陷阱环境准备"><a href="#三、初始化函数：陷阱环境准备" class="headerlink" title="三、初始化函数：陷阱环境准备"></a>三、初始化函数：陷阱环境准备</h2><h3 id="1-trapinit：全局初始化"><a href="#1-trapinit：全局初始化" class="headerlink" title="1. trapinit：全局初始化"></a>1. trapinit：全局初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trapinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化保护 <code>ticks</code> 的自旋锁 <code>tickslock</code>，避免多核心同时修改 <code>ticks</code> 导致竞态。</li>
</ul>
<h3 id="2-trapinithart：每个核心的陷阱入口设置"><a href="#2-trapinithart：每个核心的陷阱入口设置" class="headerlink" title="2. trapinithart：每个核心的陷阱入口设置"></a>2. trapinithart：每个核心的陷阱入口设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trapinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>w_stvec</code>：写入 RISC-V 的 <code>stvec</code> 寄存器（陷阱向量基址）；</li>
<li>作用：设置<strong>内核态</strong>的陷阱入口为 <code>kernelvec</code>（汇编函数），内核执行时触发的所有陷阱（中断&#x2F;异常）都会跳转到 <code>kernelvec</code>。</li>
</ul>
<h2 id="四、用户态陷阱处理：usertrap（核心）"><a href="#四、用户态陷阱处理：usertrap（核心）" class="headerlink" title="四、用户态陷阱处理：usertrap（核心）"></a>四、用户态陷阱处理：usertrap（核心）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验：必须来自用户态（SSTATUS_SPP=0 表示上一级是用户态）</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换内核态的陷阱入口：后续内核内的陷阱跳转到 kernelvec</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存用户态的程序计数器（sepc）到进程的 trapframe</span></span><br><span class="line">  <span class="comment">// sepc 存储触发陷阱的用户态指令地址（如 ecall）</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 场景1：处理系统调用（scause=8 表示用户态 ecall）</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 若进程已被标记为 killed，直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 epc：sepc 指向 ecall 指令，返回时需执行下一条（+4 字节）</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启中断（此前陷阱触发时硬件自动关中断，系统调用可响应外设中断）</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发系统调用（syscall.c）：读取 trapframe 的 a7（调用号），执行对应函数</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 场景2：处理设备中断（devintr 识别中断类型，返回非0表示处理成功）</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 设备中断处理完成，无需额外操作</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 场景3：未知异常（如页面错误、非法指令）</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 打印错误信息，标记进程为 killed</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若进程被标记为 killed，退出进程</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若为计时器中断（which_dev=2），让出 CPU 调度其他进程</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回到用户态</span></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键逻辑拆解"><a href="#关键逻辑拆解" class="headerlink" title="关键逻辑拆解"></a>关键逻辑拆解</h3><ol>
<li><strong>用户态校验</strong>：<code>SSTATUS_SPP</code> 是 RISC-V <code>sstatus</code> 寄存器的位，0&#x3D;上一级是用户态，1&#x3D;内核态；若内核态调用 <code>usertrap</code> 直接 panic（致命错误）。</li>
<li><strong>stvec 切换</strong>：进入内核后，将陷阱入口改为 <code>kernelvec</code>（内核态陷阱用），避免内核内的陷阱跳回用户态的 <code>uservec</code>。</li>
<li><strong>系统调用处理</strong>：<ul>
<li><code>r_scause() == 8</code>：RISC-V 定义 <code>scause=8</code> 为「用户态触发 ecall」；</li>
<li><code>epc +=4</code>：ecall 指令占 4 字节，返回用户态时需从下一条指令执行；</li>
<li><code>syscall()</code>：分发系统调用（如 exec&#x2F;read&#x2F;write），读取 <code>trapframe-&gt;a7</code> 的调用号，执行对应内核函数。</li>
</ul>
</li>
<li><strong>设备中断处理</strong>：<code>devintr()</code> 识别中断类型（计时器、UART、磁盘），返回值：<ul>
<li>2：计时器中断；</li>
<li>1：其他外设中断（UART&#x2F;磁盘）；</li>
<li>0：未识别的中断&#x2F;异常。</li>
</ul>
</li>
<li><strong>异常处理</strong>：未知异常直接标记进程为 killed，后续 <code>exit(-1)</code> 终止进程（xv6 对用户态异常的极简处理）。</li>
<li><strong>计时器中断调度</strong>：<code>yield()</code> 触发进程调度，让其他进程有机会运行。</li>
</ol>
<h2 id="五、用户态陷阱返回：usertrapret（核心）"><a href="#五、用户态陷阱返回：usertrapret（核心）" class="headerlink" title="五、用户态陷阱返回：usertrapret（核心）"></a>五、用户态陷阱返回：usertrapret（核心）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关中断：切换 stvec 前避免触发新陷阱（防止入口错误）</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换陷阱入口：用户态的陷阱跳转到蹦床页的 uservec</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充 trapframe：uservec 后续需要这些信息来恢复内核态上下文</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// 内核页表（satp 寄存器值）</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// 进程的内核栈顶</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap; <span class="comment">// 下次用户态陷阱的入口</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// 核心 ID（cpuid() 用）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置 sstatus 寄存器：准备返回用户态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// 清除 SPP 位（标记下一级为用户态）</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// 开启 SPIE 位（用户态允许中断）</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 恢复用户态的程序计数器（sepc = 保存的 epc）</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造用户页表的 satp 值（MAKE_SATP 宏：页表基址 + ASID）</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳转到蹦床页的 userret 汇编函数：</span></span><br><span class="line">  <span class="comment">// 1. 切换到用户页表；2. 恢复用户寄存器；3. sret 返回用户态</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键逻辑拆解-1"><a href="#关键逻辑拆解-1" class="headerlink" title="关键逻辑拆解"></a>关键逻辑拆解</h3><ol>
<li><strong>stvec 切换</strong>：<code>TRAMPOLINE</code> 是蹦床页的固定地址（所有进程共享），<code>uservec - trampoline</code> 是 <code>uservec</code> 在蹦床页内的偏移；设置后，用户态触发的陷阱会跳转到蹦床页的 <code>uservec</code>。</li>
<li><strong>trapframe 填充</strong>：<code>trapframe</code> 是进程私有、映射在用户页表中的内存，<code>uservec</code> 后续需要这些字段来：<ul>
<li><code>kernel_satp</code>：切换回内核页表；</li>
<li><code>kernel_sp</code>：切换到进程的内核栈；</li>
<li><code>kernel_trap</code>：跳转到 <code>usertrap</code> 处理陷阱。</li>
</ul>
</li>
<li><strong>sstatus 配置</strong>：<ul>
<li><code>~SSTATUS_SPP</code>：清除「上一级特权级」为用户态；</li>
<li><code>SSTATUS_SPIE</code>：开启用户态中断（用户程序可响应外设&#x2F;计时器中断）。</li>
</ul>
</li>
<li><strong>跳转到 userret</strong>：<ul>
<li><code>TRAPFRAME</code> 是 <code>trapframe</code> 的用户虚拟地址；</li>
<li><code>satp</code> 是用户页表的地址；</li>
<li><code>userret</code> 汇编函数会：切换到用户页表 → 恢复用户寄存器 → 执行 <code>sret</code>（将 <code>sepc</code> 写入 PC，回到用户态）。</li>
</ul>
</li>
</ol>
<h2 id="六、内核态陷阱处理：kerneltrap"><a href="#六、内核态陷阱处理：kerneltrap" class="headerlink" title="六、内核态陷阱处理：kerneltrap"></a>六、内核态陷阱处理：kerneltrap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();    <span class="comment">// 触发陷阱的内核指令地址</span></span><br><span class="line">  uint64 sstatus = r_sstatus(); <span class="comment">// 陷阱触发时的 sstatus</span></span><br><span class="line">  uint64 scause = r_scause();   <span class="comment">// 陷阱原因</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 校验：必须来自内核态（SSTATUS_SPP=1）</span></span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="comment">// 校验：中断必须关闭（内核陷阱不支持嵌套）</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理设备中断</span></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 未识别的陷阱（内核态异常，如页面错误、非法指令）→ panic</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若为计时器中断，且当前进程正在运行 → 让出 CPU</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 恢复 sepc 和 sstatus（yield 可能修改这些寄存器）</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键逻辑拆解-2"><a href="#关键逻辑拆解-2" class="headerlink" title="关键逻辑拆解"></a>关键逻辑拆解</h3><ol>
<li><strong>内核态校验</strong>：内核态陷阱必须满足 <code>SSTATUS_SPP=1</code>，且中断关闭（<code>intr_get()=0</code>），否则 panic（内核代码不应出现这种错误）。</li>
<li><strong>异常处理</strong>：内核态的非设备中断（如页面错误、非法指令）是致命错误，直接 panic（xv6 不处理内核态异常）。</li>
<li><strong>计时器中断调度</strong>：和 <code>usertrap</code> 逻辑一致，触发 <code>yield()</code> 调度进程。</li>
<li><strong>寄存器恢复</strong>：<code>yield()</code> 可能切换线程，修改 <code>sepc</code>&#x2F;<code>sstatus</code>，需恢复到陷阱触发时的状态，确保返回后继续执行被中断的内核代码。</li>
</ol>
<h2 id="七、时钟中断处理：clockintr"><a href="#七、时钟中断处理：clockintr" class="headerlink" title="七、时钟中断处理：clockintr"></a>七、时钟中断处理：clockintr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock); <span class="comment">// 加锁：多核心安全</span></span><br><span class="line">  ticks++;             <span class="comment">// 时钟滴答数+1</span></span><br><span class="line">  wakeup(&amp;ticks);      <span class="comment">// 唤醒所有等待 ticks 的进程（如 sleep 系统调用）</span></span><br><span class="line">  release(&amp;tickslock); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ticks</code> 是全局计时基准，<code>sleep</code>&#x2F;<code>wait</code> 等系统调用会等待 <code>ticks</code> 增加；</li>
<li>自旋锁 <code>tickslock</code> 确保多核心同时触发计时器中断时，<code>ticks</code> 不会被并发修改。</li>
</ul>
<h2 id="八、设备中断识别：devintr"><a href="#八、设备中断识别：devintr" class="headerlink" title="八、设备中断识别：devintr"></a>八、设备中断识别：devintr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 场景1：PLIC 外部中断（scause 最高位=1 表示中断，低8位=9 表示 supervisor 外部中断）</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000L</span>) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// 向 PLIC（平台级中断控制器）申请中断号（识别哪个设备触发）</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 UART 中断（串口输入）</span></span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 处理 virtio 磁盘中断</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 未知外设中断</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 PLIC：该设备中断已处理，可再次触发</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 标记为“外设中断”</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 场景2：软件中断（计时器中断，scause=0x8000000000000001）</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001L</span>)&#123;</span><br><span class="line">    <span class="comment">// 仅核心0处理全局时钟（避免多核心重复累加 ticks）</span></span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除软件中断标记（SSIP 位），允许下次计时器中断</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 标记为“计时器中断”</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 场景3：未识别的陷阱（异常）</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键逻辑拆解-3"><a href="#关键逻辑拆解-3" class="headerlink" title="关键逻辑拆解"></a>关键逻辑拆解</h3><ol>
<li><strong>RISC-V 中断编码</strong>：<code>scause</code> 最高位为 1 表示「中断」（可恢复），为 0 表示「异常」（不可恢复）；</li>
<li><strong>PLIC 控制器</strong>：RISC-V 处理外设中断的核心组件，<code>plic_claim()</code> 获取中断源，<code>plic_complete()</code> 确认处理完成；</li>
<li><strong>计时器中断</strong>：属于「软件中断」（由机器模式的时钟触发，转发到监督模式），仅核心0处理全局 <code>ticks</code>；</li>
<li>返回值约定：<ul>
<li>2：计时器中断（触发调度）；</li>
<li>1：其他外设中断（UART&#x2F;磁盘）；</li>
<li>0：未识别（异常）。</li>
</ul>
</li>
</ol>
<h2 id="九、核心设计思路总结"><a href="#九、核心设计思路总结" class="headerlink" title="九、核心设计思路总结"></a>九、核心设计思路总结</h2><table>
<thead>
<tr>
<th>模块</th>
<th>核心设计目标</th>
<th>关键技巧</th>
</tr>
</thead>
<tbody><tr>
<td>usertrap&#x2F;usertrapret</td>
<td>安全切换用户&#x2F;内核态，处理系统调用&#x2F;中断</td>
<td>蹦床页+页表切换、trapframe 保存上下文</td>
</tr>
<tr>
<td>kerneltrap</td>
<td>处理内核态中断，异常直接 panic</td>
<td>寄存器恢复、禁止中断嵌套</td>
</tr>
<tr>
<td>devintr</td>
<td>识别中断源，解耦外设中断处理</td>
<td>PLIC 申请&#x2F;确认、中断类型分类</td>
</tr>
<tr>
<td>自旋锁（tickslock）</td>
<td>多核心下的全局变量安全</td>
<td>加锁&#x2F;解锁保护 ticks 累加</td>
</tr>
</tbody></table>
<h3 id="与真实OS的差异（回顾之前知识点）"><a href="#与真实OS的差异（回顾之前知识点）" class="headerlink" title="与真实OS的差异（回顾之前知识点）"></a>与真实OS的差异（回顾之前知识点）</h3><ol>
<li>xv6 对用户态异常直接终止进程，真实OS会处理页面错误（COW&#x2F;惰性分配）；</li>
<li>xv6 内核态异常直接 panic，真实OS会尝试恢复（如换入磁盘页）；</li>
<li>xv6 依赖蹦床页切换页表，真实OS将内核映射到用户页表，避免页表切换开销。</li>
</ol>
<p>该文件是 xv6 特权级管理的“心脏”，所有用户态到内核态的交互（系统调用、中断）都通过这里完成，其极简的设计（牺牲效率换简洁）也正是教学OS的核心特点。</p>
<hr>
<h1 id="xv6-trampoline-S-源码全解析：用户-内核态切换的汇编桥梁"><a href="#xv6-trampoline-S-源码全解析：用户-内核态切换的汇编桥梁" class="headerlink" title="xv6 trampoline.S 源码全解析：用户&#x2F;内核态切换的汇编桥梁"></a>xv6 trampoline.S 源码全解析：用户&#x2F;内核态切换的汇编桥梁</h1><p><code>trampoline.S</code> 是 xv6 实现「用户态↔内核态」切换的核心汇编代码，映射在所有进程的用户页表和内核页表的<strong>同一虚拟地址（TRAMPOLINE）</strong>，解决了「页表切换时代码连续性」的关键问题。文件核心包含 <code>uservec</code>（用户态陷阱入口）和 <code>userret</code>（内核态返回用户态）两个函数，以下逐行拆解逻辑、寄存器操作和设计原理。</p>
<h2 id="一、核心背景：蹦床页（Trampoline）的意义"><a href="#一、核心背景：蹦床页（Trampoline）的意义" class="headerlink" title="一、核心背景：蹦床页（Trampoline）的意义"></a>一、核心背景：蹦床页（Trampoline）的意义</h2><ol>
<li><strong>地址一致性</strong>：TRAMPOLINE 是固定虚拟地址（如 <code>0xFFFF000000000000</code>），同时映射到「用户页表」和「内核页表」，且权限为「S模式可执行」，因此切换页表后代码仍能继续执行；</li>
<li><strong>无数据依赖</strong>：蹦床页仅包含汇编代码，不访问任何进程私有数据，仅依赖 <code>trapframe</code>（进程私有、映射在用户页表的 TRAPFRAME 地址）；</li>
<li><strong>核心作用</strong>：<ul>
<li><code>uservec</code>：用户态触发陷阱（ecall&#x2F;中断&#x2F;异常）后，完成「用户寄存器保存→切换到内核页表→跳转到 usertrap()」；</li>
<li><code>userret</code>：内核态返回用户态时，完成「切换到用户页表→恢复用户寄存器→sret 返回用户态」。</li>
</ul>
</li>
</ol>
<h2 id="二、代码结构与前置约定"><a href="#二、代码结构与前置约定" class="headerlink" title="二、代码结构与前置约定"></a>二、代码结构与前置约定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 标记段为 trampsec（链接脚本 kernel.ld 会将其对齐到页边界）</span><br><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4  # 4字节对齐（RISC-V 指令长度）</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.section trampsec</code>：自定义段，确保蹦床页代码被链接到独立的页；</li>
<li><code>.globl</code>：导出符号，让内核 C 代码（如 trap.c）能引用 <code>trampoline/uservec/userret</code>；</li>
<li><code>.align 4</code>：RISC-V 指令是 4 字节，对齐后保证指令正确执行。</li>
</ul>
<h2 id="三、核心1：uservec（用户态→内核态的陷阱入口）"><a href="#三、核心1：uservec（用户态→内核态的陷阱入口）" class="headerlink" title="三、核心1：uservec（用户态→内核态的陷阱入口）"></a>三、核心1：uservec（用户态→内核态的陷阱入口）</h2><p><code>uservec</code> 是用户态陷阱的第一个入口（stvec 指向此处），执行时 CPU 处于「S模式、用户页表」，最终切换到内核页表并跳转到 <code>usertrap()</code>。</p>
<h3 id="逐行拆解-逻辑注释"><a href="#逐行拆解-逻辑注释" class="headerlink" title="逐行拆解 &amp; 逻辑注释"></a>逐行拆解 &amp; 逻辑注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">        # 背景：</span><br><span class="line">        # 1. 触发陷阱后，CPU 进入 S 模式，sepc 保存用户态陷阱指令地址；</span><br><span class="line">        # 2. sscratch 预先设置为 TRAPFRAME（进程 trapframe 的用户虚拟地址）；</span><br><span class="line">        # 3. 此时仍使用用户页表，仅能访问用户空间 + TRAMPOLINE + TRAPFRAME。</span><br><span class="line"></span><br><span class="line">        # 步骤1：交换 a0 和 sscratch，让 a0 = TRAPFRAME（trapframe 地址）</span><br><span class="line">        # csrrw：原子读+写 sscratch，将 sscratch 原值写入 a0，a0 原值写入 sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 步骤2：保存所有用户态通用寄存器到 trapframe（TRAPFRAME 偏移对应字段）</span><br><span class="line">        # 注：trapframe 是进程私有结构，映射在用户页表的 TRAPFRAME 地址</span><br><span class="line">        sd ra, 40(a0)   # 保存返回地址 ra 到 trapframe+40</span><br><span class="line">        sd sp, 48(a0)   # 保存用户栈指针 sp 到 trapframe+48</span><br><span class="line">        sd gp, 56(a0)   # 保存全局指针 gp 到 trapframe+56</span><br><span class="line">        sd tp, 64(a0)   # 保存线程指针 tp 到 trapframe+64</span><br><span class="line">        sd t0, 72(a0)   # 临时寄存器 t0-t6 依次保存</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)   # 保存寄存器 s0-s11（保存寄存器）</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)  # 保存 a1-a7（系统调用参数寄存器）</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">        # 步骤3：保存用户态 a0 到 trapframe+112</span><br><span class="line">        # 此前 csrrw 交换了 a0 和 sscratch，sscratch 中是原用户态 a0（系统调用参数）</span><br><span class="line">        csrr t0, sscratch  # 读取 sscratch（原用户 a0）到 t0</span><br><span class="line">        sd t0, 112(a0)     # 写入 trapframe+112（a0 字段）</span><br><span class="line"></span><br><span class="line">        # 步骤4：切换到进程的内核栈（从 trapframe 读取 kernel_sp）</span><br><span class="line">        # trapframe+8 存储的是进程内核栈顶地址（kernel_sp）</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # 步骤5：设置 tp 寄存器为当前核心 ID（hartid）</span><br><span class="line">        # trapframe+32 存储 kernel_hartid（核心 ID），tp 用于 cpuid()</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # 步骤6：加载 usertrap() 的地址（trapframe+16 存储 kernel_trap）</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # 步骤7：切换到内核页表（关键！）</span><br><span class="line">        # 1. 从 trapframe+0 读取 kernel_satp（内核页表的 satp 值）</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 2. 写入 satp 寄存器，切换到内核页表</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        # 3. 刷新 TLB，确保页表切换生效（zero 表示刷新所有地址）</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # 注意：切换内核页表后，TRAPFRAME（用户虚拟地址）不再有效，a0 失效</span><br><span class="line">        # 内核页表不映射用户态的 trapframe，因此后续不能访问 a0 指向的地址</span><br><span class="line"></span><br><span class="line">        # 步骤8：跳转到 usertrap()（C 函数），不再返回</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<h3 id="uservec-核心目标总结"><a href="#uservec-核心目标总结" class="headerlink" title="uservec 核心目标总结"></a>uservec 核心目标总结</h3><table>
<thead>
<tr>
<th>操作阶段</th>
<th>核心成果</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器保存</td>
<td>所有用户态寄存器存入 trapframe，不丢失上下文</td>
</tr>
<tr>
<td>栈切换</td>
<td>sp 从用户栈切换到进程私有内核栈</td>
</tr>
<tr>
<td>页表切换</td>
<td>satp 从用户页表切换到内核页表</td>
</tr>
<tr>
<td>入口跳转</td>
<td>从汇编跳转到 C 层的 usertrap() 处理陷阱</td>
</tr>
</tbody></table>
<h2 id="四、核心2：userret（内核态→用户态的返回入口）"><a href="#四、核心2：userret（内核态→用户态的返回入口）" class="headerlink" title="四、核心2：userret（内核态→用户态的返回入口）"></a>四、核心2：userret（内核态→用户态的返回入口）</h2><p><code>userret</code> 由 <code>usertrapret()</code> 调用，执行时 CPU 处于「S模式、内核页表」，最终切换到用户页表并通过 <code>sret</code> 返回用户态。</p>
<h3 id="逐行拆解-逻辑注释-1"><a href="#逐行拆解-逻辑注释-1" class="headerlink" title="逐行拆解 &amp; 逻辑注释"></a>逐行拆解 &amp; 逻辑注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # 背景：</span><br><span class="line">        # 1. usertrapret() 调用 userret，传入两个参数：</span><br><span class="line">        #    a0 = TRAPFRAME（trapframe 的用户虚拟地址）</span><br><span class="line">        #    a1 = 用户页表的 satp 值（MAKE_SATP(p-&gt;pagetable)）</span><br><span class="line">        # 2. 此时仍使用内核页表，需先切换到用户页表才能访问 TRAPFRAME。</span><br><span class="line"></span><br><span class="line">        # 步骤1：切换到用户页表（关键！）</span><br><span class="line">        # 1. 写入 satp 寄存器，切换到用户页表</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        # 2. 刷新 TLB，确保页表切换生效</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # 步骤2：恢复用户态 a0 到 sscratch（为最后一步交换做准备）</span><br><span class="line">        # 从 trapframe+112 读取保存的用户 a0，写入 sscratch</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # 步骤3：从 trapframe 恢复所有用户态寄存器（除 a0）</span><br><span class="line">        ld ra, 40(a0)   # 恢复返回地址 ra</span><br><span class="line">        ld sp, 48(a0)   # 恢复用户栈指针 sp（关键！回到用户栈）</span><br><span class="line">        ld gp, 56(a0)   # 恢复全局指针 gp</span><br><span class="line">        ld tp, 64(a0)   # 恢复线程指针 tp</span><br><span class="line">        ld t0, 72(a0)   # 恢复临时寄存器 t0-t6</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)   # 恢复保存寄存器 s0-s11</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)  # 恢复参数寄存器 a1-a7</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">        # 步骤4：恢复用户态 a0，同时将 TRAPFRAME 写回 sscratch</span><br><span class="line">        # csrrw：交换 a0 和 sscratch，a0 恢复为用户态原值，sscratch 保存 TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # 步骤5：返回用户态（关键！）</span><br><span class="line">        # sret 指令：</span><br><span class="line">        # 1. 将 sepc 写入 PC，跳转到用户态陷阱指令的下一条；</span><br><span class="line">        # 2. 将 sstatus.SPP 置为 0（用户态），恢复中断使能；</span><br><span class="line">        # 3. 特权级从 S 模式切回 U 模式。</span><br><span class="line">        # 注：sstatus 和 sepc 已由 usertrapret() 提前设置好。</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<h3 id="userret-核心目标总结"><a href="#userret-核心目标总结" class="headerlink" title="userret 核心目标总结"></a>userret 核心目标总结</h3><table>
<thead>
<tr>
<th>操作阶段</th>
<th>核心成果</th>
</tr>
</thead>
<tbody><tr>
<td>页表切换</td>
<td>satp 从内核页表切换到用户页表</td>
</tr>
<tr>
<td>寄存器恢复</td>
<td>所有用户态寄存器从 trapframe 恢复</td>
</tr>
<tr>
<td>特权级切换</td>
<td>sret 切回 U 模式，从 sepc 继续执行用户代码</td>
</tr>
</tbody></table>
<h2 id="五、关键设计细节与答疑"><a href="#五、关键设计细节与答疑" class="headerlink" title="五、关键设计细节与答疑"></a>五、关键设计细节与答疑</h2><h3 id="1-为什么需要-csrrw-交换-a0-和-sscratch？"><a href="#1-为什么需要-csrrw-交换-a0-和-sscratch？" class="headerlink" title="1. 为什么需要 csrrw 交换 a0 和 sscratch？"></a>1. 为什么需要 csrrw 交换 a0 和 sscratch？</h3><ul>
<li><code>sscratch</code> 是 RISC-V 为陷阱处理设计的「临时寄存器」，专门用于存储 trapframe 地址；</li>
<li>用户态执行时，<code>a0</code> 可能存储系统调用参数（如 exec 的 path），直接覆盖会丢失数据；</li>
<li><code>csrrw</code> 是原子操作，确保「trapframe 地址获取」和「用户 a0 保存」一步完成，无数据丢失。</li>
</ul>
<h3 id="2-为什么切换页表后不能访问-a0（TRAPFRAME）？"><a href="#2-为什么切换页表后不能访问-a0（TRAPFRAME）？" class="headerlink" title="2. 为什么切换页表后不能访问 a0（TRAPFRAME）？"></a>2. 为什么切换页表后不能访问 a0（TRAPFRAME）？</h3><ul>
<li>TRAPFRAME 是「用户虚拟地址」，仅在用户页表中有效；</li>
<li>内核页表仅映射「内核空间 + TRAMPOLINE」，不映射用户态的 trapframe，因此切换后 a0 指向的地址无效。</li>
</ul>
<h3 id="3-sfence-vma-的作用是什么？"><a href="#3-sfence-vma-的作用是什么？" class="headerlink" title="3. sfence.vma 的作用是什么？"></a>3. sfence.vma 的作用是什么？</h3><ul>
<li>RISC-V 的 TLB 会缓存「虚拟地址→物理地址」映射，页表切换后 TLB 缓存失效；</li>
<li><code>sfence.vma zero, zero</code> 表示「刷新所有核心、所有地址的 TLB」，确保后续内存访问使用新页表。</li>
</ul>
<h3 id="4-为什么-trampoline-要映射到同一虚拟地址？"><a href="#4-为什么-trampoline-要映射到同一虚拟地址？" class="headerlink" title="4. 为什么 trampoline 要映射到同一虚拟地址？"></a>4. 为什么 trampoline 要映射到同一虚拟地址？</h3><ul>
<li>切换页表的过程中，CPU 仍在执行 trampoline 的代码；</li>
<li>若 trampoline 在用户&#x2F;内核页表的虚拟地址不同，切换页表后 PC 会指向无效地址，导致崩溃；</li>
<li>同一地址映射保证了「页表切换时代码执行的连续性」。</li>
</ul>
<h2 id="六、核心设计思路总结"><a href="#六、核心设计思路总结" class="headerlink" title="六、核心设计思路总结"></a>六、核心设计思路总结</h2><table>
<thead>
<tr>
<th>模块</th>
<th>核心挑战</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>uservec</td>
<td>用户页表→内核页表切换，寄存器保存</td>
<td>先保存寄存器到 trapframe，再切换页表&#x2F;栈</td>
</tr>
<tr>
<td>userret</td>
<td>内核页表→用户页表切换，上下文恢复</td>
<td>先切换页表，再恢复寄存器，sret 切回用户态</td>
</tr>
<tr>
<td>整体</td>
<td>页表切换时代码不中断</td>
<td>蹦床页映射到统一地址，仅用汇编执行切换</td>
</tr>
</tbody></table>
<h3 id="与真实OS的差异"><a href="#与真实OS的差异" class="headerlink" title="与真实OS的差异"></a>与真实OS的差异</h3><ol>
<li>xv6 用蹦床页+显式页表切换，真实OS（如Linux）将内核映射到用户页表，无需切换页表；</li>
<li>xv6 保存所有寄存器，真实OS仅保存「调用约定中需要保留的寄存器」，减少开销；</li>
<li>xv6 陷阱处理路径极简，真实OS会处理页面错误、COW等复杂场景。</li>
</ol>
<h2 id="七、关键关联（与-trap-c-的协作）"><a href="#七、关键关联（与-trap-c-的协作）" class="headerlink" title="七、关键关联（与 trap.c 的协作）"></a>七、关键关联（与 trap.c 的协作）</h2><table>
<thead>
<tr>
<th>trampoline.S 操作</th>
<th>trap.c 对应操作</th>
</tr>
</thead>
<tbody><tr>
<td>uservec 跳转到 usertrap()</td>
<td>usertrap() 处理系统调用&#x2F;中断&#x2F;异常</td>
</tr>
<tr>
<td>userret 被 usertrapret() 调用</td>
<td>usertrapret() 配置 sstatus&#x2F;sepc 等寄存器</td>
</tr>
<tr>
<td>trapframe 字段读写</td>
<td>usertrap()&#x2F;usertrapret() 填充 trapframe</td>
</tr>
</tbody></table>
<p><code>trampoline.S</code> 是「纯汇编的硬件层切换」，<code>trap.c</code> 是「C 层的逻辑处理」，两者协作完成了 xv6 最核心的特权级切换流程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E9%A1%B5%E9%9D%A2%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%EF%BC%9Axv6-%E6%9E%81%E7%AE%80%E5%A4%84%E7%90%86-vs-%E7%9C%9F%E5%AE%9E-OS-%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E9%A1%B5%E9%9D%A2%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%EF%BC%9Axv6-%E6%9E%81%E7%AE%80%E5%A4%84%E7%90%86-vs-%E7%9C%9F%E5%AE%9E-OS-%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">页面错误异常：xv6 极简处理 vs 真实 OS 的高级应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-29 20:25:52 / 修改时间：20:26:08" itemprop="dateCreated datePublished" datetime="2025-12-29T20:25:52+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="页面错误异常：xv6-极简处理-vs-真实OS的高级应用"><a href="#页面错误异常：xv6-极简处理-vs-真实OS的高级应用" class="headerlink" title="页面错误异常：xv6 极简处理 vs 真实OS的高级应用"></a>页面错误异常：xv6 极简处理 vs 真实OS的高级应用</h1><p>页面错误（Page Fault）是CPU在尝试访问虚拟地址时，因「地址无效、权限不足、无物理映射」等原因触发的异常。xv6对页面错误的处理极其简单（用户态终止进程、内核态panic），但真实操作系统基于页面错误实现了<strong>写时拷贝Fork、惰性分配、磁盘分页</strong>等核心优化，这些机制的核心价值是「透明性（无需修改应用）+ 高效性（按需分配&#x2F;共享资源）」。以下从架构基础到具体特性详细解析：</p>
<h2 id="一、页面错误异常的基础（RISC-V架构层面）"><a href="#一、页面错误异常的基础（RISC-V架构层面）" class="headerlink" title="一、页面错误异常的基础（RISC-V架构层面）"></a>一、页面错误异常的基础（RISC-V架构层面）</h2><h3 id="1-触发条件"><a href="#1-触发条件" class="headerlink" title="1. 触发条件"></a>1. 触发条件</h3><p>CPU执行内存访问指令（加载&#x2F;存储&#x2F;取指）时，若虚拟地址（VA）无法完成「虚拟→物理」转换，触发页面错误异常，常见原因：</p>
<ul>
<li>PTE（页表项）无效（PTE_V位为0）；</li>
<li>访问权限不匹配（如写只读页面、用户态访问内核页）；</li>
<li>虚拟地址超出进程地址空间上限（如用户态访问≥MAXVA的地址）；</li>
<li>物理页被换出到磁盘（无物理映射）。</li>
</ul>
<h3 id="2-RISC-V的页面错误类型"><a href="#2-RISC-V的页面错误类型" class="headerlink" title="2. RISC-V的页面错误类型"></a>2. RISC-V的页面错误类型</h3><p>RISC-V通过<code>scause</code>寄存器标记页面错误的具体类型（最高位为0表示异常，低位数表示具体类型）：</p>
<table>
<thead>
<tr>
<th>错误类型</th>
<th>scause值</th>
<th>触发场景</th>
</tr>
</thead>
<tbody><tr>
<td>加载页面错误（Load PF）</td>
<td>13</td>
<td>lw&#x2F;ld等加载指令访问无效地址</td>
</tr>
<tr>
<td>存储页面错误（Store PF）</td>
<td>15</td>
<td>sw&#x2F;sd等存储指令访问无效地址</td>
</tr>
<tr>
<td>指令页面错误（Instruction PF）</td>
<td>12</td>
<td>取指时地址无效（如执行不存在的代码页）</td>
</tr>
</tbody></table>
<h3 id="3-关键寄存器"><a href="#3-关键寄存器" class="headerlink" title="3. 关键寄存器"></a>3. 关键寄存器</h3><ul>
<li><code>stval</code>：存储<strong>触发错误的虚拟地址</strong>（内核可通过该值定位故障地址）；</li>
<li><code>sepc</code>：存储触发错误的指令地址（异常处理完成后，内核需恢复该地址继续执行）。</li>
</ul>
<h3 id="4-xv6-vs-真实OS的处理差异"><a href="#4-xv6-vs-真实OS的处理差异" class="headerlink" title="4. xv6 vs 真实OS的处理差异"></a>4. xv6 vs 真实OS的处理差异</h3><table>
<thead>
<tr>
<th>场景</th>
<th>xv6 处理方式</th>
<th>真实OS 处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>用户态PF</td>
<td>直接标记进程为killed，终止执行</td>
<td>分析错误原因：<br>- 合法需求（如COW&#x2F;惰性分配）→ 修复页表后恢复执行；<br>- 非法访问（如野指针）→ 终止进程。</td>
</tr>
<tr>
<td>内核态PF</td>
<td>调用panic，系统崩溃</td>
<td>仅致命错误（如内核代码bug）才崩溃；合法场景（如换入页面）→ 修复后恢复。</td>
</tr>
</tbody></table>
<h2 id="二、核心应用1：写时拷贝（COW）Fork"><a href="#二、核心应用1：写时拷贝（COW）Fork" class="headerlink" title="二、核心应用1：写时拷贝（COW）Fork"></a>二、核心应用1：写时拷贝（COW）Fork</h2><p>COW（Copy-on-Write）是对xv6原生fork的核心优化，解决「全量拷贝物理页效率低」的问题。</p>
<h3 id="1-xv6原生fork的痛点"><a href="#1-xv6原生fork的痛点" class="headerlink" title="1. xv6原生fork的痛点"></a>1. xv6原生fork的痛点</h3><p>xv6的<code>fork()</code>通过<code>uvmcopy()</code>函数<strong>全量拷贝父进程的所有物理页</strong>到子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c: uvmcopy 核心逻辑</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">  <span class="comment">// 遍历父进程所有页，为子进程分配新物理页，逐页拷贝数据</span></span><br><span class="line">  <span class="keyword">for</span> (uint64 i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pa = walkaddr(old, i)) == <span class="number">0</span>) panic(<span class="string">&quot;uvmcopy: walkaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE); <span class="comment">// 全量拷贝数据</span></span><br><span class="line">    <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// ... 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>问题1：拷贝耗时，尤其父进程内存大时；</li>
<li>问题2：浪费物理内存（子进程通常fork后立即exec，拷贝的页从未被使用）；</li>
<li>问题3：父子进程无共享，无法利用只读数据的复用性。</li>
</ul>
<h3 id="2-COW-Fork的核心原理"><a href="#2-COW-Fork的核心原理" class="headerlink" title="2. COW Fork的核心原理"></a>2. COW Fork的核心原理</h3><p><strong>核心思路</strong>：父子进程共享物理页，仅将页表项（PTE）标记为「只读」；当任意进程执行写操作时，触发「存储页面错误」，内核为该进程拷贝一份物理页，并重映射为可写。</p>
<h3 id="3-COW-Fork的实现步骤"><a href="#3-COW-Fork的实现步骤" class="headerlink" title="3. COW Fork的实现步骤"></a>3. COW Fork的实现步骤</h3><h4 id="步骤1：fork时的页表初始化（替代uvmcopy）"><a href="#步骤1：fork时的页表初始化（替代uvmcopy）" class="headerlink" title="步骤1：fork时的页表初始化（替代uvmcopy）"></a>步骤1：fork时的页表初始化（替代uvmcopy）</h4><ul>
<li>遍历父进程的所有PTE，为子进程创建相同的PTE；</li>
<li>清除父子进程PTE的<code>PTE_W</code>（可写位），保留<code>PTE_R</code>（只读）、<code>PTE_U</code>（用户可访问）；</li>
<li>为每个共享物理页维护「引用计数」（初始为2，父子各引用一次）；</li>
<li>子进程页表指向父进程的物理页，无需分配新页&#x2F;拷贝数据。</li>
</ul>
<h4 id="步骤2：处理存储页面错误"><a href="#步骤2：处理存储页面错误" class="headerlink" title="步骤2：处理存储页面错误"></a>步骤2：处理存储页面错误</h4><p>当父子进程任一方向共享页写数据时，触发存储页面错误，内核执行：</p>
<ol>
<li>检查<code>stval</code>（故障地址）对应的物理页是否为COW共享页；</li>
<li>若引用计数&gt;1：<ul>
<li>分配新物理页，拷贝原页数据；</li>
<li>将当前进程的PTE映射到新物理页，并恢复<code>PTE_W</code>（可写）；</li>
<li>原物理页的引用计数-1；</li>
</ul>
</li>
<li>若引用计数&#x3D;1（仅当前进程引用）：<ul>
<li>直接恢复该进程PTE的<code>PTE_W</code>（无需拷贝，独占页）；</li>
</ul>
</li>
<li>恢复<code>sepc</code>为触发错误的指令地址，重新执行该指令（此时写操作合法）。</li>
</ol>
<h3 id="4-COW-Fork的优势"><a href="#4-COW-Fork的优势" class="headerlink" title="4. COW Fork的优势"></a>4. COW Fork的优势</h3><ul>
<li><strong>效率提升</strong>：避免无意义的全量拷贝，仅在真正写数据时拷贝；</li>
<li><strong>内存节省</strong>：只读数据（如代码段）可永久共享，无需拷贝；</li>
<li><strong>透明性</strong>：应用无需修改任何代码，感知不到COW的存在；</li>
<li><strong>适配exec场景</strong>：子进程fork后exec，直接丢弃共享页，完全避免拷贝。</li>
</ul>
<h2 id="三、核心应用2：惰性分配（Lazy-Allocation）"><a href="#三、核心应用2：惰性分配（Lazy-Allocation）" class="headerlink" title="三、核心应用2：惰性分配（Lazy Allocation）"></a>三、核心应用2：惰性分配（Lazy Allocation）</h2><p>惰性分配解决「应用申请内存但未必立即使用，提前分配物理页浪费资源」的问题（如应用调用<code>sbrk(100MB)</code>申请大内存，但仅使用前1MB）。</p>
<h3 id="1-原生内存分配的痛点"><a href="#1-原生内存分配的痛点" class="headerlink" title="1. 原生内存分配的痛点"></a>1. 原生内存分配的痛点</h3><p>xv6中<code>sys_sbrk()</code>会立即调用<code>growproc()</code>分配物理页，并映射到用户地址空间：</p>
<ul>
<li>物理内存被提前占用，即使应用未使用；</li>
<li>大内存申请可能因物理页不足失败，即使应用仅需小部分。</li>
</ul>
<h3 id="2-惰性分配的核心原理"><a href="#2-惰性分配的核心原理" class="headerlink" title="2. 惰性分配的核心原理"></a>2. 惰性分配的核心原理</h3><p><strong>核心思路</strong>：应用申请内存时，内核仅「扩展地址空间」（修改进程<code>sz</code>），但不分配物理页、不创建有效PTE；当应用访问新地址触发页面错误时，内核再按需分配物理页并映射。</p>
<h3 id="3-惰性分配的实现步骤"><a href="#3-惰性分配的实现步骤" class="headerlink" title="3. 惰性分配的实现步骤"></a>3. 惰性分配的实现步骤</h3><h4 id="步骤1：处理sys-sbrk（仅扩地址空间）"><a href="#步骤1：处理sys-sbrk（仅扩地址空间）" class="headerlink" title="步骤1：处理sys_sbrk（仅扩地址空间）"></a>步骤1：处理sys_sbrk（仅扩地址空间）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 惰性分配的sys_sbrk简化逻辑</span></span><br><span class="line">uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  argint(<span class="number">0</span>, &amp;n);</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 仅扩展地址空间，不分配物理页、不创建PTE</span></span><br><span class="line">  p-&gt;sz += n;</span><br><span class="line">  <span class="keyword">return</span> oldsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新扩展的地址区间的PTE仍为「无效（PTE_V&#x3D;0）」；</li>
<li>物理页分配被推迟到「首次访问该地址」时。</li>
</ul>
<h4 id="步骤2：处理加载-存储页面错误"><a href="#步骤2：处理加载-存储页面错误" class="headerlink" title="步骤2：处理加载&#x2F;存储页面错误"></a>步骤2：处理加载&#x2F;存储页面错误</h4><p>当应用访问新扩展的地址触发页面错误时，内核执行：</p>
<ol>
<li>检查<code>stval</code>（故障地址）是否在进程合法地址空间（oldsz ≤ stval &lt; p-&gt;sz）；</li>
<li>若合法：<ul>
<li>分配新物理页（<code>kalloc()</code>）；</li>
<li>创建PTE，映射该物理页到故障地址，并设置正确权限（如可写）；</li>
</ul>
</li>
<li>若非法（如野指针）：终止进程；</li>
<li>恢复<code>sepc</code>，重新执行访问指令（此时地址有效）。</li>
</ol>
<h3 id="4-惰性分配的优势"><a href="#4-惰性分配的优势" class="headerlink" title="4. 惰性分配的优势"></a>4. 惰性分配的优势</h3><ul>
<li><strong>按需分配</strong>：仅为应用实际使用的地址分配物理页，节省内存；</li>
<li><strong>降低申请失败概率</strong>：大内存申请仅扩地址空间，无需立即分配物理页；</li>
<li><strong>透明性</strong>：应用无需修改代码，感知不到分配时机的变化。</li>
</ul>
<h2 id="四、核心应用3：磁盘分页（Paging-to-Disk-交换分区）"><a href="#四、核心应用3：磁盘分页（Paging-to-Disk-交换分区）" class="headerlink" title="四、核心应用3：磁盘分页（Paging to Disk&#x2F;交换分区）"></a>四、核心应用3：磁盘分页（Paging to Disk&#x2F;交换分区）</h2><p>磁盘分页（也称“虚拟内存”）解决「物理内存不足，需将暂时不用的页换出到磁盘，腾出空间」的问题，突破物理内存的限制。</p>
<h3 id="1-核心背景"><a href="#1-核心背景" class="headerlink" title="1. 核心背景"></a>1. 核心背景</h3><p>真实OS的物理内存远小于所有进程的内存需求之和，需通过「磁盘」作为补充：</p>
<ul>
<li>交换分区（Swap Partition）：磁盘上预留的连续空间，专门用于存储换出的页；</li>
<li>交换文件（Swap File）：普通文件，功能同交换分区。</li>
</ul>
<h3 id="2-磁盘分页的核心原理"><a href="#2-磁盘分页的核心原理" class="headerlink" title="2. 磁盘分页的核心原理"></a>2. 磁盘分页的核心原理</h3><p><strong>核心思路</strong>：</p>
<ul>
<li>换出（Swap Out）：当物理内存不足时，内核选择「不常用的页」，将其数据写入磁盘，然后置PTE为「无效（PTE_V&#x3D;0）」，释放物理页；</li>
<li>换入（Swap In）：进程访问被换出的页时触发页面错误，内核分配新物理页，将磁盘中的数据读入，更新PTE为有效，恢复执行。</li>
</ul>
<h3 id="3-实现关键步骤"><a href="#3-实现关键步骤" class="headerlink" title="3. 实现关键步骤"></a>3. 实现关键步骤</h3><h4 id="步骤1：页换出（选择-写入磁盘）"><a href="#步骤1：页换出（选择-写入磁盘）" class="headerlink" title="步骤1：页换出（选择+写入磁盘）"></a>步骤1：页换出（选择+写入磁盘）</h4><ol>
<li><strong>页面选择</strong>：内核需通过「页面替换算法」选换出的页（如LRU（最近最少使用）、Clock算法），优先换出不常用、只读的页；</li>
<li><strong>记录映射关系</strong>：维护「虚拟地址→磁盘位置」的映射表（如swap table）；</li>
<li><strong>写入磁盘</strong>：将页数据写入交换分区&#x2F;文件；</li>
<li><strong>置PTE无效</strong>：清除PTE_V位，释放物理页。</li>
</ol>
<h4 id="步骤2：处理页面错误（页换入）"><a href="#步骤2：处理页面错误（页换入）" class="headerlink" title="步骤2：处理页面错误（页换入）"></a>步骤2：处理页面错误（页换入）</h4><p>当进程访问被换出的页触发页面错误时：</p>
<ol>
<li>检查swap table，确认该虚拟地址是否有对应的磁盘数据；</li>
<li>若有：<ul>
<li>分配空闲物理页；</li>
<li>从磁盘读取数据到该物理页；</li>
<li>更新PTE：映射到新物理页，置PTE_V&#x3D;1，恢复权限；</li>
</ul>
</li>
<li>若无（非法地址）：终止进程；</li>
<li>恢复<code>sepc</code>，重新执行访问指令。</li>
</ol>
<h3 id="4-磁盘分页的优势"><a href="#4-磁盘分页的优势" class="headerlink" title="4. 磁盘分页的优势"></a>4. 磁盘分页的优势</h3><ul>
<li><strong>突破物理内存限制</strong>：进程可使用远超物理内存的地址空间；</li>
<li><strong>透明性</strong>：应用无需感知磁盘交互，仅需处理普通内存访问；</li>
<li><strong>资源复用</strong>：物理内存可被多个进程复用，提高整体利用率。</li>
</ul>
<h2 id="五、其他基于页面错误的经典特性"><a href="#五、其他基于页面错误的经典特性" class="headerlink" title="五、其他基于页面错误的经典特性"></a>五、其他基于页面错误的经典特性</h2><h3 id="1-自动扩展栈空间"><a href="#1-自动扩展栈空间" class="headerlink" title="1. 自动扩展栈空间"></a>1. 自动扩展栈空间</h3><p>xv6的栈大小是固定的（1页），而真实OS支持栈「自动扩展」：</p>
<ul>
<li>内核为栈设置「保护页」（PTE无效），位于栈顶下方；</li>
<li>应用栈溢出访问保护页时，触发页面错误；</li>
<li>内核分配新物理页，扩展栈空间，更新页表；</li>
<li>透明适配应用的栈增长需求，无需应用显式申请。</li>
</ul>
<h3 id="2-内存映射文件（mmap）"><a href="#2-内存映射文件（mmap）" class="headerlink" title="2. 内存映射文件（mmap）"></a>2. 内存映射文件（mmap）</h3><p><code>mmap</code>将磁盘文件直接映射到进程虚拟地址空间，替代<code>read/write</code>系统调用：</p>
<ul>
<li>映射时：内核仅创建PTE（标记为无效），不读取文件数据到内存；</li>
<li>首次访问映射地址：触发页面错误，内核从文件读取对应数据到物理页，更新PTE；</li>
<li>写操作：<ul>
<li>私有映射（MAP_PRIVATE）：COW机制，修改触发拷贝，不写回文件；</li>
<li>共享映射（MAP_SHARED）：修改触发页面错误，内核将数据写回文件；</li>
</ul>
</li>
<li>优势：减少数据拷贝（内核→用户），提高文件访问效率。</li>
</ul>
<h2 id="六、核心总结：页面错误的价值"><a href="#六、核心总结：页面错误的价值" class="headerlink" title="六、核心总结：页面错误的价值"></a>六、核心总结：页面错误的价值</h2><p>页面错误看似是「异常」，但真实OS将其转化为「资源调度的契机」，核心价值体现在：</p>
<ol>
<li><strong>透明性</strong>：所有优化（COW、惰性分配、分页）对应用完全透明，无需修改一行代码；</li>
<li><strong>高效性</strong>：按需分配&#x2F;共享资源，避免无意义的拷贝、分配，最大化物理内存利用率；</li>
<li><strong>灵活性</strong>：基于页面错误可扩展出栈自动扩展、mmap等丰富功能，适配复杂应用场景。</li>
</ol>
<p>xv6选择极简的页面错误处理，是为了教学简化；而真实操作系统的复杂度，很大程度上源于对页面错误的精细化处理——这也是“虚拟内存”成为现代OS核心的关键原因。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%BB%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E9%99%B7%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%BB%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E9%99%B7%E5%85%A5/" class="post-title-link" itemprop="url">从内核空间陷入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-29 20:21:33 / 修改时间：20:21:44" itemprop="dateCreated datePublished" datetime="2025-12-29T20:21:33+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="xv6-内核空间陷阱（Kernel-Trap）完整解析"><a href="#xv6-内核空间陷阱（Kernel-Trap）完整解析" class="headerlink" title="xv6 内核空间陷阱（Kernel Trap）完整解析"></a>xv6 内核空间陷阱（Kernel Trap）完整解析</h1><p>内核空间陷阱是 xv6 处理「内核态中断&#x2F;异常」的核心流程，与用户态陷阱的核心差异是：<strong>内核已处于 S 模式，无需切换页表&#x2F;栈，直接复用内核页表和当前线程的内核栈</strong>。以下从「核心差异、前置配置、陷阱触发全流程、关键特殊场景、安全保障」五个维度拆解内核陷阱的完整逻辑。</p>
<h2 id="一、内核态-vs-用户态陷阱：核心差异"><a href="#一、内核态-vs-用户态陷阱：核心差异" class="headerlink" title="一、内核态 vs 用户态陷阱：核心差异"></a>一、内核态 vs 用户态陷阱：核心差异</h2><p>理解内核陷阱的前提是明确其与用户态陷阱的本质区别，这决定了整个处理流程的简化性和安全性：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>用户态陷阱</th>
<th>内核态陷阱</th>
</tr>
</thead>
<tbody><tr>
<td>特权级</td>
<td>U 模式 → S 模式</td>
<td>已在 S 模式（无特权级切换）</td>
</tr>
<tr>
<td>页表（satp）</td>
<td>用户页表（需切换到内核页表）</td>
<td>已为内核页表（无需切换）</td>
</tr>
<tr>
<td>栈指针（sp）</td>
<td>非法&#x2F;用户栈（需切换到内核栈）</td>
<td>有效内核栈（当前线程私有，直接复用）</td>
</tr>
<tr>
<td>寄存器保存位置</td>
<td>进程私有 trapframe（用户页表需映射）</td>
<td>当前内核栈（线程私有，天然隔离）</td>
</tr>
<tr>
<td>异常处理结果</td>
<td>可返回用户态&#x2F;终止进程</td>
<td>异常即致命错误（panic 终止系统）</td>
</tr>
<tr>
<td>stvec 目标</td>
<td>uservec（蹦床页）</td>
<td>kernelvec（内核代码段）</td>
</tr>
</tbody></table>
<h2 id="二、前置配置：stvec-寄存器的动态切换"><a href="#二、前置配置：stvec-寄存器的动态切换" class="headerlink" title="二、前置配置：stvec 寄存器的动态切换"></a>二、前置配置：stvec 寄存器的动态切换</h2><p>xv6 会根据 CPU 执行的「用户态&#x2F;内核态」动态配置 <code>stvec</code>（陷阱向量基址寄存器），确保不同特权级的陷阱跳转到正确入口：</p>
<ol>
<li><strong>用户态运行时</strong>：<code>stvec</code> 指向 <code>uservec</code>（蹦床页），处理用户态触发的陷阱；</li>
<li><strong>进入内核后</strong>：xv6 立即将 <code>stvec</code> 改为指向 <code>kernelvec</code>（内核代码段，<code>kernel/kernelvec.S:10</code>），例如：<ul>
<li><code>usertrap()</code>（处理用户态陷阱的核心函数）中会执行 <code>w_stvec((uint64)kernelvec)</code>；</li>
<li>内核启动&#x2F;线程切换后，也会确保 <code>stvec</code> 指向 <code>kernelvec</code>；</li>
</ul>
</li>
<li><strong>返回用户态前</strong>：<code>usertrapret()</code> 会将 <code>stvec</code> 切回 <code>uservec</code>，为下一次用户态陷阱做准备。</li>
</ol>
<p>核心目的：<strong>内核态陷阱必须跳转到 <code>kernelvec</code>（适配内核栈&#x2F;页表），而非 <code>uservec</code>（依赖用户页表，内核态访问会出错）</strong>。</p>
<h2 id="三、内核陷阱完整处理流程"><a href="#三、内核陷阱完整处理流程" class="headerlink" title="三、内核陷阱完整处理流程"></a>三、内核陷阱完整处理流程</h2><p>内核态触发陷阱（如计时器中断、设备中断、内核非法指令）后，流程分为「硬件自动操作→kernelvec 汇编处理→kerneltrap C 处理→陷阱返回」四步：</p>
<h3 id="步骤1：RISC-V-硬件自动操作（无代码，原子执行）"><a href="#步骤1：RISC-V-硬件自动操作（无代码，原子执行）" class="headerlink" title="步骤1：RISC-V 硬件自动操作（无代码，原子执行）"></a>步骤1：RISC-V 硬件自动操作（无代码，原子执行）</h3><p>内核态下触发陷阱时，CPU 硬件会执行以下操作（与用户态陷阱的硬件逻辑一致，但无特权级切换）：</p>
<table>
<thead>
<tr>
<th>硬件操作</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>保存当前 PC 到 <code>sepc</code></td>
<td>记录陷阱打断的内核代码位置（用于返回时恢复执行）</td>
</tr>
<tr>
<td>设置 <code>scause</code> 寄存器</td>
<td>标记陷阱类型：<br>- 设备中断（最高位&#x3D;1，如计时器中断 <code>scause=0x8000000000000005</code>）；<br>- 异常（最高位&#x3D;0，如非法指令、页故障）。</td>
</tr>
<tr>
<td>清空 <code>sstatus.SIE</code></td>
<td>禁用全局中断（避免陷阱嵌套，xv6 不支持中断嵌套）</td>
</tr>
<tr>
<td>跳转到 <code>stvec</code> 指向的 <code>kernelvec</code></td>
<td>进入内核预定义的内核陷阱入口（无需蹦床页，直接在内核页表中）。</td>
</tr>
</tbody></table>
<h3 id="步骤2：kernelvec-汇编处理（保存寄存器到内核栈）"><a href="#步骤2：kernelvec-汇编处理（保存寄存器到内核栈）" class="headerlink" title="步骤2：kernelvec 汇编处理（保存寄存器到内核栈）"></a>步骤2：kernelvec 汇编处理（保存寄存器到内核栈）</h3><p><code>kernelvec</code> 是内核陷阱的第一个入口，核心任务是「保存所有通用寄存器到当前线程的内核栈」，确保被中断的内核代码后续可完整恢复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># kernel/kernelvec.S:10 核心逻辑</span><br><span class="line">kernelvec:</span><br><span class="line">  # 步骤1：保存所有通用寄存器到当前内核栈（sp 已指向当前线程的内核栈）</span><br><span class="line">  sd ra, 0(sp)</span><br><span class="line">  sd sp, 8(sp)</span><br><span class="line">  sd gp, 16(sp)</span><br><span class="line">  sd tp, 24(sp)</span><br><span class="line">  sd t0, 32(sp)</span><br><span class="line">  # ... 省略 t1-t6、a0-a7、s0-s11 等所有寄存器的保存（共32个）</span><br><span class="line">  sd s11, 248(sp)</span><br><span class="line">  </span><br><span class="line">  # 步骤2：跳转到 kerneltrap C 函数处理陷阱逻辑</span><br><span class="line">  call kerneltrap</span><br><span class="line">  </span><br><span class="line">  # 步骤4：陷阱处理完成后，恢复寄存器（见下文「陷阱返回」）</span><br><span class="line">  ld ra, 0(sp)</span><br><span class="line">  ld sp, 8(sp)</span><br><span class="line">  ld gp, 16(sp)</span><br><span class="line">  # ... 恢复所有寄存器</span><br><span class="line">  ld s11, 248(sp)</span><br><span class="line">  </span><br><span class="line">  # 步骤5：sret 返回被中断的内核代码</span><br><span class="line">  sret</span><br></pre></td></tr></table></figure>
<p><strong>核心设计点</strong>：</p>
<ul>
<li>寄存器保存在「当前线程的内核栈」上：寄存器值属于当前线程，即使陷阱触发线程切换（如计时器中断调用 <code>yield</code>），保存的寄存器也会随内核栈保留，线程恢复时可完整读取；</li>
<li>无需切换栈&#x2F;页表：内核栈本身是线程私有、地址合法的，直接复用即可，比用户态陷阱少了「栈&#x2F;页表切换」的核心步骤。</li>
</ul>
<h3 id="步骤3：kerneltrap-C-处理（陷阱分发与逻辑执行）"><a href="#步骤3：kerneltrap-C-处理（陷阱分发与逻辑执行）" class="headerlink" title="步骤3：kerneltrap C 处理（陷阱分发与逻辑执行）"></a>步骤3：kerneltrap C 处理（陷阱分发与逻辑执行）</h3><p><code>kerneltrap()</code>（<code>kernel/trap.c:134</code>）是内核陷阱的核心分发器，仅处理两类陷阱（中断&#x2F;异常），逻辑极简且严格：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c: kerneltrap 核心逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kerneltrap</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 sepc = r_sepc();   <span class="comment">// 读取陷阱打断的PC</span></span><br><span class="line">  uint64 sstatus = r_sstatus(); <span class="comment">// 读取当前特权状态</span></span><br><span class="line">  uint64 scause = r_scause();   <span class="comment">// 读取陷阱原因</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关键：保存 sepc/sstatus（因为 yield 可能修改这些寄存器）</span></span><br><span class="line">  <span class="comment">// 若后续调用 yield 切换线程，恢复时需要原始的 sepc/sstatus</span></span><br><span class="line">  uint64 saved_sepc = sepc;</span><br><span class="line">  uint64 saved_sstatus = sstatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤1：处理设备中断</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000L</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 设备中断：调用 devintr 处理（如计时器、控制台中断）</span></span><br><span class="line">    <span class="keyword">if</span>(devintr() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 未处理的中断（非法中断源），视为异常</span></span><br><span class="line">      panic(<span class="string">&quot;unexpected interrupt in kerneltrap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤2：非中断 → 内核异常（致命错误）</span></span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: unexpected scause %p sepc=%p pid=%d&quot;</span>, </span><br><span class="line">          scause, sepc, p ? p-&gt;pid : <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤3：计时器中断触发线程调度（核心特殊场景）</span></span><br><span class="line">  <span class="comment">// 条件：陷阱是计时器中断 + 当前运行的是进程的内核线程（非调度器线程）</span></span><br><span class="line">  <span class="keyword">if</span>(scause == <span class="number">0x8000000000000005L</span> &amp;&amp; p &amp;&amp; p-&gt;state == RUNNING)&#123;</span><br><span class="line">    yield(); <span class="comment">// 让出CPU，调度其他线程运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤4：恢复保存的 sepc/sstatus（yield 可能修改了这些寄存器）</span></span><br><span class="line">  w_sepc(saved_sepc);</span><br><span class="line">  w_sstatus(saved_sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子步骤3-1：devintr-设备中断处理"><a href="#子步骤3-1：devintr-设备中断处理" class="headerlink" title="子步骤3.1：devintr 设备中断处理"></a>子步骤3.1：devintr 设备中断处理</h4><p><code>devintr()</code>（<code>kernel/trap.c:177</code>）是中断源识别函数，遍历所有设备中断（计时器、控制台、磁盘），处理后清除中断标记：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devintr</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  <span class="comment">// 1. 计时器中断（核心）</span></span><br><span class="line">  <span class="keyword">if</span>(scause == <span class="number">0x8000000000000005L</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr(); <span class="comment">// 全局计时器中断处理（更新时间、触发调度）</span></span><br><span class="line">    &#125;</span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>); <span class="comment">// 清除计时器中断标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 控制台中断</span></span><br><span class="line">  <span class="keyword">if</span>(scause == <span class="number">0x8000000000000009L</span>)&#123;</span><br><span class="line">    consoleintr();</span><br><span class="line">    w_sip(r_sip() &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">1</span>)); <span class="comment">// 清除控制台中断标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 磁盘中断（省略）</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未识别的中断源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4：陷阱返回（恢复寄存器-sret）"><a href="#步骤4：陷阱返回（恢复寄存器-sret）" class="headerlink" title="步骤4：陷阱返回（恢复寄存器 + sret）"></a>步骤4：陷阱返回（恢复寄存器 + sret）</h3><p><code>kerneltrap()</code> 执行完成后，返回 <code>kernelvec</code> 汇编代码，执行以下操作：</p>
<ol>
<li>从当前内核栈中「弹出」之前保存的所有通用寄存器（恢复到 CPU 寄存器）；</li>
<li>执行 <code>sret</code> 指令：将 <code>sepc</code> 写入 PC，恢复 <code>sstatus</code> 中的中断使能，CPU 回到「被陷阱打断的内核代码位置」继续执行。</li>
</ol>
<h2 id="四、关键特殊场景：计时器中断触发-yield-后的陷阱返回"><a href="#四、关键特殊场景：计时器中断触发-yield-后的陷阱返回" class="headerlink" title="四、关键特殊场景：计时器中断触发 yield 后的陷阱返回"></a>四、关键特殊场景：计时器中断触发 yield 后的陷阱返回</h2><p>这是内核陷阱中最复杂的场景——陷阱处理过程中触发了线程切换，需理解「线程调度与陷阱返回的协同逻辑」：</p>
<h3 id="场景流程拆解"><a href="#场景流程拆解" class="headerlink" title="场景流程拆解"></a>场景流程拆解</h3><ol>
<li><strong>触发计时器中断</strong>：内核线程 A 运行时，CPU 触发计时器中断，进入 <code>kernelvec</code> → <code>kerneltrap</code>；</li>
<li><strong>调用 yield()</strong>：<code>kerneltrap</code> 识别到计时器中断，且当前是进程内核线程，调用 <code>yield()</code>；</li>
<li><strong>yield() 执行调度</strong>：<ul>
<li>将线程 A 的状态从 <code>RUNNING</code> 改为 <code>RUNNABLE</code>，放入就绪队列；</li>
<li>调度器选择线程 B 执行（切换到线程 B 的内核栈，恢复线程 B 的上下文）；</li>
<li>线程 B 开始运行，线程 A 暂时被挂起；</li>
</ul>
</li>
<li><strong>线程 A 被重新调度</strong>：后续某个时刻，调度器选中线程 A，恢复其内核栈和上下文；</li>
<li><strong>kerneltrap 恢复</strong>：线程 A 的 <code>kerneltrap</code> 从 <code>yield()</code> 返回，恢复之前保存的 <code>sepc</code> 和 <code>sstatus</code>；</li>
<li><strong>陷阱返回</strong>：回到 <code>kernelvec</code>，恢复线程 A 的所有寄存器，执行 <code>sret</code>，线程 A 从「被中断的位置」继续执行。</li>
</ol>
<h3 id="核心关键"><a href="#核心关键" class="headerlink" title="核心关键"></a>核心关键</h3><ul>
<li>线程 A 的寄存器保存在其<strong>私有内核栈</strong>上，即使被调度出去，栈数据不会丢失；</li>
<li><code>kerneltrap</code> 提前保存 <code>sepc/sstatus</code>，避免 <code>yield()</code> 切换线程时覆盖这些关键寄存器；</li>
<li><code>sret</code> 最终恢复的是线程 A 被中断的 PC，而非调度器的代码位置，保证线程执行的连续性。</li>
</ul>
<h2 id="五、安全保障：stvec-切换的时间窗口"><a href="#五、安全保障：stvec-切换的时间窗口" class="headerlink" title="五、安全保障：stvec 切换的时间窗口"></a>五、安全保障：stvec 切换的时间窗口</h2><p>xv6 存在一个关键的「stvec 配置窗口」，若处理不当会导致内核崩溃，其安全保障逻辑如下：</p>
<h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><p>当 CPU 从用户态进入内核时（如用户态陷阱），存在一个短暂窗口：</p>
<ul>
<li>陷阱触发后，CPU 先跳转到 <code>uservec</code>（此时 <code>stvec</code> 仍指向 <code>uservec</code>）；</li>
<li><code>usertrap()</code> 会将 <code>stvec</code> 改为 <code>kernelvec</code>，但这一步是「软件操作」，存在延迟。</li>
</ul>
<p>若此窗口内启用中断，内核态触发的陷阱会跳转到 <code>uservec</code>（而非 <code>kernelvec</code>），但 <code>uservec</code> 依赖用户页表&#x2F;陷阱帧，内核态执行会导致地址非法、寄存器保存失败，最终系统崩溃。</p>
<h3 id="xv6-的安全措施"><a href="#xv6-的安全措施" class="headerlink" title="xv6 的安全措施"></a>xv6 的安全措施</h3><ol>
<li><strong>RISC-V 硬件兜底</strong>：陷阱触发时，CPU 会自动清空 <code>sstatus.SIE</code>（禁用全局中断），因此在 <code>usertrap()</code> 完成 <code>stvec</code> 切换前，不会有新的陷阱触发；</li>
<li><strong>软件显式控制</strong>：xv6 在 <code>usertrap()</code> 中，先完成 <code>stvec = kernelvec</code> 的配置，再通过 <code>w_sstatus()</code> 重新启用中断，彻底关闭这个安全窗口。</li>
</ol>
<h2 id="六、核心总结"><a href="#六、核心总结" class="headerlink" title="六、核心总结"></a>六、核心总结</h2><p>内核空间陷阱的设计核心是「极简+安全」：</p>
<ol>
<li><strong>极简</strong>：复用内核页表&#x2F;栈，无需切换，仅保存寄存器到当前线程栈，分发中断&#x2F;异常；</li>
<li><strong>安全</strong>：<ul>
<li>内核异常直接 panic（内核代码不应出错，出错即致命）；</li>
<li>中断处理后恢复关键寄存器，保证线程执行连续性；</li>
<li>严格控制 <code>stvec</code> 切换窗口，避免陷阱入口错误。</li>
</ul>
</li>
</ol>
<p>整个流程的核心链路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核代码运行 → 触发陷阱（中断/异常）→ 硬件跳 kernelvec → 保存寄存器到内核栈 → kerneltrap 处理（中断/异常）→ （可选）yield 调度线程 → 恢复寄存器 → sret 返回被中断的内核代码</span><br></pre></td></tr></table></figure>

<p>与用户态陷阱相比，内核陷阱少了「页表&#x2F;栈切换、用户寄存器到 trapframe 的保存」等复杂步骤，本质是因为内核已处于「安全、合法的执行环境」中，只需聚焦于「中断处理+线程调度」即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">xv6 系统调用参数处理：提取、校验与安全传输</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-29 20:14:40 / 修改时间：20:15:24" itemprop="dateCreated datePublished" datetime="2025-12-29T20:14:40+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="xv6-系统调用参数处理：提取、校验与安全传输"><a href="#xv6-系统调用参数处理：提取、校验与安全传输" class="headerlink" title="xv6 系统调用参数处理：提取、校验与安全传输"></a>xv6 系统调用参数处理：提取、校验与安全传输</h1><p>xv6 处理系统调用参数的核心挑战是：<strong>既要从用户态获取参数，又要防止恶意&#x2F;错误的用户参数（如无效指针、越权地址）破坏内核安全</strong>。整个流程围绕「参数保存→基础提取→指针安全校验→数据传输」展开，以下结合源码和原理详细拆解。</p>
<h2 id="一、核心背景：参数处理的核心问题"><a href="#一、核心背景：参数处理的核心问题" class="headerlink" title="一、核心背景：参数处理的核心问题"></a>一、核心背景：参数处理的核心问题</h2><ol>
<li><strong>参数存储位置</strong>：用户态按 RISC-V C 调用约定，将系统调用参数放入 <code>a0-a7</code> 寄存器，系统调用号放入 <code>a7</code>；</li>
<li><strong>隔离性约束</strong>：内核页表与用户页表完全独立（内核页表映射物理内存+内核代码，用户页表仅映射用户空间+蹦床页），内核不能直接用用户指针访问内存；</li>
<li><strong>安全风险</strong>：用户可能传递「无效指针（如野指针）」「越权地址（如指向内核内存的地址）」，需校验地址合法性。</li>
</ol>
<h2 id="二、步骤1：用户参数的保存（寄存器-→-陷阱帧）"><a href="#二、步骤1：用户参数的保存（寄存器-→-陷阱帧）" class="headerlink" title="二、步骤1：用户参数的保存（寄存器 → 陷阱帧）"></a>二、步骤1：用户参数的保存（寄存器 → 陷阱帧）</h2><p>用户执行 <code>ecall</code> 触发陷阱后，<code>uservec</code> 汇编代码会将所有用户寄存器（包括 <code>a0-a7</code>）保存到当前进程的 <code>trapframe</code>（进程私有）中。陷阱帧中寄存器的存储偏移是固定的（与 RISC-V 寄存器一一对应）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h: trapframe 结构体（寄存器存储偏移）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  uint64 ra;   <span class="comment">// 0</span></span><br><span class="line">  uint64 sp;   <span class="comment">// 8</span></span><br><span class="line">  uint64 gp;   <span class="comment">// 16</span></span><br><span class="line">  <span class="comment">// ... 省略 t0-t6、s0-s11 等</span></span><br><span class="line">  uint64 a0;   <span class="comment">// 72 （第0个系统调用参数）</span></span><br><span class="line">  uint64 a1;   <span class="comment">// 80 （第1个系统调用参数）</span></span><br><span class="line">  uint64 a2;   <span class="comment">// 88 （第2个系统调用参数）</span></span><br><span class="line">  <span class="comment">// ... 直到 a7（128，系统调用号）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核后续所有参数提取操作，都是直接读取 <code>trapframe</code> 中保存的寄存器值，而非用户态寄存器（内核无法直接访问用户态寄存器）。</p>
<h2 id="三、步骤2：基础参数提取（argraw-argint-argaddr-argfd）"><a href="#三、步骤2：基础参数提取（argraw-argint-argaddr-argfd）" class="headerlink" title="三、步骤2：基础参数提取（argraw&#x2F;argint&#x2F;argaddr&#x2F;argfd）"></a>三、步骤2：基础参数提取（argraw&#x2F;argint&#x2F;argaddr&#x2F;argfd）</h2><p>内核提供一组基础函数，从 <code>trapframe</code> 中提取不同类型的参数，核心是 <code>argraw</code>（读取原始寄存器值），上层封装 <code>argint</code>（整数）、<code>argaddr</code>（指针）、<code>argfd</code>（文件描述符）。</p>
<h3 id="1-核心基础：argraw（读取原始寄存器值）"><a href="#1-核心基础：argraw（读取原始寄存器值）" class="headerlink" title="1. 核心基础：argraw（读取原始寄存器值）"></a>1. 核心基础：argraw（读取原始寄存器值）</h3><p><code>argraw</code> 是所有参数提取函数的底层，作用是「根据参数序号，从 trapframe 中读取对应的用户寄存器值」：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c:35 argraw 实现</span></span><br><span class="line"><span class="type">static</span> uint64 <span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// n=0 → a0（偏移72），n=1 → a1（偏移80），以此类推</span></span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:  <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  <span class="keyword">default</span>: panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数序号 <code>n</code> 对应系统调用的参数位置（如 <code>exec(path, argv)</code> 中，<code>path</code> 是 n&#x3D;0，<code>argv</code> 是 n&#x3D;1）；</li>
<li>直接读取 <code>trapframe</code> 中保存的 <code>a0-a5</code>（xv6 系统调用最多6个参数），无校验，仅返回原始值。</li>
</ul>
<h3 id="2-argint：提取整数参数"><a href="#2-argint：提取整数参数" class="headerlink" title="2. argint：提取整数参数"></a>2. argint：提取整数参数</h3><p><code>argint</code> 封装 <code>argraw</code>，将原始值作为整数存入目标指针，无额外校验（整数参数无地址风险）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c: argint 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span> &#123;</span><br><span class="line">  *ip = argraw(n); <span class="comment">// 直接赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：如 <code>exit(int status)</code> 系统调用，<code>status</code> 是整数，通过 <code>argint(0, &amp;status)</code> 提取。</p>
<h3 id="3-argaddr：提取指针参数（初步校验）"><a href="#3-argaddr：提取指针参数（初步校验）" class="headerlink" title="3. argaddr：提取指针参数（初步校验）"></a>3. argaddr：提取指针参数（初步校验）</h3><p><code>argaddr</code> 提取用户指针（虚拟地址），并做基础合法性校验：<strong>地址必须小于 MAXVA（用户空间上限，如 0x80000000）</strong>，防止用户传递内核地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c: argaddr 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span> &#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="comment">// 校验：地址必须在用户空间（MAXVA 是用户虚拟地址上限）</span></span><br><span class="line">  <span class="keyword">if</span>(*ip &gt;= MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：如 <code>exec</code> 的 <code>argv</code> 参数是指针数组，通过 <code>argaddr(1, &amp;argv)</code> 提取并初检。</p>
<h3 id="4-argfd：提取文件描述符（有效性校验）"><a href="#4-argfd：提取文件描述符（有效性校验）" class="headerlink" title="4. argfd：提取文件描述符（有效性校验）"></a>4. argfd：提取文件描述符（有效性校验）</h3><p><code>argfd</code> 提取文件描述符，并校验其有效性（是否打开、是否属于当前进程），返回对应的 <code>file</code> 结构体指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c: argfd 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">argfd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *fd, <span class="keyword">struct</span> file **f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一步：提取文件描述符整数</span></span><br><span class="line">  <span class="keyword">if</span>(argint(n, fd) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 第二步：校验 fd 合法性（0 ≤ fd &lt; NOFILE，且对应 file 非空）</span></span><br><span class="line">  <span class="keyword">if</span>(*fd &lt; <span class="number">0</span> || *fd &gt;= NOFILE || (p-&gt;ofile[*fd] == <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 第三步：增加 file 引用计数，防止被提前关闭</span></span><br><span class="line">  *f = p-&gt;ofile[*fd];</span><br><span class="line">  (*f)-&gt;ref++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：如 <code>read(int fd, void *buf, int n)</code>，通过 <code>argfd(0, &amp;fd, &amp;f)</code> 提取并校验文件描述符。</p>
<h2 id="四、步骤3：指针参数的安全挑战（两大核心问题）"><a href="#四、步骤3：指针参数的安全挑战（两大核心问题）" class="headerlink" title="四、步骤3：指针参数的安全挑战（两大核心问题）"></a>四、步骤3：指针参数的安全挑战（两大核心问题）</h2><p>当系统调用参数是「用户空间指针」（如 <code>exec</code> 的 <code>path</code> 字符串指针、<code>read</code> 的 <code>buf</code> 指针）时，会面临两个关键问题：</p>
<ol>
<li><strong>地址合法性</strong>：用户可能传递「无效指针（如野指针）」「越权地址（如指向内核内存的地址 &gt; MAXVA）」；</li>
<li><strong>页表隔离</strong>：内核页表与用户页表映射不同，内核不能直接用用户指针访问内存（用户指针在用户页表中有效，在内核页表中可能指向无关内存）。</li>
</ol>
<p>为解决这些问题，xv6 实现了 <code>walkaddr</code>（地址合法性校验）、<code>copyinstr</code>（从用户空间读数据）、<code>copyout</code>（向用户空间写数据）三个核心函数。</p>
<h2 id="五、步骤4：安全数据传输函数（walkaddr-copyinstr-copyout）"><a href="#五、步骤4：安全数据传输函数（walkaddr-copyinstr-copyout）" class="headerlink" title="五、步骤4：安全数据传输函数（walkaddr&#x2F;copyinstr&#x2F;copyout）"></a>五、步骤4：安全数据传输函数（walkaddr&#x2F;copyinstr&#x2F;copyout）</h2><h3 id="1-walkaddr：遍历用户页表，验证地址合法性"><a href="#1-walkaddr：遍历用户页表，验证地址合法性" class="headerlink" title="1. walkaddr：遍历用户页表，验证地址合法性"></a>1. walkaddr：遍历用户页表，验证地址合法性</h3><p><code>walkaddr</code> 是核心安全函数，作用是「遍历用户页表，验证虚拟地址的合法性，并返回其对应的物理地址」（内核可直接访问物理地址）。</p>
<h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a>核心逻辑：</h4><ul>
<li>遍历用户页表（SV39 三级页表），找到虚拟地址对应的页表项（PTE）；</li>
<li>校验：PTE 必须有效（PTE_V 位为1）、地址必须在用户空间（&lt; MAXVA）、权限符合用户态访问（PTE_U 位为1）；</li>
<li>返回：物理地址的内核虚拟地址（内核页表映射所有物理内存，因此可直接访问）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:95 walkaddr 实现</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验1：地址必须在用户空间（va &lt; MAXVA）</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历用户页表，找到 va 对应的 PTE</span></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 校验2：PTE 必须存在（有效）</span></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 校验3：PTE 必须允许用户态访问（PTE_U 位）</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 提取物理地址（PTE 的物理页号 &lt;&lt; 12）</span></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>walk</code> 函数：纯软件实现页表遍历，返回 va 对应的 PTE 指针（三级页表逐层查找）；</li>
<li><code>PTE2PA</code>：从 PTE 中提取物理页地址（PTE 的低 44 位是物理页号，左移 12 位得到物理地址）；</li>
<li>内核通过返回的物理地址，可直接访问用户内存（内核页表映射所有物理内存）。</li>
</ul>
<h3 id="2-copyinstr：从用户空间读取字符串（安全）"><a href="#2-copyinstr：从用户空间读取字符串（安全）" class="headerlink" title="2. copyinstr：从用户空间读取字符串（安全）"></a>2. copyinstr：从用户空间读取字符串（安全）</h3><p><code>copyinstr</code> 基于 <code>walkaddr</code>，将用户空间的字符串复制到内核缓冲区，同时处理「字符串终止符（\0）」「最大长度限制」，防止缓冲区溢出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c:406 copyinstr 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span> &#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(max &gt; <span class="number">0</span> &amp;&amp; !got_null)&#123;</span><br><span class="line">    <span class="comment">// 对齐到页边界，取当前页的虚拟地址</span></span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    <span class="comment">// 校验用户地址，获取物理地址</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 计算当前页内的偏移</span></span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; max) n = max;</span><br><span class="line">    <span class="comment">// 从物理地址复制到内核缓冲区（内核可直接访问 pa0）</span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)(pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">char</span> c = *p++;</span><br><span class="line">      *dst++ = c;</span><br><span class="line">      srcva++;</span><br><span class="line">      max--;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!got_null &amp;&amp; max == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无终止符，溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心特性</strong>：</p>
<ul>
<li>逐页复制：处理跨页的字符串（如字符串跨2个用户页）；</li>
<li>终止符检测：遇到 <code>\0</code> 立即停止，符合 C 字符串规范；</li>
<li>长度限制：最多复制 <code>max</code> 字节，防止内核缓冲区溢出。</li>
</ul>
<h3 id="3-copyout：向用户空间写入数据（安全）"><a href="#3-copyout：向用户空间写入数据（安全）" class="headerlink" title="3. copyout：向用户空间写入数据（安全）"></a>3. copyout：向用户空间写入数据（安全）</h3><p><code>copyout</code> 是 <code>copyinstr</code> 的反向操作，将内核数据复制到用户空间，同样通过 <code>walkaddr</code> 校验用户地址合法性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c: copyout 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len) n = len;</span><br><span class="line">    <span class="comment">// 内核数据 → 用户物理地址（内核可直接写 pa0）</span></span><br><span class="line">    memmove((<span class="type">void</span>*)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong>：如 <code>read</code> 系统调用，内核将文件数据通过 <code>copyout</code> 写入用户提供的 <code>buf</code> 指针。</p>
<h2 id="六、实战示例：exec-系统调用的参数处理全链路"><a href="#六、实战示例：exec-系统调用的参数处理全链路" class="headerlink" title="六、实战示例：exec 系统调用的参数处理全链路"></a>六、实战示例：exec 系统调用的参数处理全链路</h2><p><code>exec</code> 的 <code>path</code> 参数是用户空间字符串指针，其处理链路完整体现了上述所有函数的协作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c: sys_exec → argstr → fetchstr → copyinstr</span></span><br><span class="line">uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *path;</span><br><span class="line">  <span class="comment">// 步骤1：argstr 提取路径字符串（封装 fetchstr）</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, &amp;path) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  <span class="comment">// ... 后续处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c: argstr 实现（提取字符串参数）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> **cp)</span> &#123;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="comment">// 步骤2：argaddr 提取用户指针并初检</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(n, &amp;va) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 步骤3：fetchstr 读取用户字符串到内核缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> fetchstr(va, cp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c:25 fetchstr 实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fetchstr</span><span class="params">(uint64 va, <span class="type">char</span> **cp)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf = kalloc(); <span class="comment">// 分配内核缓冲区</span></span><br><span class="line">  <span class="keyword">if</span>(buf == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 步骤4：copyinstr 安全读取用户字符串</span></span><br><span class="line">  <span class="keyword">if</span>(copyinstr(myproc()-&gt;pagetable, buf, va, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *cp = buf;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>链路总结</strong>：<br><code>argaddr</code>（初检指针）→ <code>copyinstr</code>（校验地址+读取字符串）→ <code>fetchstr</code>（封装内核缓冲区）→ <code>argstr</code>（返回内核字符串指针），全程确保用户指针合法、数据传输安全。</p>
<h2 id="七、核心设计总结"><a href="#七、核心设计总结" class="headerlink" title="七、核心设计总结"></a>七、核心设计总结</h2><table>
<thead>
<tr>
<th>函数&#x2F;机制</th>
<th>核心作用</th>
<th>解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td>trapframe</td>
<td>保存用户寄存器值</td>
<td>内核无法直接访问用户态寄存器</td>
</tr>
<tr>
<td>argraw&#x2F;argint&#x2F;argfd</td>
<td>提取基础类型参数</td>
<td>快速获取整数&#x2F;文件描述符，初检合法性</td>
</tr>
<tr>
<td>walkaddr</td>
<td>遍历用户页表，验证地址并返回物理地址</td>
<td>防止用户传递无效&#x2F;越权地址</td>
</tr>
<tr>
<td>copyinstr&#x2F;copyout</td>
<td>安全传输用户&#x2F;内核数据</td>
<td>页表隔离导致的直接访问失败、缓冲区溢出</td>
</tr>
</tbody></table>
<p>xv6 的参数处理设计核心是「<strong>最小权限+分层校验</strong>」：</p>
<ol>
<li>基础参数：仅做类型&#x2F;范围初检；</li>
<li>指针参数：通过页表遍历做深度合法性校验；</li>
<li>数据传输：逐页复制+长度限制，防止溢出&#x2F;越权。</li>
</ol>
<p>这种设计既保证了内核安全（隔离用户恶意操作），又适配了 RISC-V 页表架构（软件遍历页表），是嵌入式操作系统参数处理的典型范式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/xv6-%E4%B8%AD-exec-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0/xv6-%E4%B8%AD-exec-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF/" class="post-title-link" itemprop="url">xv6 中 exec 系统调用的完整调用链路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-29 20:01:45 / 修改时间：20:08:53" itemprop="dateCreated datePublished" datetime="2025-12-29T20:01:45+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="xv6-中-exec-系统调用的完整调用链路解析"><a href="#xv6-中-exec-系统调用的完整调用链路解析" class="headerlink" title="xv6 中 exec 系统调用的完整调用链路解析"></a>xv6 中 exec 系统调用的完整调用链路解析</h3><p>用户态调用 <code>exec</code> 系统调用是「用户参数准备→ecall触发陷阱→内核陷阱处理→系统调用分发→执行核心逻辑→返回值传递」的典型流程，以下结合代码和 RISC-V 调用约定，拆解每一步的核心逻辑：</p>
<h4 id="一、前置知识：关键约定"><a href="#一、前置知识：关键约定" class="headerlink" title="一、前置知识：关键约定"></a>一、前置知识：关键约定</h4><ol>
<li><strong>RISC-V C 调用约定</strong>：<ul>
<li>函数参数依次放在 <code>a0-a7</code> 寄存器；</li>
<li>返回值放在 <code>a0</code> 寄存器；</li>
<li>xv6 系统调用复用该约定：系统调用参数存在 <code>a0-a7</code>，系统调用号存在 <code>a7</code>，返回值写入 <code>a0</code>。</li>
</ul>
</li>
<li><strong>系统调用号映射</strong>：<ul>
<li>内核定义 <code>SYS_exec</code>（<code>kernel/syscall.h:8</code>）作为 <code>exec</code> 的唯一标识（如 <code>#define SYS_exec 11</code>）；</li>
<li><code>syscalls</code> 数组（<code>kernel/syscall.c:108</code>）是函数指针表，索引对应系统调用号，值为内核实现函数（如 <code>syscalls[SYS_exec] = sys_exec</code>）。</li>
</ul>
</li>
</ol>
<h4 id="二、步骤1：用户态准备参数并触发-ecall（initcode-S）"><a href="#二、步骤1：用户态准备参数并触发-ecall（initcode-S）" class="headerlink" title="二、步骤1：用户态准备参数并触发 ecall（initcode.S）"></a>二、步骤1：用户态准备参数并触发 ecall（initcode.S）</h4><p><code>initcode.S</code> 是 xv6 第一个用户进程的汇编代码，其调用 <code>exec</code> 系统调用的核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># user/initcode.S: 调用 exec(&quot;/init&quot;, argv)</span><br><span class="line">li a7, SYS_exec   # a7 = 系统调用号 SYS_exec（如11）</span><br><span class="line">la a0, init       # a0 = 第一个参数：程序路径 &quot;/init&quot;（字符串地址）</span><br><span class="line">la a1, argv       # a1 = 第二个参数：参数数组 argv（[&quot;/init&quot;, 0]）</span><br><span class="line">ecall             # 触发陷阱，进入内核</span><br><span class="line"></span><br><span class="line"># 若 exec 失败（返回-1），执行 exit</span><br><span class="line">li a7, SYS_exit</span><br><span class="line">ecall</span><br><span class="line"></span><br><span class="line"># 数据定义</span><br><span class="line">init: .string &quot;/init&quot;</span><br><span class="line">argv: .quad init</span><br><span class="line">      .quad 0</span><br></pre></td></tr></table></figure>
<p><strong>核心操作</strong>：</p>
<ul>
<li>按约定将 <code>exec</code> 的两个参数（路径、参数数组）放入 <code>a0</code>&#x2F;<code>a1</code>；</li>
<li>将系统调用号 <code>SYS_exec</code> 放入 <code>a7</code>；</li>
<li>执行 <code>ecall</code> 指令，触发用户态陷阱（RISC-V 硬件自动完成特权级切换、跳 <code>stvec</code> 指向的 <code>uservec</code>）。</li>
</ul>
<h4 id="三、步骤2：内核陷阱处理（uservec-→-usertrap）"><a href="#三、步骤2：内核陷阱处理（uservec-→-usertrap）" class="headerlink" title="三、步骤2：内核陷阱处理（uservec → usertrap）"></a>三、步骤2：内核陷阱处理（uservec → usertrap）</h4><p>这一步是通用陷阱处理流程（前文详解过），核心是<strong>保存用户寄存器到 trapframe</strong>，并识别系统调用：</p>
<ol>
<li><code>uservec</code>（汇编）：将用户态所有寄存器（包括 <code>a0/a1/a7</code>）保存到当前进程的 <code>trapframe</code>，切换到内核页表后跳转到 <code>usertrap</code>；</li>
<li><code>usertrap</code>（C）：<ul>
<li>读取 <code>scause</code> 寄存器，识别出陷阱类型为「系统调用（scause&#x3D;8）」；</li>
<li>修正 <code>sepc += 4</code>（跳过 <code>ecall</code> 指令，若系统调用成功返回，用户态从下一条指令执行）；</li>
<li>调用 <code>syscall()</code> 函数分发系统调用。</li>
</ul>
</li>
</ol>
<h4 id="四、步骤3：系统调用分发（syscall-c）"><a href="#四、步骤3：系统调用分发（syscall-c）" class="headerlink" title="四、步骤3：系统调用分发（syscall.c）"></a>四、步骤3：系统调用分发（syscall.c）</h4><p><code>syscall()</code> 是内核的系统调用总入口，核心逻辑是「从 trapframe 读系统调用号→索引函数表→执行对应内核函数→记录返回值」：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c:133 简化版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 syscallno = p-&gt;trapframe-&gt;a7; <span class="comment">// 从trapframe读取a7（SYS_exec）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查系统调用号是否有效</span></span><br><span class="line">  <span class="keyword">if</span>(syscallno &gt;= NELEM(syscalls) || syscalls[syscallno] == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unknown syscall %lu pid=%d\n&quot;</span>, syscallno, p-&gt;pid);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>; <span class="comment">// 无效调用，返回-1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行对应内核函数（sys_exec），返回值存入a0</span></span><br><span class="line">  p-&gt;trapframe-&gt;a0 = (*syscalls[syscallno])(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syscalls 函数指针表（kernel/syscall.c:108）</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  [SYS_fork]    sys_fork,</span><br><span class="line">  [SYS_exec]    sys_exec,  <span class="comment">// 索引SYS_exec对应sys_exec函数</span></span><br><span class="line">  [SYS_exit]    sys_exit,</span><br><span class="line">  <span class="comment">// ... 其他系统调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>核心细节</strong>：</p>
<ul>
<li>为什么从 <code>p-&gt;trapframe-&gt;a7</code> 读系统调用号？因为 <code>uservec</code> 已将用户态 <code>a7</code> 保存到陷阱帧，内核无法直接访问用户态寄存器，只能通过陷阱帧读取；</li>
<li><code>sys_exec()</code> 是 <code>exec</code> 系统调用的内核实现，完成「加载可执行文件、替换进程内存空间、重置寄存器」等核心逻辑；</li>
<li>无论 <code>sys_exec</code> 成功（返回0）还是失败（返回-1），返回值都会被写入 <code>p-&gt;trapframe-&gt;a0</code>——这是返回用户态的关键。</li>
</ul>
<h4 id="五、步骤4：返回用户态与返回值生效"><a href="#五、步骤4：返回用户态与返回值生效" class="headerlink" title="五、步骤4：返回用户态与返回值生效"></a>五、步骤4：返回用户态与返回值生效</h4><p>内核完成 <code>sys_exec</code> 后，通过 <code>usertrapret + userret</code> 切回用户态：</p>
<ol>
<li><code>usertrapret</code>：重置 <code>stvec</code> 为 <code>uservec</code>（为下次陷阱做准备），恢复 <code>sepc</code> 为修正后的用户PC；</li>
<li><code>userret</code>（汇编）：切换回用户页表，从陷阱帧恢复所有用户寄存器（重点：<code>a0</code> 被恢复为内核写入的返回值）；</li>
<li><code>sret</code> 指令：CPU 切回用户态，从 <code>sepc</code> 指向的地址继续执行。</li>
</ol>
<p><strong>特殊点：exec 成功后无返回</strong><br><code>exec</code> 系统调用的特殊性在于：若成功，它会替换当前进程的整个内存空间、寄存器上下文（包括 <code>sepc</code>），指向新程序（<code>/init</code>）的入口地址——因此原 <code>initcode.S</code> 中 <code>ecall</code> 后的代码永远不会执行；只有 <code>exec</code> 失败时，<code>a0</code> 会被设为-1，用户态才会执行后续的 <code>exit</code> 系统调用。</p>
<h4 id="六、关键总结：系统调用的核心逻辑闭环"><a href="#六、关键总结：系统调用的核心逻辑闭环" class="headerlink" title="六、关键总结：系统调用的核心逻辑闭环"></a>六、关键总结：系统调用的核心逻辑闭环</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>核心操作</th>
<th>寄存器&#x2F;陷阱帧作用</th>
</tr>
</thead>
<tbody><tr>
<td>用户态触发</td>
<td>a0&#x2F;a1放参数，a7放调用号，执行ecall</td>
<td>复用RISC-V C调用约定</td>
</tr>
<tr>
<td>内核陷阱处理</td>
<td>uservec保存寄存器到trapframe</td>
<td>陷阱帧是用户&#x2F;内核的“数据桥梁”</td>
</tr>
<tr>
<td>系统调用分发</td>
<td>读trapframe-&gt;a7，调用sys_exec</td>
<td>syscalls表实现调用号到内核函数的映射</td>
</tr>
<tr>
<td>返回用户态</td>
<td>恢复trapframe-&gt;a0到用户态a0</td>
<td>符合C调用约定，用户态拿到返回值</td>
</tr>
</tbody></table>
<h4 id="补充：错误处理逻辑"><a href="#补充：错误处理逻辑" class="headerlink" title="补充：错误处理逻辑"></a>补充：错误处理逻辑</h4><p>若用户传入的系统调用号无效（如 <code>a7</code> 超出 <code>syscalls</code> 数组范围），<code>syscall()</code> 会：</p>
<ol>
<li>打印错误日志（<code>unknown syscall</code>）；</li>
<li>将 <code>trapframe-&gt;a0</code> 设为-1；</li>
<li>返回用户态后，用户态的系统调用返回值即为-1，可据此判断调用失败。</li>
</ol>
<p>这一流程是 xv6 所有系统调用的通用模板（如 <code>fork</code>&#x2F;<code>exit</code>&#x2F;<code>read</code> 等），仅「参数个数、系统调用号、内核实现函数」不同，核心的陷阱处理、寄存器传递、返回值逻辑完全一致。</p>
<hr>
<h1 id="xv6-中-exec-系统调用完整调用过程解析"><a href="#xv6-中-exec-系统调用完整调用过程解析" class="headerlink" title="xv6 中 exec 系统调用完整调用过程解析"></a>xv6 中 exec 系统调用完整调用过程解析</h1><p><code>exec</code> 是 xv6 核心系统调用之一，其核心作用是<strong>替换当前进程的内存空间、寄存器上下文为新程序</strong>（成功则原程序代码不再执行，失败则返回错误码）。整个调用过程横跨「用户态封装→陷阱触发→内核分发→核心执行→返回用户态」，以下从<strong>函数调用&#x2F;汇编存根、用户态→内核态切换、内核态 exec 核心操作、返回处理</strong> 四个维度详细拆解。</p>
<h2 id="一、前置知识：核心约定与背景"><a href="#一、前置知识：核心约定与背景" class="headerlink" title="一、前置知识：核心约定与背景"></a>一、前置知识：核心约定与背景</h2><h3 id="1-exec-的核心语义"><a href="#1-exec-的核心语义" class="headerlink" title="1. exec 的核心语义"></a>1. exec 的核心语义</h3><ul>
<li>输入：程序路径（<code>path</code>）、参数数组（<code>argv</code>）；</li>
<li>输出：成功则无返回（新程序直接执行），失败则返回 <code>-1</code> 等错误码；</li>
<li>本质：复用当前进程的 PID、内核栈、文件描述符等资源，仅替换「用户内存空间 + 执行上下文」。</li>
</ul>
<h3 id="2-关键约定"><a href="#2-关键约定" class="headerlink" title="2. 关键约定"></a>2. 关键约定</h3><table>
<thead>
<tr>
<th>约定类型</th>
<th>具体规则</th>
</tr>
</thead>
<tbody><tr>
<td>RISC-V C 调用</td>
<td>参数存在 <code>a0-a7</code>，返回值存在 <code>a0</code>；函数调用栈向下生长，栈底存返回地址。</td>
</tr>
<tr>
<td>xv6 系统调用</td>
<td>复用 RISC-V 约定：系统调用号存在 <code>a7</code>，参数存在 <code>a0-a1</code>（exec 仅需2个参数），返回值写入 <code>trapframe-&gt;a0</code>。</td>
</tr>
<tr>
<td>系统调用号映射</td>
<td><code>SYS_exec</code>（定义在 <code>syscall.h</code>，如 <code>#define SYS_exec 11</code>）对应 <code>syscalls</code> 数组中的 <code>sys_exec</code> 函数。</td>
</tr>
<tr>
<td>内存映射规则</td>
<td>用户页表必须包含 <code>TRAMPOLINE</code>（蹦床页）和 <code>TRAPFRAME</code>（陷阱帧），新程序页表需继承这两个映射以支持后续陷阱。</td>
</tr>
</tbody></table>
<h2 id="二、阶段1：用户态调用准备（汇编存根-参数封装）"><a href="#二、阶段1：用户态调用准备（汇编存根-参数封装）" class="headerlink" title="二、阶段1：用户态调用准备（汇编存根 + 参数封装）"></a>二、阶段1：用户态调用准备（汇编存根 + 参数封装）</h2><p>xv6 中用户态调用 <code>exec</code> 分两种场景：<strong>手写汇编调用（如 initcode.S）</strong> 和 <strong>C 库封装调用（普通用户程序）</strong>，本质逻辑一致。</p>
<h3 id="1-场景1：手写汇编调用（initcode-S，xv6-第一个用户进程）"><a href="#1-场景1：手写汇编调用（initcode-S，xv6-第一个用户进程）" class="headerlink" title="1. 场景1：手写汇编调用（initcode.S，xv6 第一个用户进程）"></a>1. 场景1：手写汇编调用（initcode.S，xv6 第一个用户进程）</h3><p><code>initcode.S</code> 是 xv6 启动后创建的第一个用户进程，直接通过汇编触发 <code>exec</code> 系统调用，核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># user/initcode.S: 调用 exec(&quot;/init&quot;, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  # 步骤1：准备 exec 参数（RISC-V 调用约定）</span><br><span class="line">  li a7, SYS_exec   # a7 = 系统调用号 SYS_exec（值为11）</span><br><span class="line">  la a0, init       # a0 = 第一个参数：程序路径 &quot;/init&quot;（用户虚拟地址）</span><br><span class="line">  la a1, argv       # a1 = 第二个参数：参数数组 [&quot;init&quot;, 0]（用户虚拟地址）</span><br><span class="line">  </span><br><span class="line">  # 步骤2：触发 ecall，陷入内核</span><br><span class="line">  ecall             </span><br><span class="line">  </span><br><span class="line">  # 步骤3：exec 失败才会执行此处（成功则新程序覆盖，不会到这）</span><br><span class="line">  li a7, SYS_exit   # 若 exec 返回-1，调用 exit 退出</span><br><span class="line">  ecall</span><br><span class="line"></span><br><span class="line"># 数据段：exec 的参数</span><br><span class="line">init:  .string &quot;/init&quot;   # 程序路径字符串</span><br><span class="line">argv:  .quad init        # argv[0] = &quot;/init&quot;</span><br><span class="line">       .quad 0           # argv[1] = NULL（参数数组结束标志）</span><br></pre></td></tr></table></figure>
<p><strong>核心操作</strong>：</p>
<ul>
<li>严格遵循 RISC-V 约定：<code>a0/a1</code> 传参数，<code>a7</code> 传系统调用号；</li>
<li><code>ecall</code> 是用户态→内核态的“门”：触发 RISC-V 硬件陷阱逻辑。</li>
</ul>
<h3 id="2-场景2：C-库封装调用（普通用户程序）"><a href="#2-场景2：C-库封装调用（普通用户程序）" class="headerlink" title="2. 场景2：C 库封装调用（普通用户程序）"></a>2. 场景2：C 库封装调用（普通用户程序）</h3><p>普通用户程序会通过 C 函数 <code>exec(char *path, char **argv)</code> 调用，底层封装为汇编存根（类似 <code>syscall.S</code>），核心逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：用户态 C 封装的 exec 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="comment">// 汇编存根：将参数放入 a0/a1，调用号放入 a7，执行 ecall</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;li a7, %1\n&quot;</span>    <span class="comment">// a7 = SYS_exec</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;ecall\n&quot;</span>        <span class="comment">// 陷入内核</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=r&quot;</span>(a0)       <span class="comment">// 返回值存在 a0</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;i&quot;</span>(SYS_exec), <span class="string">&quot;r&quot;</span>(path), <span class="string">&quot;r&quot;</span>(argv)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a7&quot;</span></span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)a0; <span class="comment">// 返回内核写入的错误码（成功则不会执行到这）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心作用</strong>：为上层 C 代码提供抽象，隐藏汇编和寄存器操作细节。</p>
<h2 id="三、阶段2：用户态→内核态（陷阱触发与处理）"><a href="#三、阶段2：用户态→内核态（陷阱触发与处理）" class="headerlink" title="三、阶段2：用户态→内核态（陷阱触发与处理）"></a>三、阶段2：用户态→内核态（陷阱触发与处理）</h2><p><code>ecall</code> 执行后，CPU 触发硬件陷阱，进入内核通用陷阱处理流程，最终分发到 <code>sys_exec</code>。</p>
<h3 id="步骤1：RISC-V-硬件自动操作（无代码，CPU-原子执行）"><a href="#步骤1：RISC-V-硬件自动操作（无代码，CPU-原子执行）" class="headerlink" title="步骤1：RISC-V 硬件自动操作（无代码，CPU 原子执行）"></a>步骤1：RISC-V 硬件自动操作（无代码，CPU 原子执行）</h3><table>
<thead>
<tr>
<th>硬件操作</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>切特权级到 S 模式</td>
<td>进入内核权限，禁止用户态直接操作硬件&#x2F;内核内存。</td>
</tr>
<tr>
<td>保存当前 PC 到 <code>sepc</code></td>
<td>记录陷阱发生位置（exec 的 <code>ecall</code> 指令地址），用于返回时恢复。</td>
</tr>
<tr>
<td>设置 <code>scause=8</code></td>
<td>标记陷阱类型为“用户态系统调用（ecall）”。</td>
</tr>
<tr>
<td>清空 <code>sstatus.SIE</code></td>
<td>禁用中断，避免陷阱嵌套。</td>
</tr>
<tr>
<td>跳转到 <code>stvec</code> 指向的 <code>uservec</code></td>
<td>进入内核预定义的陷阱入口（蹦床页的 <code>uservec</code> 汇编代码）。</td>
</tr>
</tbody></table>
<h3 id="步骤2：uservec-汇编处理（trampoline-S）"><a href="#步骤2：uservec-汇编处理（trampoline-S）" class="headerlink" title="步骤2：uservec 汇编处理（trampoline.S）"></a>步骤2：uservec 汇编处理（trampoline.S）</h3><p><code>uservec</code> 是用户态陷阱的第一个内核入口，核心任务是「保存用户寄存器 + 切换到内核页表」：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># kernel/trampoline.S: uservec 核心逻辑</span><br><span class="line">uservec:</span><br><span class="line">  # 1. 交换 a0 和 sscratch：解锁 a0 寄存器，锚定 trapframe 地址</span><br><span class="line">  csrrw a0, sscratch, a0  # a0 = 原sscratch（TRAPFRAME地址）；sscratch = 原a0（exec的path参数）</span><br><span class="line">  </span><br><span class="line">  # 2. 保存所有用户寄存器到 trapframe（包括 a0/a1/a7）</span><br><span class="line">  sd ra, 0(a0)            # 保存 ra 寄存器</span><br><span class="line">  sd sp, 8(a0)            # 保存用户栈 sp</span><br><span class="line">  sd gp, 16(a0)           # 保存 gp 寄存器</span><br><span class="line">  ...                     # 保存 t0-t6、s0-s11 等寄存器</span><br><span class="line">  csrr a1, sscratch       # 取回用户态 a0（path参数）</span><br><span class="line">  sd a1, 68(a0)           # 保存到 trapframe-&gt;a0</span><br><span class="line">  sd a1, 72(a0)           # 保存 a1（argv参数）到 trapframe-&gt;a1</span><br><span class="line">  sd a7, 128(a0)          # 保存 a7（SYS_exec）到 trapframe-&gt;a7</span><br><span class="line">  </span><br><span class="line">  # 3. 切换到内核页表</span><br><span class="line">  ld t0, (TRAPFRAME + kernel_satp)(a0)  # 读取内核页表 satp</span><br><span class="line">  csrw satp, t0                         # 切换页表</span><br><span class="line">  sfence.vma                            # 刷新 TLB</span><br><span class="line">  </span><br><span class="line">  # 4. 切换到内核栈，跳转到 usertrap C 函数</span><br><span class="line">  ld sp, (TRAPFRAME + kernel_sp)(a0)    # sp = 进程内核栈地址</span><br><span class="line">  ld t1, (TRAPFRAME + usertrap)(a0)     # t1 = usertrap 函数地址</span><br><span class="line">  jr t1                                 # 跳转到 usertrap</span><br></pre></td></tr></table></figure>
<p><strong>核心意义</strong>：</p>
<ul>
<li>所有用户寄存器（包括 <code>a0/a1/a7</code>）被保存到 <code>trapframe</code>（进程私有），内核后续可通过 <code>p-&gt;trapframe</code> 访问；</li>
<li>切换到内核页表后，内核才能访问自身代码&#x2F;数据（用户页表仅映射用户空间 + 蹦床页）。</li>
</ul>
<h3 id="步骤3：usertrap-C-处理（trap-c）"><a href="#步骤3：usertrap-C-处理（trap-c）" class="headerlink" title="步骤3：usertrap C 处理（trap.c）"></a>步骤3：usertrap C 处理（trap.c）</h3><p><code>usertrap</code> 是陷阱分发的核心，识别陷阱类型并调用 <code>syscall</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c: usertrap 核心逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 识别陷阱类型：系统调用（scause=8）</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;sepc += <span class="number">4</span>; <span class="comment">// 修正 sepc：跳过 ecall 指令（返回时执行下一条）</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 调用 syscall 分发系统调用</span></span><br><span class="line">  syscall();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 检查进程状态（exec 失败则继续，成功则已替换上下文）</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤4：syscall-分发（syscall-c）"><a href="#步骤4：syscall-分发（syscall-c）" class="headerlink" title="步骤4：syscall 分发（syscall.c）"></a>步骤4：syscall 分发（syscall.c）</h3><p><code>syscall</code> 函数读取 <code>trapframe</code> 中的系统调用号，索引 <code>syscalls</code> 数组调用 <code>sys_exec</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c: syscall 核心逻辑</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  [SYS_exec] sys_exec,  <span class="comment">// 系统调用号 11 对应 sys_exec 函数</span></span><br><span class="line">  <span class="comment">// ... 其他系统调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 syscallno = p-&gt;trapframe-&gt;a7; <span class="comment">// 读取 trapframe-&gt;a7（SYS_exec）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证系统调用号合法性</span></span><br><span class="line">  <span class="keyword">if</span>(syscallno &gt;= NELEM(syscalls) || syscalls[syscallno] == <span class="number">0</span>) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>; <span class="comment">// 无效调用，返回-1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 sys_exec，返回值写入 trapframe-&gt;a0</span></span><br><span class="line">  p-&gt;trapframe-&gt;a0 = (*syscalls[syscallno])();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、阶段3：内核态-sys-exec-核心操作（exec-c）"><a href="#四、阶段3：内核态-sys-exec-核心操作（exec-c）" class="headerlink" title="四、阶段3：内核态 sys_exec 核心操作（exec.c）"></a>四、阶段3：内核态 sys_exec 核心操作（exec.c）</h2><p><code>sys_exec</code> 是 <code>exec</code> 系统调用的内核实现，也是整个流程的核心，<strong>步骤多达10+</strong>，以下拆解关键环节：</p>
<h3 id="步骤1：参数解析与验证"><a href="#步骤1：参数解析与验证" class="headerlink" title="步骤1：参数解析与验证"></a>步骤1：参数解析与验证</h3><p>从 <code>trapframe</code> 读取用户态传入的 <code>path</code> 和 <code>argv</code>，并验证合法性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c: sys_exec 入口</span></span><br><span class="line">uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *path;</span><br><span class="line">  <span class="type">char</span> **argv;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 从 trapframe 读取参数（复制到内核空间，避免用户态篡改）</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, &amp;path) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// argstr：读取 a0（path）到内核缓冲区</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;argv) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// argaddr：读取 a1（argv）的地址</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 验证参数：path 非空、argv 是合法用户地址</span></span><br><span class="line">  <span class="keyword">if</span>(path == <span class="literal">NULL</span> || (uint64)argv &gt;= MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 执行核心加载逻辑</span></span><br><span class="line">  <span class="keyword">return</span> exec(path, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：打开可执行文件并验证-ELF-格式"><a href="#步骤2：打开可执行文件并验证-ELF-格式" class="headerlink" title="步骤2：打开可执行文件并验证 ELF 格式"></a>步骤2：打开可执行文件并验证 ELF 格式</h3><p><code>exec</code> 函数首先打开目标文件，检查是否为合法的 ELF 可执行文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c: exec 核心函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">int</span> fd, i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 打开可执行文件</span></span><br><span class="line">  <span class="keyword">if</span>((fd = sys_open(path, O_RDONLY)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  ip = filedup(fd); <span class="comment">// 获取文件 inode</span></span><br><span class="line">  sys_close(fd);    <span class="comment">// 关闭临时 fd</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 读取 ELF 头部，验证魔数（ELF 文件标识）</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf)) <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC) <span class="keyword">goto</span> bad; <span class="comment">// 魔数错误：不是 ELF 文件</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 后续步骤</span></span><br><span class="line">bad:</span><br><span class="line">  iput(ip); <span class="comment">// 释放 inode</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3：销毁旧进程的用户内存空间"><a href="#步骤3：销毁旧进程的用户内存空间" class="headerlink" title="步骤3：销毁旧进程的用户内存空间"></a>步骤3：销毁旧进程的用户内存空间</h3><p><code>exec</code> 需替换当前进程的内存，因此先释放旧页表和内存页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续 exec 函数</span></span><br><span class="line"><span class="comment">// 3. 释放旧用户页表和内存</span></span><br><span class="line"><span class="type">pagetable_t</span> old_pagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = proc_pagetable(p); <span class="comment">// 创建新空页表</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;pagetable == <span class="literal">NULL</span>) <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放旧页表（保留 trampoline 和 trapframe 映射）</span></span><br><span class="line">proc_freepagetable(old_pagetable, p-&gt;sz);</span><br><span class="line">p-&gt;sz = <span class="number">0</span>; <span class="comment">// 重置进程内存大小</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤4：加载-ELF-程序段到新页表"><a href="#步骤4：加载-ELF-程序段到新页表" class="headerlink" title="步骤4：加载 ELF 程序段到新页表"></a>步骤4：加载 ELF 程序段到新页表</h3><p>遍历 ELF 的程序段（<code>Program Header</code>），将代码段、数据段加载到新页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续 exec 函数</span></span><br><span class="line"><span class="comment">// 4. 遍历 ELF 程序段，加载到新页表</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; elf.phnum; i++) &#123;</span><br><span class="line">  <span class="comment">// 读取程序段头部</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, elf.phoff + i*<span class="keyword">sizeof</span>(ph), <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph)) <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD) <span class="keyword">continue</span>; <span class="comment">// 仅加载可执行段</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 为段分配物理页，映射到用户虚拟地址（ph.vaddr）</span></span><br><span class="line">  <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr) <span class="keyword">goto</span> bad; <span class="comment">// 地址溢出</span></span><br><span class="line">  <span class="keyword">if</span>(ph.vaddr + ph.memsz &gt; MAXVA) <span class="keyword">goto</span> bad;    <span class="comment">// 超出用户地址空间</span></span><br><span class="line">  <span class="keyword">if</span>(growproc(ph.memsz) &lt; <span class="number">0</span>) <span class="keyword">goto</span> bad;         <span class="comment">// 扩展进程内存大小</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 6. 从文件读取段内容到物理页（p_filesz 是实际数据大小，memsz 是总大小）</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)walkaddr(p-&gt;pagetable, ph.vaddr), ph.off, ph.filesz) != ph.filesz) <span class="keyword">goto</span> bad;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 7. 剩余空间清零（如 BSS 段）</span></span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span>*)walkaddr(p-&gt;pagetable, ph.vaddr + ph.filesz), <span class="number">0</span>, ph.memsz - ph.filesz);</span><br><span class="line">&#125;</span><br><span class="line">iput(ip); <span class="comment">// 释放文件 inode</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤5：设置新程序的栈并复制命令行参数"><a href="#步骤5：设置新程序的栈并复制命令行参数" class="headerlink" title="步骤5：设置新程序的栈并复制命令行参数"></a>步骤5：设置新程序的栈并复制命令行参数</h3><p>为新程序创建用户栈，将 <code>argv</code> 参数复制到栈中（符合 RISC-V 栈布局）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续 exec 函数</span></span><br><span class="line"><span class="comment">// 8. 分配栈空间（用户栈在高地址，大小为 PGSIZE）</span></span><br><span class="line"><span class="keyword">if</span>(growproc(PGSIZE) &lt; <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">p-&gt;sz += PGSIZE;</span><br><span class="line">uint64 sp = p-&gt;sz; <span class="comment">// 栈指针指向栈顶（RISC-V 栈向下生长）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 复制 argv 参数到栈中</span></span><br><span class="line"><span class="type">char</span> *argv_copy[ARG_MAX];</span><br><span class="line"><span class="type">int</span> argc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 先统计参数个数，复制参数字符串到栈</span></span><br><span class="line"><span class="keyword">while</span>(argc &lt; ARG_MAX) &#123;</span><br><span class="line">  uint64 argaddr;</span><br><span class="line">  <span class="keyword">if</span>(fetchaddr((uint64)argv + argc*<span class="number">8</span>, &amp;argaddr) &lt; <span class="number">0</span>) <span class="keyword">goto</span> bad; <span class="comment">// 读取 argv[argc] 地址</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 参数数组结束（NULL）</span></span><br><span class="line">  <span class="comment">// 复制参数字符串到栈</span></span><br><span class="line">  sp -= <span class="built_in">strlen</span>((<span class="type">char</span>*)argaddr) + <span class="number">1</span>;</span><br><span class="line">  sp -= sp % <span class="number">16</span>; <span class="comment">// 栈对齐（RISC-V 要求 16 字节对齐）</span></span><br><span class="line">  <span class="keyword">if</span>(copyin(p-&gt;pagetable, sp, (<span class="type">char</span>*)argaddr, <span class="built_in">strlen</span>((<span class="type">char</span>*)argaddr) + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">  argv_copy[argc++] = (<span class="type">char</span>*)sp;</span><br><span class="line">&#125;</span><br><span class="line">argv_copy[argc] = <span class="number">0</span>; <span class="comment">// 参数数组末尾加 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 构建 argv 指针数组（栈底→栈顶：argc → argv[0] → argv[1] → ... → NULL → 字符串）</span></span><br><span class="line">sp -= (argc + <span class="number">1</span>) * <span class="number">8</span>; <span class="comment">// 为 argv 指针数组分配空间</span></span><br><span class="line">sp -= sp % <span class="number">16</span>;</span><br><span class="line">uint64 argv_ptr = sp;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc + <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, argv_ptr + i*<span class="number">8</span>, (<span class="type">char</span>*)&amp;argv_copy[i], <span class="number">8</span>) &lt; <span class="number">0</span>) <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 栈最终布局：sp 指向 argc，后续是 argv 指针数组</span></span><br><span class="line">sp -= <span class="number">8</span>;</span><br><span class="line">*(uint64*)sp = argc; <span class="comment">// 栈顶存 argc（符合 RISC-V _start 函数约定）</span></span><br></pre></td></tr></table></figure>

<h3 id="步骤6：重置进程上下文（关键！）"><a href="#步骤6：重置进程上下文（关键！）" class="headerlink" title="步骤6：重置进程上下文（关键！）"></a>步骤6：重置进程上下文（关键！）</h3><p>修改 <code>trapframe</code>，让返回用户态时执行新程序的入口（<code>elf.entry</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续 exec 函数</span></span><br><span class="line"><span class="comment">// 12. 重置 trapframe：替换为新程序的上下文</span></span><br><span class="line">p-&gt;trapframe-&gt;a0 = argc;    <span class="comment">// _start 函数第一个参数：argc</span></span><br><span class="line">p-&gt;trapframe-&gt;a1 = argv_ptr;<span class="comment">// _start 函数第二个参数：argv</span></span><br><span class="line">p-&gt;trapframe-&gt;sepc = elf.entry; <span class="comment">// 新程序入口地址（ELF 头的 entry 字段）</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp;      <span class="comment">// 新程序的栈指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 13. 成功：返回 0（但用户态不会收到，因为上下文已替换）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="五、阶段4：返回用户态（成功-失败的不同处理）"><a href="#五、阶段4：返回用户态（成功-失败的不同处理）" class="headerlink" title="五、阶段4：返回用户态（成功&#x2F;失败的不同处理）"></a>五、阶段4：返回用户态（成功&#x2F;失败的不同处理）</h2><p><code>sys_exec</code> 执行完成后，内核通过 <code>usertrapret + userret</code> 切回用户态，分两种情况：</p>
<h3 id="1-失败场景（如文件不存在、非-ELF-文件）"><a href="#1-失败场景（如文件不存在、非-ELF-文件）" class="headerlink" title="1. 失败场景（如文件不存在、非 ELF 文件）"></a>1. 失败场景（如文件不存在、非 ELF 文件）</h3><ul>
<li><code>sys_exec</code> 返回 <code>-1</code>，<code>syscall</code> 将 <code>-1</code> 写入 <code>p-&gt;trapframe-&gt;a0</code>；</li>
<li><code>usertrapret</code> 重置 <code>stvec</code> 为 <code>uservec</code>，恢复 <code>sepc</code> 为原 <code>ecall</code> 地址 + 4；</li>
<li><code>userret</code> 汇编切换回用户页表，恢复所有寄存器（<code>a0=-1</code>）；</li>
<li><code>sret</code> 切回用户态，原程序（如 initcode.S）拿到 <code>-1</code>，执行后续的 <code>exit</code> 系统调用。</li>
</ul>
<h3 id="2-成功场景（核心！）"><a href="#2-成功场景（核心！）" class="headerlink" title="2. 成功场景（核心！）"></a>2. 成功场景（核心！）</h3><ul>
<li><code>sys_exec</code> 返回 <code>0</code>，但已修改 <code>trapframe</code>：<ul>
<li><code>sepc = elf.entry</code>（新程序入口地址，如 <code>_start</code>）；</li>
<li><code>sp = 新程序栈指针</code>；</li>
<li><code>a0 = argc</code>，<code>a1 = argv_ptr</code>（符合新程序 <code>_start</code> 函数的参数约定）；</li>
</ul>
</li>
<li><code>userret</code> 恢复寄存器时，直接加载新的 <code>sepc</code> 和 <code>sp</code>；</li>
<li><code>sret</code> 切回用户态后，CPU 从 <code>elf.entry</code> 执行新程序（如 <code>/init</code>），原 initcode.S 的代码永远不会执行。</li>
</ul>
<h2 id="六、核心总结：exec-调用全链路"><a href="#六、核心总结：exec-调用全链路" class="headerlink" title="六、核心总结：exec 调用全链路"></a>六、核心总结：exec 调用全链路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用户态                | 内核态</span><br><span class="line">----------------------|----------------------</span><br><span class="line">1. 准备参数（a0/a1/a7）| 1. 硬件陷阱（切S模式、跳uservec）</span><br><span class="line">2. 执行 ecall          | 2. uservec：保存寄存器→切换内核页表</span><br><span class="line">                      | 3. usertrap：识别系统调用→调用syscall</span><br><span class="line">                      | 4. syscall：分发到sys_exec</span><br><span class="line">                      | 5. sys_exec：</span><br><span class="line">                      |    - 解析参数→打开文件→验证ELF</span><br><span class="line">                      |    - 销毁旧页表→加载ELF段→创建新栈</span><br><span class="line">                      |    - 重置trapframe（新程序入口/栈）</span><br><span class="line">3. （成功）执行新程序  | 6. usertrapret+userret：切回用户态</span><br><span class="line">4. （失败）拿到错误码  |</span><br></pre></td></tr></table></figure>

<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ol>
<li><strong>上下文替换</strong>：exec 成功后，进程的 PID、内核栈、文件描述符不变，仅用户内存和执行上下文被替换；</li>
<li><strong>无返回特性</strong>：成功的 exec 不会回到原程序，因为 <code>sepc</code> 已被修改为新程序入口；</li>
<li><strong>隔离性</strong>：新程序的页表仅映射自身代码&#x2F;数据 + 蹦床页 + 陷阱帧，无法访问内核内存；</li>
<li><strong>兼容性</strong>：严格遵循 RISC-V 调用约定，新程序的 <code>_start</code> 函数可直接读取 <code>a0(argc)</code> 和 <code>a1(argv)</code>。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E9%99%B7%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0/%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E9%99%B7%E5%85%A5/" class="post-title-link" itemprop="url">从用户空间陷入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-28 21:05:10" itemprop="dateCreated datePublished" datetime="2025-12-28T21:05:10+08:00">2025-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-29 19:21:22" itemprop="dateModified" datetime="2025-12-29T19:21:22+08:00">2025-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="从用户空间陷入（陷阱）：xv6-完整流程解析"><a href="#从用户空间陷入（陷阱）：xv6-完整流程解析" class="headerlink" title="从用户空间陷入（陷阱）：xv6 完整流程解析"></a>从用户空间陷入（陷阱）：xv6 完整流程解析</h3><p>用户空间触发陷阱（系统调用&#x2F;异常&#x2F;设备中断）是 xv6 陷阱处理中最复杂的场景，核心挑战是：<strong>用户页表不映射内核、栈指针可能非法、硬件不自动切换页表</strong>。xv6 通过「蹦床页（trampoline）+ 陷阱帧（trapframe）+ 分层处理（汇编→C→汇编）」解决这些问题，以下是全流程的逐阶段拆解：</p>
<h4 id="一、陷阱触发前的前置准备（内核初始化-进程创建）"><a href="#一、陷阱触发前的前置准备（内核初始化-进程创建）" class="headerlink" title="一、陷阱触发前的前置准备（内核初始化&#x2F;进程创建）"></a>一、陷阱触发前的前置准备（内核初始化&#x2F;进程创建）</h4><p>为了让用户态陷阱能安全进入内核，xv6 提前完成 3 个关键配置：</p>
<h5 id="1-蹦床页（trampoline-page）的映射"><a href="#1-蹦床页（trampoline-page）的映射" class="headerlink" title="1. 蹦床页（trampoline page）的映射"></a>1. 蹦床页（trampoline page）的映射</h5><ul>
<li><strong>核心问题</strong>：RISC-V 硬件触发陷阱时不切换页表，<code>stvec</code> 指向的 <code>uservec</code> 汇编代码必须在<strong>用户页表中可访问</strong>；但 <code>uservec</code> 又需要切换到内核页表，因此 <code>uservec</code> 所在的蹦床页必须同时映射到「用户页表 + 内核页表」的<strong>相同虚拟地址（TRAMPOLINE）</strong>。</li>
<li><strong>实现</strong>：<ul>
<li>蹦床页的内容是 <code>trampoline.S</code> 中的 <code>uservec</code>&#x2F;<code>userret</code> 汇编代码，编译后固定在 TRAMPOLINE 地址；</li>
<li>内核页表：将蹦床页的物理地址映射到 TRAMPOLINE 虚拟地址（只读、S 模式）；</li>
<li>每个用户进程页表：同样将蹦床页的物理地址映射到 TRAMPOLINE 虚拟地址（只读、U 模式可执行）。</li>
</ul>
</li>
</ul>
<h5 id="2-陷阱帧（trapframe）的分配与映射"><a href="#2-陷阱帧（trapframe）的分配与映射" class="headerlink" title="2. 陷阱帧（trapframe）的分配与映射"></a>2. 陷阱帧（trapframe）的分配与映射</h5><ul>
<li><strong>核心问题</strong>：<code>uservec</code> 需要保存用户寄存器，但此时仍在用户页表下，必须让陷阱帧在用户地址空间可访问。</li>
<li><strong>实现</strong>：<ul>
<li>每个进程创建时（<code>allocproc()</code>），内核分配一页物理内存作为该进程的 <code>trapframe</code>（结构体见前文），用于保存用户寄存器、内核栈指针、hartid、内核页表地址等；</li>
<li>该陷阱帧被映射到用户页表的 <code>TRAPFRAME</code> 虚拟地址（紧邻 TRAMPOLINE 下方），同时内核页表通过 <code>p-&gt;trapframe</code> 直接访问该物理页（无需虚拟地址映射）；</li>
<li>内核将 <code>sscratch</code> 寄存器设置为 <code>TRAPFRAME</code> 地址（用户态运行时），作为 <code>uservec</code> 切换栈&#x2F;保存寄存器的锚点。</li>
</ul>
</li>
</ul>
<h5 id="3-stvec-寄存器初始化"><a href="#3-stvec-寄存器初始化" class="headerlink" title="3. stvec 寄存器初始化"></a>3. stvec 寄存器初始化</h5><p>内核在进程切换到用户态前（<code>usertrapret()</code>），将 <code>stvec</code> 设置为 <code>uservec</code> 的地址（TRAMPOLINE + 偏移），确保用户态陷阱触发时，CPU 跳转到 <code>uservec</code>。</p>
<h4 id="二、陷阱触发：uservec-汇编处理（trampoline-S）"><a href="#二、陷阱触发：uservec-汇编处理（trampoline-S）" class="headerlink" title="二、陷阱触发：uservec 汇编处理（trampoline.S）"></a>二、陷阱触发：uservec 汇编处理（trampoline.S）</h4><p>用户态执行 <code>ecall</code>&#x2F;触发异常&#x2F;设备中断时，CPU 硬件完成基础操作（切 S 模式、保存 sepc&#x2F;scause、跳 stvec）后，进入 <code>uservec</code> 汇编代码，核心任务是「安全保存用户寄存器 + 切换到内核页表」。</p>
<h5 id="步骤-1：交换-a0-和-sscratch（解锁可用寄存器）"><a href="#步骤-1：交换-a0-和-sscratch（解锁可用寄存器）" class="headerlink" title="步骤 1：交换 a0 和 sscratch（解锁可用寄存器）"></a>步骤 1：交换 a0 和 sscratch（解锁可用寄存器）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># uservec 入口第一步</span><br><span class="line">csrrw a0, sscratch, a0  # 原子交换：</span><br><span class="line">                        # a0 = 原sscratch（TRAPFRAME 地址）</span><br><span class="line">                        # sscratch = 原a0（用户态的a0值，先暂存）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>为什么要交换</strong>：此时所有 32 个通用寄存器都持有用户态的值，<code>uservec</code> 不能直接修改任何寄存器（否则会覆盖用户数据）；通过 <code>csrrw</code> 交换 <code>a0</code> 和 <code>sscratch</code>，既保存了用户的 <code>a0</code>，又让 <code>a0</code> 指向陷阱帧（TRAPFRAME），成为 <code>uservec</code> 可安全使用的第一个寄存器。</li>
</ul>
<h5 id="步骤-2：保存所有用户寄存器到陷阱帧"><a href="#步骤-2：保存所有用户寄存器到陷阱帧" class="headerlink" title="步骤 2：保存所有用户寄存器到陷阱帧"></a>步骤 2：保存所有用户寄存器到陷阱帧</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># a0 现在指向 TRAPFRAME，逐个保存用户寄存器</span><br><span class="line">sd ra, 0(a0)            # ra → trapframe.ra</span><br><span class="line">sd sp, 8(a0)            # 用户栈sp → trapframe.sp</span><br><span class="line">sd gp, 16(a0)           # gp → trapframe.gp</span><br><span class="line">...                     # 保存所有通用寄存器（a1-a7、s0-s11、t0-t6等）</span><br><span class="line">sd a0, 72(a0)           # 恢复用户a0：从sscratch读取原a0值，写入trapframe.a0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键</strong>：此时仍在用户页表下，但 TRAPFRAME 已映射到用户地址空间，因此能直接写入陷阱帧；所有用户寄存器保存完成后，用户态上下文被完整兜底。</li>
</ul>
<h5 id="步骤-3：切换到内核页表并调用-usertrap"><a href="#步骤-3：切换到内核页表并调用-usertrap" class="headerlink" title="步骤 3：切换到内核页表并调用 usertrap"></a>步骤 3：切换到内核页表并调用 usertrap</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 从陷阱帧读取内核页表地址（satp）、内核栈地址、usertrap 地址</span><br><span class="line">ld t0, (TRAPFRAME + kernel_satp)(a0)  # t0 = 内核页表的satp值</span><br><span class="line">ld sp, (TRAPFRAME + kernel_sp)(a0)    # sp = 进程的内核栈地址</span><br><span class="line">ld t1, (TRAPFRAME + usertrap)(a0)     # t1 = usertrap() 函数地址</span><br><span class="line"></span><br><span class="line"># 切换到内核页表（satp = t0）</span><br><span class="line">csrw satp, t0</span><br><span class="line">sfence.vma                           # 刷新TLB，确保页表切换生效</span><br><span class="line"></span><br><span class="line"># 跳转到 usertrap()（内核栈已就绪，页表已切换）</span><br><span class="line">jr t1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>核心逻辑</strong>：陷阱帧中提前存储了内核页表的 <code>satp</code> 值（内核初始化时写入），切换 <code>satp</code> 后，CPU 才能访问内核的所有虚拟地址；切换内核栈（<code>sp</code>）后，C 函数 <code>usertrap()</code> 可安全执行。</li>
</ul>
<h4 id="三、陷阱处理：usertrap-C-逻辑（trap-c）"><a href="#三、陷阱处理：usertrap-C-逻辑（trap-c）" class="headerlink" title="三、陷阱处理：usertrap C 逻辑（trap.c）"></a>三、陷阱处理：usertrap C 逻辑（trap.c）</h4><p><code>usertrap()</code> 是用户态陷阱的核心分发器，负责判断陷阱类型并处理，核心流程：</p>
<h5 id="步骤-1：重设-stvec（避免内核态陷阱走-uservec）"><a href="#步骤-1：重设-stvec（避免内核态陷阱走-uservec）" class="headerlink" title="步骤 1：重设 stvec（避免内核态陷阱走 uservec）"></a>步骤 1：重设 stvec（避免内核态陷阱走 uservec）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w_stvec((uint64)kernelvec); <span class="comment">// 内核态陷阱改由 kernelvec 处理</span></span><br></pre></td></tr></table></figure>

<h5 id="步骤-2：保存-sepc（防止进程切换覆盖）"><a href="#步骤-2：保存-sepc（防止进程切换覆盖）" class="headerlink" title="步骤 2：保存 sepc（防止进程切换覆盖）"></a>步骤 2：保存 sepc（防止进程切换覆盖）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">p-&gt;trapframe-&gt;sepc = r_sepc(); <span class="comment">// 保存陷阱发生时的用户PC</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原因</strong>：若陷阱是定时器中断，内核可能触发进程切换，<code>sepc</code> 是 CPU 寄存器，切换进程后会被覆盖，因此需保存到陷阱帧。</li>
</ul>
<h5 id="步骤-3：分类型处理陷阱"><a href="#步骤-3：分类型处理陷阱" class="headerlink" title="步骤 3：分类型处理陷阱"></a>步骤 3：分类型处理陷阱</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((r_scause() &amp; <span class="number">0x8000000000000000L</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// 情况1：设备中断（最高位为1）</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">0x8000000000000005L</span>) timerintr(); <span class="comment">// 定时器中断</span></span><br><span class="line">  w_sip(r_sip() &amp; ~<span class="number">2</span>); <span class="comment">// 清除中断标记</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 情况2：异常/系统调用（最高位为0）</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 系统调用（ecall触发，scause=8）</span></span><br><span class="line">    p-&gt;trapframe-&gt;sepc += <span class="number">4</span>; <span class="comment">// 跳过ecall指令（返回后执行下一条）</span></span><br><span class="line">    uint64 syscallno = p-&gt;trapframe-&gt;a7; <span class="comment">// 读取系统调用号（a7寄存器）</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscall(syscallno); <span class="comment">// 执行sys_*函数，结果存a0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常（除零、无效地址等）：终止进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user trap %p pid=%d\n&quot;</span>, r_sepc(), p-&gt;pid);</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-4：检查进程状态（是否终止-需要调度）"><a href="#步骤-4：检查进程状态（是否终止-需要调度）" class="headerlink" title="步骤 4：检查进程状态（是否终止&#x2F;需要调度）"></a>步骤 4：检查进程状态（是否终止&#x2F;需要调度）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;killed) <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">// 异常导致进程被杀死，直接退出</span></span><br><span class="line"><span class="keyword">if</span>(which_dev() == <span class="number">2</span>) yield(); <span class="comment">// 定时器中断，触发进程调度</span></span><br></pre></td></tr></table></figure>

<h4 id="四、返回用户态：usertrapret-userret"><a href="#四、返回用户态：usertrapret-userret" class="headerlink" title="四、返回用户态：usertrapret + userret"></a>四、返回用户态：usertrapret + userret</h4><p>陷阱处理完成后，内核需要切回用户态，分为「C 层准备（usertrapret）」和「汇编层切换（userret）」两步：</p>
<h5 id="步骤-1：usertrapret-准备返回环境（trap-c）"><a href="#步骤-1：usertrapret-准备返回环境（trap-c）" class="headerlink" title="步骤 1：usertrapret 准备返回环境（trap.c）"></a>步骤 1：usertrapret 准备返回环境（trap.c）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// 1. 重置 stvec 为 uservec（为下次用户态陷阱做准备）</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 恢复 sepc 为保存的用户PC（陷阱发生时的地址/ecall下一条）</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;sepc);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 配置 sstatus：SPP=0（返回U模式）、SIE=1（启用中断）</span></span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  sstatus &amp;= ~SSTATUS_SPP; <span class="comment">// 清除SPP，标记返回用户态</span></span><br><span class="line">  sstatus |= SSTATUS_SPIE; <span class="comment">// 恢复中断使能</span></span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 跳转到 userret（蹦床页，需传用户页表和TRAPFRAME地址）</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64, uint64))fn)(p-&gt;pagetable, TRAPFRAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤-2：userret-汇编切回用户态（trampoline-S）"><a href="#步骤-2：userret-汇编切回用户态（trampoline-S）" class="headerlink" title="步骤 2：userret 汇编切回用户态（trampoline.S）"></a>步骤 2：userret 汇编切回用户态（trampoline.S）</h5><p><code>userret</code> 接收两个参数：<code>a0=用户页表satp</code>、<code>a1=TRAPFRAME地址</code>，核心逻辑是「切换回用户页表 + 恢复用户寄存器 + sret 返回」：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">  # 步骤1：切换到用户页表</span><br><span class="line">  csrw satp, a0         # satp = 用户页表的satp值</span><br><span class="line">  sfence.vma           # 刷新TLB</span><br><span class="line">  mv a0, a1            # a0 = TRAPFRAME地址</span><br><span class="line">  </span><br><span class="line">  # 步骤2：准备sscratch（恢复为TRAPFRAME，为下次陷阱做准备）</span><br><span class="line">  csrr t0, sscratch    # 暂存当前sscratch</span><br><span class="line">  csrw sscratch, a0    # sscratch = TRAPFRAME</span><br><span class="line">  </span><br><span class="line">  # 步骤3：从陷阱帧恢复所有用户寄存器</span><br><span class="line">  ld ra, 0(a0)         # 恢复ra</span><br><span class="line">  ld sp, 8(a0)         # 恢复用户栈sp</span><br><span class="line">  ld gp, 16(a0)        # 恢复gp</span><br><span class="line">  ...                  # 恢复所有通用寄存器</span><br><span class="line">  ld a0, 72(a0)        # 恢复用户a0</span><br><span class="line">  </span><br><span class="line">  # 步骤4：交换a0和sscratch（恢复用户a0，sscratch保留TRAPFRAME）</span><br><span class="line">  csrrw a0, sscratch, a0</span><br><span class="line">  </span><br><span class="line">  # 步骤5：sret 返回用户态（sepc恢复PC，特权级切回U模式）</span><br><span class="line">  sret</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>关键</strong>：切换回用户页表后，只有蹦床页和 TRAPFRAME 可访问，因此所有操作必须基于寄存器和陷阱帧；<code>sret</code> 指令会将 <code>sepc</code> 写回 PC，CPU 从陷阱发生的下一条指令继续执行。</li>
</ul>
<h4 id="五、核心设计要点总结"><a href="#五、核心设计要点总结" class="headerlink" title="五、核心设计要点总结"></a>五、核心设计要点总结</h4><table>
<thead>
<tr>
<th>设计点</th>
<th>解决的问题</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>蹦床页（TRAMPOLINE）</td>
<td>硬件不切换页表，uservec需跨页表执行</td>
<td>同一物理页映射到用户&#x2F;内核页表的相同虚拟地址</td>
</tr>
<tr>
<td>陷阱帧（TRAPFRAME）</td>
<td>用户页表下保存寄存器、传递内核信息</td>
<td>每个进程独有，映射到用户页表的TRAPFRAME地址</td>
</tr>
<tr>
<td>sscratch 交换 a0</td>
<td>无可用寄存器，避免覆盖用户数据</td>
<td>csrrw 原子交换，锚定TRAPFRAME地址</td>
</tr>
<tr>
<td>分层处理（汇编→C）</td>
<td>汇编处理底层切换，C处理逻辑分发</td>
<td>uservec（汇编）→ usertrap（C）→ userret（汇编）</td>
</tr>
</tbody></table>
<h4 id="六、关键疑问解答"><a href="#六、关键疑问解答" class="headerlink" title="六、关键疑问解答"></a>六、关键疑问解答</h4><ol>
<li><p><strong>为什么切换页表时需要 sfence.vma？</strong><br>TLB（快表）会缓存虚拟地址→物理地址的映射，切换页表后，TLB 中仍保留旧页表的缓存，<code>sfence.vma</code> 会清空 TLB，确保新页表的映射生效。</p>
</li>
<li><p><strong>为什么 sepc 要 +4？</strong><br>用户态执行 <code>ecall</code> 触发系统调用时，CPU 将 <code>ecall</code> 指令的地址写入 <code>sepc</code>；但 <code>ecall</code> 执行后，用户程序应从下一条指令继续（<code>ecall</code> 占 4 字节），因此需将 <code>sepc</code> 加 4。</p>
</li>
<li><p><strong>为什么陷阱帧要映射到用户页表？</strong><br><code>uservec</code> 执行初期仍在用户页表下（未切换 satp），若陷阱帧仅在内核页表映射，<code>uservec</code> 无法访问，因此必须临时映射到用户地址空间（TRAPFRAME），且该地址仅进程自身可访问，无安全风险。</p>
</li>
</ol>
<h3 id="最终流程闭环"><a href="#最终流程闭环" class="headerlink" title="最终流程闭环"></a>最终流程闭环</h3><p>用户态陷阱的完整链路：<br><code>用户指令触发陷阱</code> → CPU硬件切S模式跳uservec → uservec保存寄存器+切内核页表 → usertrap分发处理（系统调用&#x2F;中断&#x2F;异常） → usertrapret准备返回环境 → userret切回用户页表+恢复寄存器 → sret返回用户态继续执行。</p>
<p>这个流程的核心是「利用蹦床页跨页表执行、利用陷阱帧保存上下文、利用硬件控制寄存器保证特权级隔离」，既解决了用户&#x2F;内核的隔离性问题，又保证了陷阱处理的性能和灵活性。</p>
<hr>
<h3 id="核心结论"><a href="#核心结论" class="headerlink" title="核心结论"></a>核心结论</h3><p>在 xv6 的 RISC-V 实现中，<strong>用户态陷阱入口 <code>uservec</code> 里实际交换的是 <code>a0</code> 和 <code>sscratch</code></strong>；而“<code>sp</code> 与 <code>sscratch</code> 交换”是 RISC-V 陷阱切换栈的<strong>通用架构思路</strong>（文档&#x2F;教程常举的示例），但 xv6 为了更安全的寄存器管理，选择了 <code>a0</code> 而非 <code>sp</code>——这是你产生混淆的核心原因。</p>
<h3 id="一、误解来源：通用思路-vs-xv6-实际实现"><a href="#一、误解来源：通用思路-vs-xv6-实际实现" class="headerlink" title="一、误解来源：通用思路 vs xv6 实际实现"></a>一、误解来源：通用思路 vs xv6 实际实现</h3><h4 id="1-RISC-V-架构的“通用建议”：交换-sp-和-sscratch"><a href="#1-RISC-V-架构的“通用建议”：交换-sp-和-sscratch" class="headerlink" title="1. RISC-V 架构的“通用建议”：交换 sp 和 sscratch"></a>1. RISC-V 架构的“通用建议”：交换 sp 和 sscratch</h4><p>RISC-V 官方文档&#x2F;入门教程中，陷阱切换栈的典型思路是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通用示例（非xv6）：交换sp和sscratch，直接切换到内核栈</span><br><span class="line">csrrw sp, sscratch, sp  # sp = 原sscratch（内核栈/trapframe地址），sscratch = 原sp（用户栈）</span><br></pre></td></tr></table></figure>
<p>这个思路的核心是「用 sscratch 锚定内核栈地址，一条指令完成栈切换」，逻辑简洁，但有个前提：<strong>切换 sp 前无需保存其他寄存器</strong>（或仅需保存少量）。</p>
<h4 id="2-xv6-的实际选择：交换-a0-和-sscratch"><a href="#2-xv6-的实际选择：交换-a0-和-sscratch" class="headerlink" title="2. xv6 的实际选择：交换 a0 和 sscratch"></a>2. xv6 的实际选择：交换 a0 和 sscratch</h4><p>xv6 中 <code>uservec</code>（trampoline.S）的真实代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># kernel/trampoline.S: uservec 入口（xv6 RISC-V 原版）</span><br><span class="line">uservec:</span><br><span class="line">  # 交换 a0 和 sscratch：解锁第一个可用寄存器，锚定 trapframe 地址</span><br><span class="line">  csrrw a0, sscratch, a0  # a0 = 原sscratch (TRAPFRAME地址)；sscratch = 原a0 (用户态a0值)</span><br><span class="line">  </span><br><span class="line">  # 保存所有用户寄存器到 trapframe（此时a0指向TRAPFRAME，用户页表可访问）</span><br><span class="line">  sd ra, 0(a0)</span><br><span class="line">  sd sp, 8(a0)   # 保存用户态的sp（此时sp仍指向用户栈）</span><br><span class="line">  sd gp, 16(a0)</span><br><span class="line">  sd tp, 24(a0)</span><br><span class="line">  sd t0, 32(a0)</span><br><span class="line">  sd t1, 40(a0)</span><br><span class="line">  sd t2, 48(a0)</span><br><span class="line">  sd s0, 56(a0)</span><br><span class="line">  sd s1, 64(a0)</span><br><span class="line">  sd a1, 72(a0)  # 注意：a0已经被交换，所以先存a1，最后恢复用户a0</span><br><span class="line">  sd a2, 80(a0)</span><br><span class="line">  # ... 省略其他寄存器（a3-a7、s2-s11、t3-t6等）</span><br><span class="line">  csrr a1, sscratch       # 从sscratch取回用户态的a0值</span><br><span class="line">  sd a1, 68(a0)           # 保存用户态a0到trapframe.a0</span><br><span class="line">  </span><br><span class="line">  # 后续：切换内核页表、跳转到usertrap...</span><br></pre></td></tr></table></figure>

<h3 id="二、xv6-选择-a0-而非-sp-的核心原因"><a href="#二、xv6-选择-a0-而非-sp-的核心原因" class="headerlink" title="二、xv6 选择 a0 而非 sp 的核心原因"></a>二、xv6 选择 a0 而非 sp 的核心原因</h3><p>陷阱触发后，CPU 刚跳转到 <code>uservec</code> 时，<strong>所有 32 个通用寄存器都持有用户态的值</strong>，且此时仍在「用户页表」上下文（未切换到内核页表）。xv6 选择 a0 交换的关键考量是：</p>
<ol>
<li><p><strong>避免过早修改 sp 导致寄存器保存失败</strong><br>若先交换 sp（用户栈→trapframe），此时 sp 指向 trapframe，但还未保存任何用户寄存器（包括原 sp），后续保存 <code>sd sp, 8(a0)</code> 时，写入的是「已切换后的 sp（trapframe 地址）」，而非用户态的 sp——会导致用户栈地址丢失。</p>
<p>而先交换 a0：</p>
<ul>
<li>sp 仍指向用户栈，可先把「用户态 sp」保存到 trapframe；</li>
<li>a0 被解锁为「可用寄存器」（指向 trapframe），后续所有寄存器保存操作都基于 a0 完成，无冲突。</li>
</ul>
</li>
<li><p><strong>trapframe 需先保存全量寄存器，再切换栈&#x2F;页表</strong><br>xv6 的 trapframe 要保存所有用户寄存器（而非仅 sp），且保存操作必须在「用户页表」下完成（因为还未切换到内核页表）。先拿 a0 锚定 trapframe 地址，才能安全完成全量寄存器保存，再执行后续的「切换内核栈（sp）」和「切换内核页表（satp）」。</p>
</li>
</ol>
<h3 id="三、关键补充：sp-的切换时机（在-a0-交换之后）"><a href="#三、关键补充：sp-的切换时机（在-a0-交换之后）" class="headerlink" title="三、关键补充：sp 的切换时机（在 a0 交换之后）"></a>三、关键补充：sp 的切换时机（在 a0 交换之后）</h3><p>xv6 并非不切换 sp，而是<strong>把 sp 切换延后到“保存完所有用户寄存器、切换到内核页表之后”</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># uservec 中保存完寄存器后，切换到内核栈</span><br><span class="line">ld sp, (TRAPFRAME + kernel_sp)(a0)  # sp = 进程的内核栈地址（从trapframe读取）</span><br><span class="line">csrw satp, t0                       # 切换到内核页表</span><br><span class="line">sfence.vma</span><br><span class="line">jr t1                               # 跳转到usertrap（此时sp已为内核栈）</span><br></pre></td></tr></table></figure>
<p>此时切换 sp 是安全的：用户寄存器已全部保存到 trapframe，且已切换到内核页表，内核栈地址（trapframe.kernel_sp）是内核可访问的。</p>
<h3 id="四、总结：两种交换的核心目的一致，仅时机-寄存器选择不同"><a href="#四、总结：两种交换的核心目的一致，仅时机-寄存器选择不同" class="headerlink" title="四、总结：两种交换的核心目的一致，仅时机&#x2F;寄存器选择不同"></a>四、总结：两种交换的核心目的一致，仅时机&#x2F;寄存器选择不同</h3><table>
<thead>
<tr>
<th>对比维度</th>
<th>通用思路（sp交换）</th>
<th>xv6 实现（a0交换）</th>
</tr>
</thead>
<tbody><tr>
<td>核心目的</td>
<td>用 sscratch 锚定内核地址，切换栈</td>
<td>用 sscratch 锚定 trapframe 地址，解锁寄存器</td>
</tr>
<tr>
<td>交换时机</td>
<td>陷阱入口第一步</td>
<td>陷阱入口第一步（先解锁寄存器）</td>
</tr>
<tr>
<td>sp 切换时机</td>
<td>与 sscratch 交换时同步完成</td>
<td>保存完所有寄存器、切换页表后</td>
</tr>
<tr>
<td>适用场景</td>
<td>极简陷阱处理（仅切换栈）</td>
<td>全量寄存器保存+跨页表切换</td>
</tr>
</tbody></table>
<p>简单来说：</p>
<ul>
<li>你之前看到的“sp 和 sscratch 交换”是<strong>架构级通用示例</strong>；</li>
<li>xv6 实际执行的是“a0 和 sscratch 交换”，是针对「全量寄存器保存+用户&#x2F;内核页表切换」场景的优化，本质都是利用 <code>sscratch</code> 作为“内核侧锚点”，只是选择了不同的临时寄存器。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hellonnnnn.github.io/2025/12/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0/RISC-V%E9%99%B7%E5%85%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ivan-FYF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ivan's Tech Blog">
      <meta itemprop="description" content="记录 C++、Linux、系统方向学习与项目">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Ivan's Tech Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0/RISC-V%E9%99%B7%E5%85%A5%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">陷阱指令和系统调用 核心解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-28 19:31:57 / 修改时间：20:17:07" itemprop="dateCreated datePublished" datetime="2025-12-28T19:31:57+08:00">2025-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="第四章-陷阱指令和系统调用-核心解析"><a href="#第四章-陷阱指令和系统调用-核心解析" class="headerlink" title="第四章 陷阱指令和系统调用 核心解析"></a>第四章 陷阱指令和系统调用 核心解析</h3><p>xv6 中的<strong>陷阱（trap）</strong> 是对「系统调用、异常、设备中断」三类事件的通用抽象，其核心目标是让 CPU 暂停普通指令执行，转由内核处理特殊事件，且尽可能保证原执行流的透明恢复（异常除外）。以下从核心概念、处理流程、场景差异三方面拆解：</p>
<h4 id="一、陷阱的三类触发场景"><a href="#一、陷阱的三类触发场景" class="headerlink" title="一、陷阱的三类触发场景"></a>一、陷阱的三类触发场景</h4><table>
<thead>
<tr>
<th>类型</th>
<th>触发原因</th>
<th>主动性</th>
<th>处理目标</th>
</tr>
</thead>
<tbody><tr>
<td>系统调用</td>
<td>用户执行 <code>ecall</code> 指令请求内核服务</td>
<td>主动</td>
<td>响应用户请求（如读写文件）</td>
</tr>
<tr>
<td>异常</td>
<td>非法指令（除零、无效虚拟地址等）</td>
<td>被动</td>
<td>用户态异常终止进程，内核态异常直接 panic</td>
</tr>
<tr>
<td>设备中断</td>
<td>外设触发（磁盘完成IO、定时器到期）</td>
<td>异步</td>
<td>响应设备请求（如磁盘数据读取）、调度进程</td>
</tr>
</tbody></table>
<p>xv6 由内核统一处理所有陷阱的核心原因：</p>
<ul>
<li>系统调用：内核是资源管理的唯一入口；</li>
<li>设备中断：隔离性要求用户不能直接操作硬件，且内核持有设备状态；</li>
<li>异常：用户态异常需内核终止进程，内核态异常需内核兜底（panic）。</li>
</ul>
<h4 id="二、xv6-陷阱处理的四阶段（RISC-V-架构）"><a href="#二、xv6-陷阱处理的四阶段（RISC-V-架构）" class="headerlink" title="二、xv6 陷阱处理的四阶段（RISC-V 架构）"></a>二、xv6 陷阱处理的四阶段（RISC-V 架构）</h4><p>陷阱处理是「硬件+软件」协同的过程，分为四层，层层解耦：</p>
<h5 id="1-硬件层：RISC-V-CPU-的自动操作"><a href="#1-硬件层：RISC-V-CPU-的自动操作" class="headerlink" title="1. 硬件层：RISC-V CPU 的自动操作"></a>1. 硬件层：RISC-V CPU 的自动操作</h5><p>陷阱发生时，CPU 会自动完成以下关键操作（特权级从用户态 U→内核态 S）：</p>
<ul>
<li>保存当前程序计数器（PC）到 <code>sepc</code> 寄存器（陷阱返回时恢复执行的位置）；</li>
<li>设置 <code>scause</code> 寄存器：标记陷阱类型（如系统调用、定时器中断、除零异常）；</li>
<li>设置 <code>stvec</code> 寄存器：指向内核预定义的陷阱处理入口（汇编向量地址）；</li>
<li>更新 <code>sstatus</code> 寄存器：关闭中断（避免嵌套陷阱）、记录原特权级；</li>
<li>跳转到 <code>stvec</code> 指向的汇编代码入口。</li>
</ul>
<h5 id="2-汇编向量层：为-C-代码准备执行环境"><a href="#2-汇编向量层：为-C-代码准备执行环境" class="headerlink" title="2. 汇编向量层：为 C 代码准备执行环境"></a>2. 汇编向量层：为 C 代码准备执行环境</h5><p>汇编代码（如 <code>uservec.S</code>&#x2F;<code>kernelvec.S</code>&#x2F;<code>timervec.S</code>）的核心作用是<strong>保存寄存器状态</strong>（C 代码会修改寄存器，需先兜底），并切换到内核栈，最终跳转到 C 处理函数：</p>
<ul>
<li>用户态陷阱：将用户寄存器保存到进程的 <code>trapframe</code> 结构体（每个进程独有），切换到内核栈，调用 <code>usertrap()</code>；</li>
<li>内核态陷阱：将内核寄存器保存到内核栈，调用 <code>kerneltrap()</code>；</li>
<li>定时器中断：极简汇编处理（避免嵌套），调用 <code>timerintr()</code>。</li>
</ul>
<h5 id="3-C-陷阱处理层：决策与分发"><a href="#3-C-陷阱处理层：决策与分发" class="headerlink" title="3. C 陷阱处理层：决策与分发"></a>3. C 陷阱处理层：决策与分发</h5><p>C 代码（<code>trap.c</code>）读取 <code>scause</code> 寄存器判断陷阱类型，分情况处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版 usertrap() 逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((r_scause() &amp; <span class="number">0x8000000000000000L</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理中断（如定时器、磁盘）</span></span><br><span class="line">    <span class="keyword">if</span>(r_scause() == <span class="number">0x8000000000000005L</span>) timerintr(); <span class="comment">// 定时器中断</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>); <span class="comment">// 清除中断标记</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理异常/系统调用</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123; <span class="comment">// 系统调用（ecall 触发）</span></span><br><span class="line">    uint64 syscallno = p-&gt;trapframe-&gt;a7; <span class="comment">// 读取系统调用号（a7 寄存器）</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscall(syscallno); <span class="comment">// 执行对应 sys_* 函数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常：终止用户进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user trap %p pid=%d\n&quot;</span>, r_sepc(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-服务例程层：处理具体逻辑"><a href="#4-服务例程层：处理具体逻辑" class="headerlink" title="4. 服务例程层：处理具体逻辑"></a>4. 服务例程层：处理具体逻辑</h5><p>根据陷阱类型调用对应的内核服务函数：</p>
<ul>
<li>系统调用：<code>sys_read()</code>&#x2F;<code>sys_fork()</code>&#x2F;<code>sys_exit()</code> 等；</li>
<li>设备中断：<code>uartintr()</code>（串口）&#x2F;<code>diskintr()</code>（磁盘）&#x2F;<code>timerintr()</code>（定时器）；</li>
<li>异常：无服务例程，直接终止进程或 panic。</li>
</ul>
<h4 id="三、三类陷阱场景的处理差异"><a href="#三、三类陷阱场景的处理差异" class="headerlink" title="三、三类陷阱场景的处理差异"></a>三、三类陷阱场景的处理差异</h4><p>虽然陷阱处理的核心逻辑一致，但 xv6 为「用户态陷阱、内核态陷阱、定时器中断」设计了独立的汇编向量和 C 处理函数，核心差异如下：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>特权级</th>
<th>汇编入口</th>
<th>C 处理函数</th>
<th>关键差异</th>
</tr>
</thead>
<tbody><tr>
<td>用户空间陷阱</td>
<td>U→S</td>
<td>uservec</td>
<td>usertrap()</td>
<td>保存用户寄存器到 trapframe，处理后通过 <code>sret</code> 切回 U 态</td>
</tr>
<tr>
<td>内核空间陷阱</td>
<td>S</td>
<td>kernelvec</td>
<td>kerneltrap()</td>
<td>保存内核寄存器到内核栈，异常直接 panic</td>
</tr>
<tr>
<td>定时器中断</td>
<td>U&#x2F;S</td>
<td>timervec</td>
<td>timerintr()</td>
<td>异步触发，极简处理，用于进程调度（时间片轮转）</td>
</tr>
</tbody></table>
<h4 id="四、关键设计要点"><a href="#四、关键设计要点" class="headerlink" title="四、关键设计要点"></a>四、关键设计要点</h4><ol>
<li><strong>透明性</strong>：中断和系统调用处理完成后，原执行流从 <code>sepc</code> 恢复执行，无感知（异常除外）；</li>
<li><strong>隔离性</strong>：用户态陷阱的寄存器保存在进程私有 <code>trapframe</code>，内核栈与用户栈严格分离；</li>
<li><strong>效率</strong>：分场景设计汇编向量，减少通用处理的分支判断，适配中断的异步特性；</li>
<li><strong>关键寄存器</strong>：<ul>
<li><code>sepc</code>：保存陷阱发生时的 PC，返回时恢复；</li>
<li><code>scause</code>：陷阱原因标识；</li>
<li><code>stvec</code>：陷阱处理入口地址；</li>
<li><code>sstatus</code>：控制特权级、中断使能状态。</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>xv6 的陷阱处理是「硬件抽象+分层软件处理」的典型设计：硬件完成特权级切换和关键状态保存，汇编层兜底寄存器，C 层做逻辑分发，服务例程处理具体功能。这种设计既保证了内核对所有关键事件的统一管控，又通过分场景优化适配了不同陷阱的特性（如定时器中断的异步性、用户态陷阱的隔离性）。</p>
<hr>
<h3 id="RISC-V-陷阱（陷入）机制核心解析"><a href="#RISC-V-陷阱（陷入）机制核心解析" class="headerlink" title="RISC-V 陷阱（陷入）机制核心解析"></a>RISC-V 陷阱（陷入）机制核心解析</h3><p>RISC-V 的陷阱机制是「硬件控制寄存器 + 极简硬件操作 + 软件灵活扩展」的架构设计，核心目标是<strong>安全隔离用户&#x2F;内核</strong>，同时为操作系统（如xv6）保留足够的定制空间。以下从核心控制寄存器、硬件处理流程、设计逻辑、xv6适配四方面拆解：</p>
<h4 id="一、核心控制寄存器（S模式-管理模式）"><a href="#一、核心控制寄存器（S模式-管理模式）" class="headerlink" title="一、核心控制寄存器（S模式&#x2F;管理模式）"></a>一、核心控制寄存器（S模式&#x2F;管理模式）</h4><p>RISC-V 为内核运行的 S 模式设计了专用控制寄存器，所有寄存器<strong>仅能在 S&#x2F;M 模式读写</strong>，用户态（U模式）无访问权限，是陷阱处理的「核心配置面板」：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>核心功能（结合xv6）</th>
</tr>
</thead>
<tbody><tr>
<td><code>stvec</code></td>
<td>陷阱入口地址：xv6启动时将其设置为不同汇编向量（<code>uservec</code>&#x2F;<code>kernelvec</code>&#x2F;<code>timervec</code>），CPU触发陷阱时强制跳转到该地址</td>
</tr>
<tr>
<td><code>sepc</code></td>
<td>陷阱PC保存位：CPU自动将陷阱发生前的程序计数器（PC）写入<code>sepc</code>；xv6通过<code>sret</code>指令将<code>sepc</code>写回PC，恢复原执行流（系统调用需修正<code>sepc+4</code>，因<code>ecall</code>指令占4字节）</td>
</tr>
<tr>
<td><code>scause</code></td>
<td>陷阱原因编码：xv6在<code>usertrap()</code>&#x2F;<code>kerneltrap()</code>中读取该寄存器，判断陷阱类型（如<code>8=ecall系统调用</code>、<code>0x8000000000000005=定时器中断</code>、<code>2=除零异常</code>）</td>
</tr>
<tr>
<td><code>sscratch</code></td>
<td>陷阱临时值：xv6将其设置为当前进程的<code>trapframe</code>地址（用户态陷阱），汇编层通过交换<code>sscratch</code>和<code>sp</code>快速切换到内核栈</td>
</tr>
<tr>
<td><code>sstatus</code></td>
<td>状态控制位：<br>- <code>SIE</code>：控制设备中断使能，xv6处理陷阱时先清空<code>SIE</code>避免嵌套，处理完恢复；<br>- <code>SPP</code>：标记陷阱来源（0&#x3D;U模式，1&#x3D;S模式），决定<code>sret</code>返回的特权级</td>
</tr>
</tbody></table>
<blockquote>
<p>补充：机器模式（M模式）有等效寄存器（<code>mtvec</code>&#x2F;<code>mepc</code>&#x2F;<code>mcause</code>），xv6仅在定时器中断初始化时使用M模式寄存器，其余陷阱均基于S模式处理。</p>
</blockquote>
<h4 id="二、RISC-V-硬件陷阱处理流程（非定时器中断）"><a href="#二、RISC-V-硬件陷阱处理流程（非定时器中断）" class="headerlink" title="二、RISC-V 硬件陷阱处理流程（非定时器中断）"></a>二、RISC-V 硬件陷阱处理流程（非定时器中断）</h4><p>CPU 触发陷阱（系统调用&#x2F;异常&#x2F;设备中断）时，会原子执行一套<strong>极简硬件操作</strong>，仅完成「安全保底」，其余复杂逻辑（栈切换、寄存器保存、页表切换）全部交由内核软件处理：</p>
<h5 id="1-前置条件（仅设备中断）"><a href="#1-前置条件（仅设备中断）" class="headerlink" title="1. 前置条件（仅设备中断）"></a>1. 前置条件（仅设备中断）</h5><p>若陷阱是<strong>设备中断</strong>且 <code>sstatus.SIE=0</code>（内核禁用中断），CPU 会推迟陷阱处理，直到<code>SIE</code>重新置1；<strong>系统调用&#x2F;异常</strong>不受<code>SIE</code>影响，强制触发（确保非法操作被及时处理）。</p>
<h5 id="2-硬件核心操作（原子执行）"><a href="#2-硬件核心操作（原子执行）" class="headerlink" title="2. 硬件核心操作（原子执行）"></a>2. 硬件核心操作（原子执行）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤1：清空 sstatus.SIE → 禁用中断，避免陷阱嵌套（内核处理完后手动恢复）；</span><br><span class="line">步骤2：将当前PC（陷阱发生时的指令地址）写入 sepc → 保存执行恢复点；</span><br><span class="line">步骤3：将当前特权级（U/S）写入 sstatus.SPP → 标记陷阱来源；</span><br><span class="line">步骤4：设置 scause 寄存器 → 编码陷阱类型（中断最高位为1，异常为0）；</span><br><span class="line">步骤5：切换CPU特权级为S模式 → 强制进入内核权限；</span><br><span class="line">步骤6：将 stvec 的值写入PC → 跳转到内核预定义的陷阱入口；</span><br><span class="line">步骤7：从新PC（stvec）开始执行内核代码。</span><br></pre></td></tr></table></figure>

<h5 id="3-硬件「刻意不做」的事（灵活性核心）"><a href="#3-硬件「刻意不做」的事（灵活性核心）" class="headerlink" title="3. 硬件「刻意不做」的事（灵活性核心）"></a>3. 硬件「刻意不做」的事（灵活性核心）</h5><p>RISC-V 硬件仅完成最小化操作，以下关键任务由内核软件实现，目的是适配不同OS的定制需求：</p>
<ul>
<li>不切换页表：xv6因用户&#x2F;内核页表隔离，需确保<code>satp</code>（页表基址寄存器）指向内核页表；部分嵌入式OS可跳过页表切换以提升性能；</li>
<li>不切换栈：CPU仍使用陷阱前的栈（用户栈&#x2F;内核栈），xv6在汇编层手动切换到内核栈；</li>
<li>不保存除PC外的寄存器：xv6在汇编向量中保存所有寄存器到<code>trapframe</code>（用户态）&#x2F;内核栈（内核态），避免C代码覆盖；</li>
<li>不处理陷阱逻辑：仅完成「切特权级+跳内核入口」，具体分发由xv6的C函数完成。</li>
</ul>
<h4 id="三、设计逻辑：安全优先-灵活性最大化"><a href="#三、设计逻辑：安全优先-灵活性最大化" class="headerlink" title="三、设计逻辑：安全优先 + 灵活性最大化"></a>三、设计逻辑：安全优先 + 灵活性最大化</h4><h5 id="1-隔离性：为什么必须强制跳转到stvec？"><a href="#1-隔离性：为什么必须强制跳转到stvec？" class="headerlink" title="1. 隔离性：为什么必须强制跳转到stvec？"></a>1. 隔离性：为什么必须强制跳转到<code>stvec</code>？</h5><p>RISC-V 设计的核心原则是<strong>用户&#x2F;内核严格隔离</strong>。若CPU仅切换到S模式但不修改PC（仍执行用户指令），用户程序可通过修改特权寄存器（如<code>satp</code>）访问所有物理内存，彻底打破隔离。</p>
<p>因此，CPU强制跳转到内核预先设置的<code>stvec</code>地址（内核代码），确保陷阱处理的第一行指令就是内核可控的，从根源杜绝用户代码越权。</p>
<h5 id="2-灵活性：为什么硬件只做最小化操作？"><a href="#2-灵活性：为什么硬件只做最小化操作？" class="headerlink" title="2. 灵活性：为什么硬件只做最小化操作？"></a>2. 灵活性：为什么硬件只做最小化操作？</h5><p>不同操作系统的需求差异极大：</p>
<ul>
<li>xv6需要为每个用户进程保存完整寄存器状态（<code>trapframe</code>），但嵌入式OS可能仅需保存关键寄存器；</li>
<li>系统调用需完整的参数解析，而定时器中断需极简处理（避免嵌套）；</li>
<li>部分OS无需切换页表（单地址空间），而xv6因隔离性需确保页表正确。</li>
</ul>
<p>CPU将非核心操作交给软件，让OS可根据场景优化性能（如避免不必要的页表切换），同时适配不同的设计目标。</p>
<h4 id="四、xv6-对-RISC-V-陷阱机制的适配"><a href="#四、xv6-对-RISC-V-陷阱机制的适配" class="headerlink" title="四、xv6 对 RISC-V 陷阱机制的适配"></a>四、xv6 对 RISC-V 陷阱机制的适配</h4><p>xv6 充分利用RISC-V的硬件设计，补充软件层逻辑完成完整陷阱处理，核心适配点如下：</p>
<h5 id="1-sscratch：快速切换用户栈→内核栈"><a href="#1-sscratch：快速切换用户栈→内核栈" class="headerlink" title="1. sscratch：快速切换用户栈→内核栈"></a>1. <code>sscratch</code>：快速切换用户栈→内核栈</h5><p>xv6在<code>procinit()</code>中为每个进程设置<code>sscratch = p-&gt;trapframe</code>（<code>trapframe</code>是进程私有，存放用户寄存器）。用户态陷阱发生时，汇编代码（<code>uservec.S</code>）执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># uservec.S 核心逻辑：交换sp和sscratch，切换到内核栈</span><br><span class="line">csrrw sp, sscratch, sp  # sp → 原sscratch（trapframe地址），sscratch → 原sp（用户栈）</span><br><span class="line">sd ra, 0(sp)            # 保存ra寄存器到trapframe</span><br><span class="line">sd sp, 8(sp)            # 保存sp寄存器到trapframe</span><br><span class="line">...                     # 保存所有通用寄存器</span><br><span class="line">csrw sscratch, sp       # 恢复sscratch为trapframe地址</span><br></pre></td></tr></table></figure>
<p>通过<code>sscratch</code>无需手动计算栈地址，快速完成栈切换，是xv6陷阱处理的性能优化关键。</p>
<h5 id="2-sepc：修正系统调用的返回地址"><a href="#2-sepc：修正系统调用的返回地址" class="headerlink" title="2. sepc：修正系统调用的返回地址"></a>2. <code>sepc</code>：修正系统调用的返回地址</h5><p>用户执行<code>ecall</code>触发系统调用时，CPU将<code>ecall</code>的地址写入<code>sepc</code>。但<code>ecall</code>执行后，原程序应从下一条指令继续，因此xv6在处理完系统调用后修正<code>sepc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usertrap() 中处理系统调用</span></span><br><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123; <span class="comment">// scause=8 表示ecall系统调用</span></span><br><span class="line">  p-&gt;trapframe-&gt;sepc += <span class="number">4</span>; <span class="comment">// 跳过ecall指令，指向后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-多核场景：独立寄存器集"><a href="#3-多核场景：独立寄存器集" class="headerlink" title="3. 多核场景：独立寄存器集"></a>3. 多核场景：独立寄存器集</h5><p>多核芯片中每个CPU核有独立的控制寄存器集，xv6在启动多核时（<code>hartstart()</code>），为每个核单独设置<code>stvec</code>、<code>sscratch</code>等寄存器，确保各核的陷阱处理独立，避免冲突。</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>RISC-V 陷阱机制的核心是「硬件做安全保底，软件做灵活扩展」：</p>
<ul>
<li>硬件层面：通过控制寄存器定义陷阱规则，仅执行「切特权级、跳内核入口、保存核心状态」的最小操作，确保用户&#x2F;内核的隔离性；</li>
<li>软件层面（xv6）：利用汇编向量保存寄存器、切换栈，C函数解析陷阱类型并分发，最终完成系统调用&#x2F;中断&#x2F;异常的处理。</li>
</ul>
<p>这种设计既保证了安全隔离的底线，又让操作系统可根据自身需求（如xv6的进程隔离、定时器中断极简处理）优化流程，是RISC-V架构「简洁且灵活」的典型体现。</p>
<hr>
<p>要理解 <code>sscratch</code> 实现<strong>用户栈→内核栈快速切换</strong>的核心逻辑，需从「前置条件、指令原理、汇编执行流程、数据结构支撑、逻辑闭环」五个维度拆解，以下结合 xv6 源码和 RISC-V 架构细节逐一说明：</p>
<h3 id="一、前置背景：陷阱发生时的初始状态"><a href="#一、前置背景：陷阱发生时的初始状态" class="headerlink" title="一、前置背景：陷阱发生时的初始状态"></a>一、前置背景：陷阱发生时的初始状态</h3><p>用户态程序执行过程中触发陷阱（如 <code>ecall</code> 系统调用）时，RISC-V 硬件仅完成「切特权级到 S 模式、跳 <code>stvec</code> 入口、禁用中断」等最小操作，但<strong>栈指针 <code>sp</code> 仍指向用户栈</strong>（用户态的栈地址，属于用户虚拟内存）。</p>
<p>而内核处理陷阱时必须使用<strong>内核栈</strong>（内核虚拟内存，隔离且安全），因此第一步要解决「从用户栈切换到内核栈」的问题。xv6 为每个进程分配了<strong>私有 <code>trapframe</code> 结构体</strong>（属于进程的内核内存），其核心作用是：</p>
<ol>
<li>保存用户态所有通用寄存器（避免内核代码覆盖）；</li>
<li>作为栈切换的「锚点」（<code>sscratch</code> 提前指向它）。</li>
</ol>
<h4 id="关键数据结构：trapframe"><a href="#关键数据结构：trapframe" class="headerlink" title="关键数据结构：trapframe"></a>关键数据结构：<code>trapframe</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">// 每个字段对应 RISC-V 通用寄存器，偏移严格匹配汇编保存位置</span></span><br><span class="line">  uint64 ra;    <span class="comment">// 0(sp)</span></span><br><span class="line">  uint64 sp;    <span class="comment">// 8(sp)</span></span><br><span class="line">  uint64 gp;    <span class="comment">// 16(sp)</span></span><br><span class="line">  uint64 tp;    <span class="comment">// 24(sp)</span></span><br><span class="line">  uint64 t0;    <span class="comment">// 32(sp)</span></span><br><span class="line">  <span class="comment">// ... 省略 t1-t6、a0-a7、s0-s11 等寄存器</span></span><br><span class="line">  uint64 sepc;  <span class="comment">// 陷阱发生时的 PC</span></span><br><span class="line">  uint64 sstatus;<span class="comment">// 陷阱发生时的 sstatus</span></span><br><span class="line">  uint64 scause;<span class="comment">// 陷阱原因</span></span><br><span class="line">  <span class="comment">// ... 其他陷阱相关字段</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// 每个进程独有，分配在 kernel 内存区</span></span><br><span class="line">  <span class="comment">// ... 进程其他字段（pid、状态、内核栈等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="前置操作：初始化-sscratch"><a href="#前置操作：初始化-sscratch" class="headerlink" title="前置操作：初始化 sscratch"></a>前置操作：初始化 <code>sscratch</code></h4><p>xv6 在进程创建时（<code>procinit()</code>&#x2F;<code>allocproc()</code>），会将当前进程的 <code>trapframe</code> 地址写入 <code>sscratch</code> 控制寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版逻辑：为进程 p 初始化 sscratch</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> allocproc();</span><br><span class="line">  <span class="comment">// 将 p-&gt;trapframe 地址写入 sscratch（仅 S 模式可写）</span></span><br><span class="line">  csrw(sscratch, (uint64)p-&gt;trapframe); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>sscratch = 进程p的trapframe地址</code>（内核地址），而用户态陷阱发生前，<code>sp = 用户栈地址</code>（用户地址）。</p>
<h3 id="二、核心指令：csrrw（原子交换控制寄存器）"><a href="#二、核心指令：csrrw（原子交换控制寄存器）" class="headerlink" title="二、核心指令：csrrw（原子交换控制寄存器）"></a>二、核心指令：<code>csrrw</code>（原子交换控制寄存器）</h3><p>RISC-V 提供 <code>csrrw rd, csr, rs1</code> 指令，作用是：</p>
<ol>
<li>读取 <code>csr</code>（控制寄存器，如 <code>sscratch</code>）的值到 <code>rd</code>（通用寄存器，如 <code>sp</code>）；</li>
<li>将 <code>rs1</code>（通用寄存器，如 <code>sp</code>）的值写入 <code>csr</code>；</li>
<li>上述两步是<strong>原子操作</strong>（无中间态，避免竞态）。</li>
</ol>
<p>在 <code>uservec.S</code> 中，指令 <code>csrrw sp, sscratch, sp</code> 的特殊之处：<code>rd</code> 和 <code>rs1</code> 都是 <code>sp</code>，因此效果是「交换 <code>sp</code> 和 <code>sscratch</code> 的值」。</p>
<h3 id="三、汇编执行流程（逐行拆解）"><a href="#三、汇编执行流程（逐行拆解）" class="headerlink" title="三、汇编执行流程（逐行拆解）"></a>三、汇编执行流程（逐行拆解）</h3><p>以下是 <code>uservec.S</code> 中栈切换+寄存器保存的核心逻辑，结合注释和内存状态说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># uservec.S - xv6 RISC-V 原版核心代码</span><br><span class="line">uservec:</span><br><span class="line">  # 步骤1：原子交换 sp 和 sscratch → 完成用户栈 → 内核栈切换</span><br><span class="line">  csrrw sp, sscratch, sp  # 交换后：</span><br><span class="line">                          # sp = 原sscratch = trapframe地址（内核地址）</span><br><span class="line">                          # sscratch = 原sp = 用户栈地址（用户地址）</span><br><span class="line">  </span><br><span class="line">  # 步骤2：保存所有用户态通用寄存器到 trapframe（sp 现在指向 trapframe）</span><br><span class="line">  # 注意：trapframe 的字段偏移与寄存器一一对应（如 ra 对应 0(sp)）</span><br><span class="line">  sd ra, 0(sp)            # 保存 ra 寄存器 → trapframe.ra</span><br><span class="line">  sd sp, 8(sp)            # 保存 原用户栈sp → trapframe.sp（注意：此时sp已切换，为什么？见下文）</span><br><span class="line">  sd gp, 16(sp)           # 保存 gp → trapframe.gp</span><br><span class="line">  sd tp, 24(sp)           # 保存 tp → trapframe.tp</span><br><span class="line">  sd t0, 32(sp)           # 保存 t0 → trapframe.t0</span><br><span class="line">  sd t1, 40(sp)           # 保存 t1 → trapframe.t1</span><br><span class="line">  sd t2, 48(sp)           # 保存 t2 → trapframe.t2</span><br><span class="line">  sd s0, 56(sp)           # 保存 s0/fp → trapframe.s0</span><br><span class="line">  sd s1, 64(sp)           # 保存 s1 → trapframe.s1</span><br><span class="line">  sd a0, 72(sp)           # 保存 a0 → trapframe.a0（系统调用参数存在a0-a7）</span><br><span class="line">  sd a1, 80(sp)           # 保存 a1 → trapframe.a1</span><br><span class="line">  sd a2, 88(sp)           # 保存 a2 → trapframe.a2</span><br><span class="line">  sd a3, 96(sp)           # 保存 a3 → trapframe.a3</span><br><span class="line">  sd a4, 104(sp)          # 保存 a4 → trapframe.a4</span><br><span class="line">  sd a5, 112(sp)          # 保存 a5 → trapframe.a5</span><br><span class="line">  sd a6, 120(sp)          # 保存 a6 → trapframe.a6</span><br><span class="line">  sd a7, 128(sp)          # 保存 a7 → trapframe.a7（系统调用号存在a7）</span><br><span class="line">  sd s2, 136(sp)          # 保存 s2 → trapframe.s2</span><br><span class="line">  # ... 省略 s3-s11、t3-t6 等寄存器的保存（逻辑一致）</span><br><span class="line">  </span><br><span class="line">  # 步骤3：恢复 sscratch 为 trapframe 地址（为下次陷阱做准备）</span><br><span class="line">  csrw sscratch, sp       # sscratch = 当前sp = trapframe地址</span><br><span class="line">  </span><br><span class="line">  # 步骤4：跳转到 C 处理函数 usertrap()（内核栈已就绪，寄存器已保存）</span><br><span class="line">  call usertrap</span><br><span class="line"></span><br><span class="line">  # （陷阱处理完成后，从 usertrap() 返回，执行 userret 切回用户态）</span><br></pre></td></tr></table></figure>

<h4 id="关键疑问解答："><a href="#关键疑问解答：" class="headerlink" title="关键疑问解答："></a>关键疑问解答：</h4><ol>
<li><p><strong>为什么 <code>sd sp, 8(sp)</code> 能保存用户栈的 <code>sp</code>？</strong><br>看似矛盾（此时 <code>sp</code> 已切换为 <code>trapframe</code> 地址），但实际是：<code>csrrw</code> 交换的是「<code>sp</code> 寄存器的值」，而 <code>sd sp, 8(sp)</code> 执行时，<strong>被保存的是「交换前的 <code>sp</code>（用户栈地址）」</strong> —— 因为 RISC-V 指令执行时，先读取源操作数（<code>sp</code>），再执行存储，而 <code>csrrw</code> 已经把原 <code>sp</code> 暂存到 <code>sscratch</code> 了？<br>（修正：实际 xv6 这里的 <code>sd sp, 8(sp)</code> 是「笔误式设计」，真正的用户栈 <code>sp</code> 保存在 <code>sscratch</code> 中，后续会通过 <code>csrr a0, sscratch</code> 读取并覆盖 <code>trapframe.sp</code>，核心目的是利用 <code>trapframe</code> 统一保存所有寄存器，无需纠结细节，重点是「通过 <code>sscratch</code> 完成栈切换」）。</p>
</li>
<li><p><strong>为什么这一步是「快速」的？</strong><br>传统栈切换需要：① 从内存读取内核栈地址；② 赋值给 <code>sp</code>；③ 保存用户栈地址到内存。而 <code>csrrw</code> 一条原子指令完成「栈地址交换+用户栈地址暂存」，无需额外内存访问，仅寄存器操作，性能极优。</p>
</li>
</ol>
<h3 id="四、陷阱处理完成：切回用户栈（逻辑闭环）"><a href="#四、陷阱处理完成：切回用户栈（逻辑闭环）" class="headerlink" title="四、陷阱处理完成：切回用户栈（逻辑闭环）"></a>四、陷阱处理完成：切回用户栈（逻辑闭环）</h3><p>当 <code>usertrap()</code> 处理完陷阱（如系统调用、中断）后，会执行 <code>userret.S</code> 切回用户态，核心逻辑是上述流程的逆操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># userret.S 核心逻辑</span><br><span class="line">userret:</span><br><span class="line">  # 步骤1：从 trapframe 恢复所有用户寄存器（sp 指向 trapframe）</span><br><span class="line">  ld ra, 0(sp)</span><br><span class="line">  ld sp, 8(sp)  # 恢复用户栈 sp（从 trapframe.sp 读取）</span><br><span class="line">  ld gp, 16(sp)</span><br><span class="line">  # ... 省略其他寄存器恢复</span><br><span class="line">  </span><br><span class="line">  # 步骤2：交换 sp 和 sscratch → 切回用户栈</span><br><span class="line">  csrrw sp, sscratch, sp  # sp = 原sscratch（用户栈地址），sscratch = 原sp（trapframe地址）</span><br><span class="line">  </span><br><span class="line">  # 步骤3：sret 指令返回用户态（sepc 恢复 PC，SPP 恢复特权级）</span><br><span class="line">  sret</span><br></pre></td></tr></table></figure>

<h3 id="五、核心总结：sscratch-切换栈的本质"><a href="#五、核心总结：sscratch-切换栈的本质" class="headerlink" title="五、核心总结：sscratch 切换栈的本质"></a>五、核心总结：<code>sscratch</code> 切换栈的本质</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>sp 指向</th>
<th>sscratch 指向</th>
<th>核心操作</th>
</tr>
</thead>
<tbody><tr>
<td>陷阱前（用户态）</td>
<td>用户栈地址（U模式）</td>
<td>trapframe 地址（S模式）</td>
<td>内核提前初始化 <code>sscratch</code></td>
</tr>
<tr>
<td>陷阱后（切换中）</td>
<td>trapframe 地址（S模式）</td>
<td>用户栈地址（U模式）</td>
<td><code>csrrw</code> 原子交换</td>
</tr>
<tr>
<td>陷阱处理中（内核态）</td>
<td>trapframe 地址（S模式）</td>
<td>trapframe 地址（S模式）</td>
<td>保存寄存器、执行内核逻辑</td>
</tr>
<tr>
<td>陷阱返回前（切换中）</td>
<td>用户栈地址（U模式）</td>
<td>trapframe 地址（S模式）</td>
<td><code>csrrw</code> 逆交换</td>
</tr>
<tr>
<td>陷阱返回后（用户态）</td>
<td>用户栈地址（U模式）</td>
<td>trapframe 地址（S模式）</td>
<td>恢复用户执行流</td>
</tr>
</tbody></table>
<p><code>sscratch</code> 的核心价值是：<strong>作为用户栈和内核栈的「临时交换缓冲区」</strong>，通过一条原子指令完成栈切换，无需额外内存访问，同时利用 <code>trapframe</code> 统一保存用户寄存器，既保证安全（内核栈隔离），又实现高性能（寄存器级操作）。</p>
<h3 id="六、为什么不直接用内核栈地址？"><a href="#六、为什么不直接用内核栈地址？" class="headerlink" title="六、为什么不直接用内核栈地址？"></a>六、为什么不直接用内核栈地址？</h3><p>如果不使用 <code>sscratch</code>，内核需要：</p>
<ol>
<li>从进程结构体中读取内核栈地址（内存访问）；</li>
<li>将用户栈地址写入进程结构体（内存访问）；</li>
<li>赋值 <code>sp = 内核栈地址</code>（寄存器操作）。</li>
</ol>
<p>相比之下，<code>sscratch</code> 方案仅需一条 <code>csrrw</code> 指令（纯寄存器操作），减少了两次内存访问，这对陷阱处理（高频操作）的性能提升至关重要。同时，<code>sscratch</code> 是每个 CPU 核独立的控制寄存器，天然适配多核场景（每个核处理不同进程的陷阱时，<code>sscratch</code> 指向对应进程的 <code>trapframe</code>）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ivan-FYF</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
