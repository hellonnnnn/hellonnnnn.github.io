{"meta":{"title":"Ivan's Tech Blog","subtitle":"C++ / Linux / System Programming","description":"记录 C++、Linux、系统方向学习与项目","author":"Ivan-FYF","url":"https://hellonnnnn.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-17","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-17","excerpt":""}],"posts":[{"title":"xv6-labs-2020 lab1","text":"fork + exec：Unix &#x2F; Linux（xv6）执行程序的核心模式12345678910111213141516171819# fork + exec：Unix / xv6 执行程序的核心模型先明确一个核心概念：**fork + exec 是 Unix / Linux（包括 xv6）执行程序的经典模式**。你给出的代码片段中，`exec` 会用目标程序（如 `/bin/echo`）**替换当前进程的代码和数据**，但需要特别注意的是：&gt; **exec 本身不会创建新进程**因此，实际使用中必须先通过 `fork` 创建子进程，再在子进程中调用 `exec`。 这样既能保留父进程（shell），又能让子进程执行新程序，这正是 **xv6 shell 的核心逻辑**。---## xv6 shell 执行 `echo hello` 的完整流程（结合源码）下面以用户在 xv6 shell 中输入：```textecho hello 为例，结合 user/sh.c 的关键位置，拆解整个执行过程。 步骤 1：shell 主循环等待用户输入位置：main()（user/sh.c:145） xv6 的 shell 运行在一个无限循环中，主要完成两件事： 打印命令提示符（如 $ ） 调用 getcmd() 读取用户输入的一行命令 此时： shell 是父进程 处于前台运行状态 等待用户输入命令 步骤 2：创建子进程（fork）当用户输入 echo hello 并回车后，shell 调用： 1int pid = fork(); fork() 会创建一个与当前进程几乎完全相同的子进程： 父进程（shell） fork() 返回子进程的 PID 随后调用 wait() 或 waitpid()，进入阻塞状态 子进程 fork() 返回 0 继续执行后续的命令处理逻辑 关键点： fork 是“复制”，不是重新创建 子进程在 exec 之前与父进程共享相同的代码和数据 步骤 3：子进程调用 runcmd 处理命令位置：runcmd()（user/sh.c:58） 子进程会解析用户输入的命令： 命令名：echo 参数：hello 并构造参数数组 argv： 1234char *argv[3];argv[0] = &quot;echo&quot;; // 程序名argv[1] = &quot;hello&quot;; // 参数argv[2] = 0; // 参数数组必须以 NULL 结尾 同时，runcmd 会确定可执行文件路径，例如： 1/bin/echo 步骤 4：子进程调用 exec 替换程序位置：user/sh.c:78 子进程调用： 1exec(&quot;/bin/echo&quot;, argv); exec 的行为是： 丢弃当前子进程的代码和数据 加载 /bin/echo 的代码和数据 从 echo 程序的 main 函数开始执行 如果 exec 调用成功： 当前进程将不再是 shell 的副本 之前的 runcmd 代码不会再执行 printf(&quot;exec error\\n&quot;) 不会被执行 步骤 5：echo 程序执行并调用 exitecho 程序运行后： 向标准输出打印： 1hello 调用： 1exit(0); 子进程终止，并通知父进程。 步骤 6：父进程（shell）从 wait 返回父进程中的： 1wait(0); 返回后： shell 回收子进程资源 清除僵尸进程 重新回到主循环 再次打印提示符，等待下一条命令 exec 失败时会发生什么？如果： 1exec(&quot;/bin/echo&quot;, argv); 执行失败（如文件不存在），则： 当前进程不会被替换 会继续执行后续代码： 12printf(&quot;exec error\\n&quot;);exit(1); 随后子进程退出，父进程依然会从 wait() 返回。 为什么 argv[0] 是程序名？原因包括： Unix 规范约定 argv[0] 表示程序名 argv[1] 及以后才是实际参数 程序自身可能使用 argv[0] 同一个程序根据启动名执行不同逻辑（如 busybox） xv6 的简化实现 多数 xv6 程序忽略 argv[0] 但依然遵循该参数规范 总结核心结论 fork + exec 是 Unix &#x2F; xv6 执行程序的标准模式 fork 负责创建进程 exec 负责加载并运行新程序 shell 通过 wait 保持自身持续运行 echo hello 的完整链路1234567shell 读取命令→ fork 创建子进程→ 子进程解析命令→ exec 加载 /bin/echo→ echo 输出 hello 并 exit→ 父进程 wait 返回→ shell 继续等待输入 这一设计实现了 进程创建与程序执行的解耦，也是 Unix shell 能持续工作的根本原因。 以下是runcmd函数的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475voidruncmd(struct cmd *cmd)&#123; int p[2]; struct backcmd *bcmd; struct execcmd *ecmd; struct listcmd *lcmd; struct pipecmd *pcmd; struct redircmd *rcmd; if(cmd == 0) exit(1); switch(cmd-&gt;type)&#123; default: panic(&quot;runcmd&quot;); case EXEC: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(1); exec(ecmd-&gt;argv[0], ecmd-&gt;argv); fprintf(2, &quot;exec %s failed\\n&quot;, ecmd-&gt;argv[0]); break; case REDIR: rcmd = (struct redircmd*)cmd; close(rcmd-&gt;fd); if(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; 0)&#123; fprintf(2, &quot;open %s failed\\n&quot;, rcmd-&gt;file); exit(1); &#125; runcmd(rcmd-&gt;cmd); break; case LIST: lcmd = (struct listcmd*)cmd; if(fork1() == 0) runcmd(lcmd-&gt;left); wait(0); runcmd(lcmd-&gt;right); break; case PIPE: pcmd = (struct pipecmd*)cmd; if(pipe(p) &lt; 0) panic(&quot;pipe&quot;); if(fork1() == 0)&#123; close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); &#125; if(fork1() == 0)&#123; close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; case BACK: bcmd = (struct backcmd*)cmd; if(fork1() == 0) runcmd(bcmd-&gt;cmd); break; &#125; exit(0);&#125; 一、函数整体功能总结runcmd是一个递归函数，它接收一个struct cmd类型的命令节点（这个节点是shell解析用户输入后生成的抽象语法树节点），通过switch判断命令的类型（EXEC&#x2F;REDIR&#x2F;LIST&#x2F;PIPE&#x2F;BACK），然后执行对应的逻辑。核心依赖fork1（xv6的fork封装）、exec、pipe、dup、wait等系统调用，实现了Unix shell的核心功能。 二、关键数据结构说明代码中出现的struct cmd及其子结构体是xv6对不同命令的封装，每个子结构体对应一种命令类型： struct execcmd：普通执行命令（如echo hello），包含命令参数数组argv； struct redircmd：重定向命令（如echo hello &gt; file.txt），包含重定向的文件描述符fd、文件名file、打开模式mode，以及被重定向的子命令cmd； struct listcmd：顺序执行命令（如echo hello ; ls），包含左命令left和右命令right； struct pipecmd：管道命令（如ls | grep txt），包含左命令left（管道写端）和右命令right（管道读端）； struct backcmd：后台运行命令（如sleep 10 &amp;），包含后台执行的子命令cmd； cmd-&gt;type：标识命令类型的枚举（EXEC&#x2F;REDIR等）。 三、逐模块解析代码逻辑1. 基础判断：空命令直接退出12if(cmd == 0) exit(1); 如果命令节点为空（解析失败），子进程直接退出，返回错误状态。 2. EXEC：执行普通程序（核心分支，如echo hello）1234567case EXEC: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(1); exec(ecmd-&gt;argv[0], ecmd-&gt;argv); fprintf(2, &quot;exec %s failed\\n&quot;, ecmd-&gt;argv[0]); break; 逻辑拆解： 将cmd强转为execcmd（普通执行命令结构体），获取参数数组argv； 如果argv[0]为空（无命令名），直接退出； 调用exec系统调用，加载并执行argv[0]对应的程序（如/bin/echo），参数为argv； 如果exec返回，说明执行失败（因为成功的exec会替换进程代码，不会返回），此时打印错误信息； 注意：这里的exec是xv6的封装，对应你之前看到的exec(&quot;/bin/echo&quot;, argv)逻辑。 3. REDIR：处理输入输出重定向（如echo hello &gt; file.txt）123456789case REDIR: rcmd = (struct redircmd*)cmd; close(rcmd-&gt;fd); if(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; 0)&#123; fprintf(2, &quot;open %s failed\\n&quot;, rcmd-&gt;file); exit(1); &#125; runcmd(rcmd-&gt;cmd); break; 逻辑拆解（以echo hello &gt; file.txt为例）： rcmd-&gt;fd：要重定向的文件描述符（如stdout是1，stdin是0，stderr是2）； close(rcmd-&gt;fd)：关闭原来的文件描述符（比如关闭stdout（1））； open(rcmd-&gt;file, rcmd-&gt;mode)：打开目标文件（如file.txt，写模式），此时系统会分配最小的可用文件描述符（也就是刚才关闭的1）； 递归调用runcmd(rcmd-&gt;cmd)：执行被重定向的命令（如echo hello），此时命令的输出（原本写向stdout（1））会被重定向到file.txt； 核心原理：利用Unix文件描述符的“最小可用”规则，通过close+open实现重定向（xv6也支持dup实现，逻辑一致）。 4. LIST：处理顺序执行命令（如echo hello ; ls）1234567case LIST: lcmd = (struct listcmd*)cmd; if(fork1() == 0) runcmd(lcmd-&gt;left); wait(0); runcmd(lcmd-&gt;right); break; 逻辑拆解： lcmd-&gt;left：左边的命令（如echo hello），lcmd-&gt;right：右边的命令（如ls）； fork1()创建子进程，子进程执行左命令； 父进程调用wait(0)，阻塞等待左命令执行完毕； 左命令执行完后，父进程再执行右命令； 特点：顺序执行，左命令完成后才会执行右命令。 5. PIPE：处理管道命令（如ls | grep txt）1234567891011121314151617181920212223case PIPE: pcmd = (struct pipecmd*)cmd; if(pipe(p) &lt; 0) panic(&quot;pipe&quot;); if(fork1() == 0)&#123; close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); &#125; if(fork1() == 0)&#123; close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; 这是最复杂的分支，核心是利用pipe创建管道，将左命令的输出作为右命令的输入。 逻辑拆解（以ls | grep txt为例）： 创建管道：pipe(p)创建一个管道，p[0]是读端，p[1]是写端； 处理左命令（ls，管道写端）： fork1()创建子进程1； close(1)：关闭子进程1的stdout（1）； dup(p[1])：复制管道写端p[1]到stdout（1）（因为1是最小可用描述符）； close(p[0])和close(p[1])：关闭多余的管道描述符（只保留重定向后的stdout）； 执行左命令ls，此时ls的输出会写入管道写端p[1]； 处理右命令（grep txt，管道读端）： fork1()创建子进程2； close(0)：关闭子进程2的stdin（0）； dup(p[0])：复制管道读端p[0]到stdin（0）； close(p[0])和close(p[1])：关闭多余的管道描述符； 执行右命令grep txt，此时grep会从管道读端p[0]读取ls的输出； 父进程处理： close(p[0])和close(p[1])：父进程关闭管道描述符（否则子进程退出后管道不会被释放）； wait(0)两次：等待两个子进程都执行完毕； 核心原理：管道是单向的，左进程写管道，右进程读管道，通过dup将管道描述符重定向到标准输入&#x2F;输出。 6. BACK：处理后台运行命令（如sleep 10 &amp;）12345case BACK: bcmd = (struct backcmd*)cmd; if(fork1() == 0) runcmd(bcmd-&gt;cmd); break; 逻辑拆解： fork1()创建子进程，子进程执行后台命令（如sleep 10）； 父进程不调用wait(0)：这是和普通命令的关键区别，父进程（shell）不会阻塞，直接返回继续处理下一条命令； 特点：命令在后台运行，shell无需等待，用户可以立即输入新命令； 注意：xv6的后台处理比较简化，没有处理僵尸进程（实际Unix shell会用信号处理）。 7. 函数末尾：退出进程1exit(0); 无论哪种命令类型执行完毕（除了exec成功的情况，因为exec会替换代码，不会走到这里），子进程都会调用exit(0)退出。 四、总结关键点回顾 核心逻辑：runcmd通过类型判断+递归调用，处理xv6 shell的所有命令类型，依赖fork+exec实现程序执行，依赖pipe+dup实现管道，依赖close+open实现重定向。 各命令类型的核心差异： EXEC：直接exec执行程序，失败则打印错误； REDIR：先重定向文件描述符，再递归执行命令； LIST：fork执行左命令，wait后执行右命令； PIPE：创建管道，两个子进程分别处理左右命令，实现数据传递； BACK：fork执行命令，父进程不wait，后台运行； xv6的简化处理：相比实际Unix shell，xv6的runcmd省略了信号处理（如后台进程的僵尸回收）、通配符解析、环境变量等功能，但保留了shell的核心骨架。 这个函数是xv6 shell的“心脏”，理解它的逻辑就能掌握xv6如何处理用户命令的本质。","path":"2025/12/18/xv6-labs-2020-lab1/","date":"12-18","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 我是Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2025/12/17/hello-world/","date":"12-17","excerpt":"","tags":[]}],"categories":[],"tags":[]}