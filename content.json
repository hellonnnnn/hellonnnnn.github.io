{"meta":{"title":"Ivan's Tech Blog","subtitle":"C++ / Linux / System Programming","description":"记录 C++、Linux、系统方向学习与项目","author":"Ivan-FYF","url":"https://hellonnnnn.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-17","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-17","excerpt":""}],"posts":[{"title":"xv6-labs-2020 lab1","text":"先明确核心概念：fork+exec是 Unix&#x2F;Linux（包括 xv6）执行程序的核心模式你给出的代码片段中，exec会替换当前进程的代码和数据为目标程序（如&#x2F;bin&#x2F;echo），但 **exec本身不会创建新进程 **。因此，实际使用中需要先通过fork创建子进程，再在子进程中调用exec—— 这样既保留了父进程（shell），又能让子进程执行新程序，这也是 xv6 shell 的核心逻辑。xv6 shell 执行echo hello的完整流程（结合源码位置）我们以用户在 xv6 shell 中输入echo hello为例，结合你提到的user&#x2F;sh.c中的关键行，拆解整个过程：步骤 1：shell 的主循环等待用户输入（main(user&#x2F;sh.c:145)）xv6 的 shell 运行在一个无限主循环中，核心做两件事：打印提示符（如$ ）；调用getcmd函数读取用户输入的一行命令（如echo hello）。此时 shell 是父进程，处于前台运行状态，等待用户输入命令。步骤 2：创建子进程（fork）当用户输入echo hello并回车后，shell 会调用fork()系统调用，创建一个和自身完全相同的子进程：父进程（shell）：fork会返回子进程的 PID（进程 ID），之后父进程会调用wait()或waitpid()，进入阻塞状态，等待子进程执行完毕。子进程：fork会返回 0，子进程会继续执行后续的命令处理逻辑（即调用runcmd）。关键：fork是 “复制” 而非 “新创建”，子进程拥有和父进程完全相同的内存空间、代码和数据，直到执行exec才会被替换。步骤 3：子进程调用runcmd(user&#x2F;sh.c:58)处理命令子进程会将用户输入的echo hello解析为命令和参数（命令：echo，参数：hello），然后调用runcmd函数执行实际逻辑：解析命令路径：runcmd会找到echo对应的可执行文件路径（如&#x2F;bin&#x2F;echo）；构造参数数组argv：就像你给出的代码片段一样，构造格式如下：char* argv[3];argv[0] &#x3D; “echo”; &#x2F;&#x2F; 第一个参数通常是程序名，多数程序会忽略，但规范要求保留argv[1] &#x3D; “hello”; &#x2F;&#x2F; 实际的参数argv[2] &#x3D; 0; &#x2F;&#x2F; 参数数组以NULL结尾，标识参数结束步骤 4：子进程调用exec(user&#x2F;sh.c:78)替换程序子进程调用exec(“&#x2F;bin&#x2F;echo”, argv)，这是整个流程的核心：exec系统调用会丢弃当前子进程的代码和数据，加载&#x2F;bin&#x2F;echo程序的代码和数据到子进程的内存空间中；然后从echo程序的main函数开始执行，参数就是argv（echo hello）；如果exec执行成功，子进程就不再是 shell 的副本了，而是变成了echo程序的进程，之前的runcmd代码也不会再执行（因此printf(“exec error\\n”)不会被打印）。步骤 5：echo程序执行完毕，调用exitecho程序会输出hello，然后调用exit()系统调用：exit会终止子进程，释放资源，并通知父进程（shell）“子进程已完成”。步骤 6：父进程（shell）从wait中返回，继续主循环当子进程调用exit后，父进程（shell）的wait()会返回，解除阻塞状态：父进程会清理子进程的僵尸状态；回到主循环，再次打印提示符，等待用户输入下一条命令。补充：如果exec失败会怎样？如果exec调用失败（比如找不到&#x2F;bin&#x2F;echo文件），子进程不会被替换，会继续执行后续代码，也就是你代码中的printf(“exec error\\n”)，然后子进程会调用exit终止，父进程同样会从wait中返回。为什么参数数组的第一个元素是程序名（argv[0]）？你提到 “多数程序忽略参数数组中的第一个元素”，这是因为：规范约定：Unix&#x2F;Linux 的程序参数规范中，argv[0]默认是程序的名称（或路径），argv[1]及以后才是实际参数；程序自身的需求：有些程序会使用argv[0]，比如ls程序如果被重命名为ll，argv[0]会是ll，程序可以根据argv[0]的不同执行不同的逻辑；xv6 的简化处理：xv6 中的程序（如echo）比较简单，大多忽略argv[0]，只处理argv[1]及以后的参数，但依然遵循这个规范。总结关键点回顾xv6 shell 的核心逻辑：通过fork创建子进程，子进程用exec替换为目标程序，父进程用wait等待子进程结束，这是 Unix 系系统执行程序的经典模式。echo hello的执行流程：shell 主循环读入命令 → fork创建子进程 → 子进程解析命令并构造argv → exec加载&#x2F;bin&#x2F;echo → echo执行并exit → 父进程wait返回并继续循环。argv[0]的作用：是 Unix 规范约定的程序名，多数 xv6 程序忽略它，但构造参数数组时必须保留，且参数数组以NULL结尾。这个流程的本质是分离了 “进程创建”（fork）和 “程序加载”（exec），让 shell 可以作为父进程持续运行，而子进程专门执行用户命令，这也是 shell 能连续接收用户输入的关键。","path":"2025/12/18/xv6-labs-2020-lab1/","date":"12-18","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 我是Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2025/12/17/hello-world/","date":"12-17","excerpt":"","tags":[]}],"categories":[],"tags":[]}