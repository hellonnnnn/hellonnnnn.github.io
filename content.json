{"meta":{"title":"Ivan's Tech Blog","subtitle":"C++ / Linux / System Programming","description":"记录 C++、Linux、系统方向学习与项目","author":"Ivan-FYF","url":"https://hellonnnnn.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-17","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-17","excerpt":""}],"posts":[{"title":"git使用","text":"","path":"2025/12/20/git使用/","date":"12-20","excerpt":"","tags":[]},{"title":"Unix/Linux 管道的工作原理","text":"管道（Pipe）原理与Xv6 shell实现笔记一、管道核心概念1. 定义管道是内核提供的小型缓冲区，通过一对文件描述符（读端p[0]、写端p[1]）暴露给进程，数据从写端写入、读端读取，实现进程间通信（IPC）。 2. 核心特性 半双工：数据仅能从写端流向读端，无法反向传输。 阻塞机制： 管道为空时，read操作阻塞，直到有数据写入或所有写端关闭（此时read返回0，类似文件末尾）。 管道满时（内核缓冲区有限，通常几KB），write操作阻塞，直到数据被读取。 字节流传输：数据无边界，读取方需自行处理分割（如按行、按空格）。 生命周期：所有关联文件描述符关闭后，内核释放管道缓冲区，管道销毁。 二、管道使用示例代码解析1. 完整代码（Unix&#x2F;Linux环境）1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main() &#123; int p[2]; // 管道描述符：p[0]读端，p[1]写端 char *argv[2]; // wc命令参数数组 argv[0] = &quot;wc&quot;; // 命令名 argv[1] = NULL; // 参数数组以NULL结尾（exec要求） // 1. 创建管道 if (pipe(p) == -1) &#123; perror(&quot;pipe&quot;); exit(1); &#125; // 2. 创建子进程 pid_t pid = fork(); if (pid == -1) &#123; perror(&quot;fork&quot;); exit(1); &#125; if (pid == 0) &#123; // 子进程：执行wc，从管道读数据 close(0); // 关闭标准输入（默认终端） dup(p[0]); // 复制管道读端到最小未用描述符（0，即标准输入） close(p[0]); // 关闭原始读端（已重定向，无需保留） close(p[1]); // 必须关闭写端（否则wc认为有进程可能写数据，永久阻塞） execvp(&quot;wc&quot;, argv); // 执行wc，标准输入绑定管道读端 perror(&quot;execvp&quot;); // exec失败时执行 exit(1); &#125; else &#123; // 父进程：向管道写数据 close(p[0]); // 关闭读端（父进程仅写） write(p[1], &quot;hello world\\n&quot;, 12); // 写入数据 close(p[1]); // 关闭写端（让子进程感知数据结束） wait(NULL); // 等待子进程结束，避免僵尸进程 &#125; return 0;&#125; 2. 关键步骤说明 操作 作用 pipe(p) 创建管道，内核分配缓冲区，返回读&#x2F;写描述符 fork() 子进程复制父进程文件描述符表，父子共享管道描述符 子进程close(0) + dup(p[0]) 将管道读端绑定到标准输入（wc从管道读取数据） 子进程close(p[1]) 关闭写端，避免wc永久阻塞 父进程close(p[0]) 关闭读端，避免资源泄漏 父进程close(p[1]) 关闭写端，触发子进程wc的EOF检测 3. 运行结果11 2 12 # 1行、2个单词、12个字符（包含换行符） 三、Xv6 shell管道实现1. 进程树结构Xv6 shell处理cmd1 | cmd2 | cmd3时，会构建进程树： 叶子节点：执行具体命令（如grep、wc）的进程。 内部节点：每个管道|对应一个进程，作用为： 创建管道连接左右命令； fork两个子进程分别运行左右命令； 等待子进程完成后退出。 2. 设计取舍：为何保留内部节点进程？理论上可让内部节点直接运行左&#x2F;右命令（减少进程创建），但会导致逻辑复杂： 若内部进程运行左命令（如echo hi），命令退出后内部进程也退出，无法运行右命令（如wc）； 若内部进程运行右命令（如echo hi），右命令不会等待左命令（如sleep 10）完成，导致时序错误（sleep 10 | echo hi立即输出）。 为保证代码简洁，Xv6 shell选择保留内部节点进程，牺牲少量性能换取逻辑正确性。 四、核心要点总结 管道通过内核缓冲区实现进程间通信，依赖文件描述符重定向； 必须关闭无用的管道描述符（尤其是写端），否则读取进程会永久阻塞； Xv6 shell通过进程树实现多管道命令，内部节点进程负责管道管理和等待子进程； 管道是字节流、半双工，阻塞特性由内核控制。 管道 vs 临时文件：核心优势解析管道与临时文件都能实现“前序命令输出作为后序命令输入”的效果，但管道在自动化、性能、并行性和语义适配性上具备显著优势，以下是详细对比：管道看起来并不比临时文件更强大：下面的管道命令行echo hello world | wc可以不通过管道实现，如下echo hello world &gt; &#x2F;tmp&#x2F;xyz; wc &lt; &#x2F;tmp&#x2F;xyz区别在于： 一、自动清理，无残留风险 临时文件：使用后需手动删除（如rm /tmp/xyz），若程序异常退出（如被中断、崩溃），临时文件会残留，长期积累会占用磁盘空间，甚至导致同名文件覆盖、权限冲突等问题（例如多个进程同时使用/tmp/xyz）。 管道：管道的生命周期与关联进程绑定——当所有读写进程退出、管道描述符全部关闭时，内核会自动释放管道缓冲区，无需人工干预，不存在残留垃圾，也避免了临时文件的命名冲突问题。 二、无需磁盘空间，支持流式传输 临时文件：必须将完整数据写入磁盘文件后，后续程序才能读取，依赖磁盘空闲空间。若传输超大数据流（如GB级日志、视频流），磁盘空间不足会导致操作失败；且磁盘I&#x2F;O速度远低于内存，数据写入&#x2F;读取会产生显著延迟。 管道：数据存储在内核缓冲区（内存中），采用“流式传输”——前序进程写入一部分数据，后序进程即可读取一部分，无需等待完整数据生成。即使传输TB级数据流，只要内核缓冲区能周转，就无需依赖磁盘空间，且内存I&#x2F;O速度远快于磁盘，效率更高。 三、支持并行执行，提升整体效率 临时文件：必须严格串行执行——前序命令（如echo hello world &gt; /tmp/xyz）完全执行并将所有数据写入文件后，后序命令（如wc &lt; /tmp/xyz）才能启动，总耗时为两个命令耗时之和（T总 = T1 + T2）。 管道：前后命令可并行执行——前序进程（echo）写入数据的同时，后序进程（wc）可立即读取并处理，无需等待前序进程结束。例如大型日志生成 | grep 关键词场景中，日志生成到一半时，grep已开始匹配，总耗时接近较慢进程的耗时（T总 ≈ max(T1, T2)），大幅缩短执行时间。 四、阻塞式语义适配进程通信，更高效 临时文件：文件操作的核心语义是“非阻塞”——写入文件后数据持久化，读取时只需从磁盘加载，无需等待写入方；但进程间通信时，若后序进程读取速度快于前序进程写入速度，会出现“读空”（需轮询文件是否有新数据），若前序进程写入速度快，会占用大量磁盘空间，轮询和磁盘I&#x2F;O都会产生额外开销。 管道：管道的阻塞式读写语义完全适配进程间通信需求： 读端阻塞：若管道为空，读进程（如wc）会自动阻塞，直到写进程（如echo）写入数据或所有写端关闭，无需轮询，减少CPU消耗； 写端阻塞：若管道缓冲区满，写进程会阻塞，直到读进程读取数据，避免数据溢出，天然实现“生产-消费”的速率匹配；这种阻塞机制由内核实现，无需用户态代码干预，比文件的轮询&#x2F;非阻塞处理更高效、更简洁。 补充：管道的隐藏优势——无磁盘I&#x2F;O损耗临时文件的所有数据都需经过“内存→磁盘→内存”的两次拷贝（前序进程写磁盘、后序进程读磁盘），而管道数据仅在“进程内存→内核缓冲区→进程内存”之间拷贝，全程无磁盘参与，对于高频、小数据量的进程通信（如shell命令链、程序模块间交互），管道的延迟和资源占用远低于临时文件。","path":"2025/12/20/Unix-Linux-管道的工作原理/","date":"12-20","excerpt":"","tags":[]},{"title":"xv6-labs-2020 lab1","text":"fork + exec：Unix &#x2F; Linux（xv6）执行程序的核心模式12345678910111213141516171819# fork + exec：Unix / xv6 执行程序的核心模型先明确一个核心概念：**fork + exec 是 Unix / Linux（包括 xv6）执行程序的经典模式**。你给出的代码片段中，`exec` 会用目标程序（如 `/bin/echo`）**替换当前进程的代码和数据**，但需要特别注意的是：&gt; **exec 本身不会创建新进程**因此，实际使用中必须先通过 `fork` 创建子进程，再在子进程中调用 `exec`。 这样既能保留父进程（shell），又能让子进程执行新程序，这正是 **xv6 shell 的核心逻辑**。---## xv6 shell 执行 `echo hello` 的完整流程（结合源码）下面以用户在 xv6 shell 中输入：```textecho hello 为例，结合 user/sh.c 的关键位置，拆解整个执行过程。 步骤 1：shell 主循环等待用户输入位置：main()（user/sh.c:145） xv6 的 shell 运行在一个无限循环中，主要完成两件事： 打印命令提示符（如 $ ） 调用 getcmd() 读取用户输入的一行命令 此时： shell 是父进程 处于前台运行状态 等待用户输入命令 步骤 2：创建子进程（fork）当用户输入 echo hello 并回车后，shell 调用： 1int pid = fork(); fork() 会创建一个与当前进程几乎完全相同的子进程： 父进程（shell） fork() 返回子进程的 PID 随后调用 wait() 或 waitpid()，进入阻塞状态 子进程 fork() 返回 0 继续执行后续的命令处理逻辑 关键点： fork 是“复制”，不是重新创建 子进程在 exec 之前与父进程共享相同的代码和数据 步骤 3：子进程调用 runcmd 处理命令位置：runcmd()（user/sh.c:58） 子进程会解析用户输入的命令： 命令名：echo 参数：hello 并构造参数数组 argv： 1234char *argv[3];argv[0] = &quot;echo&quot;; // 程序名argv[1] = &quot;hello&quot;; // 参数argv[2] = 0; // 参数数组必须以 NULL 结尾 同时，runcmd 会确定可执行文件路径，例如： 1/bin/echo 步骤 4：子进程调用 exec 替换程序位置：user/sh.c:78 子进程调用： 1exec(&quot;/bin/echo&quot;, argv); exec 的行为是： 丢弃当前子进程的代码和数据 加载 /bin/echo 的代码和数据 从 echo 程序的 main 函数开始执行 如果 exec 调用成功： 当前进程将不再是 shell 的副本 之前的 runcmd 代码不会再执行 printf(&quot;exec error\\n&quot;) 不会被执行 步骤 5：echo 程序执行并调用 exitecho 程序运行后： 向标准输出打印： 1hello 调用： 1exit(0); 子进程终止，并通知父进程。 步骤 6：父进程（shell）从 wait 返回父进程中的： 1wait(0); 返回后： shell 回收子进程资源 清除僵尸进程 重新回到主循环 再次打印提示符，等待下一条命令 exec 失败时会发生什么？如果： 1exec(&quot;/bin/echo&quot;, argv); 执行失败（如文件不存在），则： 当前进程不会被替换 会继续执行后续代码： 12printf(&quot;exec error\\n&quot;);exit(1); 随后子进程退出，父进程依然会从 wait() 返回。 为什么 argv[0] 是程序名？原因包括： Unix 规范约定 argv[0] 表示程序名 argv[1] 及以后才是实际参数 程序自身可能使用 argv[0] 同一个程序根据启动名执行不同逻辑（如 busybox） xv6 的简化实现 多数 xv6 程序忽略 argv[0] 但依然遵循该参数规范 总结核心结论 fork + exec 是 Unix &#x2F; xv6 执行程序的标准模式 fork 负责创建进程 exec 负责加载并运行新程序 shell 通过 wait 保持自身持续运行 echo hello 的完整链路1234567shell 读取命令→ fork 创建子进程→ 子进程解析命令→ exec 加载 /bin/echo→ echo 输出 hello 并 exit→ 父进程 wait 返回→ shell 继续等待输入 这一设计实现了 进程创建与程序执行的解耦，也是 Unix shell 能持续工作的根本原因。 以下是runcmd函数的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475voidruncmd(struct cmd *cmd)&#123; int p[2]; struct backcmd *bcmd; struct execcmd *ecmd; struct listcmd *lcmd; struct pipecmd *pcmd; struct redircmd *rcmd; if(cmd == 0) exit(1); switch(cmd-&gt;type)&#123; default: panic(&quot;runcmd&quot;); case EXEC: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(1); exec(ecmd-&gt;argv[0], ecmd-&gt;argv); fprintf(2, &quot;exec %s failed\\n&quot;, ecmd-&gt;argv[0]); break; case REDIR: rcmd = (struct redircmd*)cmd; close(rcmd-&gt;fd); if(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; 0)&#123; fprintf(2, &quot;open %s failed\\n&quot;, rcmd-&gt;file); exit(1); &#125; runcmd(rcmd-&gt;cmd); break; case LIST: lcmd = (struct listcmd*)cmd; if(fork1() == 0) runcmd(lcmd-&gt;left); wait(0); runcmd(lcmd-&gt;right); break; case PIPE: pcmd = (struct pipecmd*)cmd; if(pipe(p) &lt; 0) panic(&quot;pipe&quot;); if(fork1() == 0)&#123; close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); &#125; if(fork1() == 0)&#123; close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; case BACK: bcmd = (struct backcmd*)cmd; if(fork1() == 0) runcmd(bcmd-&gt;cmd); break; &#125; exit(0);&#125; 一、函数整体功能总结runcmd是一个递归函数，它接收一个struct cmd类型的命令节点（这个节点是shell解析用户输入后生成的抽象语法树节点），通过switch判断命令的类型（EXEC&#x2F;REDIR&#x2F;LIST&#x2F;PIPE&#x2F;BACK），然后执行对应的逻辑。核心依赖fork1（xv6的fork封装）、exec、pipe、dup、wait等系统调用，实现了Unix shell的核心功能。 二、关键数据结构说明代码中出现的struct cmd及其子结构体是xv6对不同命令的封装，每个子结构体对应一种命令类型： struct execcmd：普通执行命令（如echo hello），包含命令参数数组argv； struct redircmd：重定向命令（如echo hello &gt; file.txt），包含重定向的文件描述符fd、文件名file、打开模式mode，以及被重定向的子命令cmd； struct listcmd：顺序执行命令（如echo hello ; ls），包含左命令left和右命令right； struct pipecmd：管道命令（如ls | grep txt），包含左命令left（管道写端）和右命令right（管道读端）； struct backcmd：后台运行命令（如sleep 10 &amp;），包含后台执行的子命令cmd； cmd-&gt;type：标识命令类型的枚举（EXEC&#x2F;REDIR等）。 三、逐模块解析代码逻辑1. 基础判断：空命令直接退出12if(cmd == 0) exit(1); 如果命令节点为空（解析失败），子进程直接退出，返回错误状态。 2. EXEC：执行普通程序（核心分支，如echo hello）1234567case EXEC: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(1); exec(ecmd-&gt;argv[0], ecmd-&gt;argv); fprintf(2, &quot;exec %s failed\\n&quot;, ecmd-&gt;argv[0]); break; 逻辑拆解： 将cmd强转为execcmd（普通执行命令结构体），获取参数数组argv； 如果argv[0]为空（无命令名），直接退出； 调用exec系统调用，加载并执行argv[0]对应的程序（如/bin/echo），参数为argv； 如果exec返回，说明执行失败（因为成功的exec会替换进程代码，不会返回），此时打印错误信息； 注意：这里的exec是xv6的封装，对应你之前看到的exec(&quot;/bin/echo&quot;, argv)逻辑。 3. REDIR：处理输入输出重定向（如echo hello &gt; file.txt）123456789case REDIR: rcmd = (struct redircmd*)cmd; close(rcmd-&gt;fd); if(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; 0)&#123; fprintf(2, &quot;open %s failed\\n&quot;, rcmd-&gt;file); exit(1); &#125; runcmd(rcmd-&gt;cmd); break; 逻辑拆解（以echo hello &gt; file.txt为例）： rcmd-&gt;fd：要重定向的文件描述符（如stdout是1，stdin是0，stderr是2）； close(rcmd-&gt;fd)：关闭原来的文件描述符（比如关闭stdout（1））； open(rcmd-&gt;file, rcmd-&gt;mode)：打开目标文件（如file.txt，写模式），此时系统会分配最小的可用文件描述符（也就是刚才关闭的1）； 递归调用runcmd(rcmd-&gt;cmd)：执行被重定向的命令（如echo hello），此时命令的输出（原本写向stdout（1））会被重定向到file.txt； 核心原理：利用Unix文件描述符的“最小可用”规则，通过close+open实现重定向（xv6也支持dup实现，逻辑一致）。 4. LIST：处理顺序执行命令（如echo hello ; ls）1234567case LIST: lcmd = (struct listcmd*)cmd; if(fork1() == 0) runcmd(lcmd-&gt;left); wait(0); runcmd(lcmd-&gt;right); break; 逻辑拆解： lcmd-&gt;left：左边的命令（如echo hello），lcmd-&gt;right：右边的命令（如ls）； fork1()创建子进程，子进程执行左命令； 父进程调用wait(0)，阻塞等待左命令执行完毕； 左命令执行完后，父进程再执行右命令； 特点：顺序执行，左命令完成后才会执行右命令。 5. PIPE：处理管道命令（如ls | grep txt）1234567891011121314151617181920212223case PIPE: pcmd = (struct pipecmd*)cmd; if(pipe(p) &lt; 0) panic(&quot;pipe&quot;); if(fork1() == 0)&#123; close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); &#125; if(fork1() == 0)&#123; close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); &#125; close(p[0]); close(p[1]); wait(0); wait(0); break; 这是最复杂的分支，核心是利用pipe创建管道，将左命令的输出作为右命令的输入。 逻辑拆解（以ls | grep txt为例）： 创建管道：pipe(p)创建一个管道，p[0]是读端，p[1]是写端； 处理左命令（ls，管道写端）： fork1()创建子进程1； close(1)：关闭子进程1的stdout（1）； dup(p[1])：复制管道写端p[1]到stdout（1）（因为1是最小可用描述符）； close(p[0])和close(p[1])：关闭多余的管道描述符（只保留重定向后的stdout）； 执行左命令ls，此时ls的输出会写入管道写端p[1]； 处理右命令（grep txt，管道读端）： fork1()创建子进程2； close(0)：关闭子进程2的stdin（0）； dup(p[0])：复制管道读端p[0]到stdin（0）； close(p[0])和close(p[1])：关闭多余的管道描述符； 执行右命令grep txt，此时grep会从管道读端p[0]读取ls的输出； 父进程处理： close(p[0])和close(p[1])：父进程关闭管道描述符（否则子进程退出后管道不会被释放）； wait(0)两次：等待两个子进程都执行完毕； 核心原理：管道是单向的，左进程写管道，右进程读管道，通过dup将管道描述符重定向到标准输入&#x2F;输出。 6. BACK：处理后台运行命令（如sleep 10 &amp;）12345case BACK: bcmd = (struct backcmd*)cmd; if(fork1() == 0) runcmd(bcmd-&gt;cmd); break; 逻辑拆解： fork1()创建子进程，子进程执行后台命令（如sleep 10）； 父进程不调用wait(0)：这是和普通命令的关键区别，父进程（shell）不会阻塞，直接返回继续处理下一条命令； 特点：命令在后台运行，shell无需等待，用户可以立即输入新命令； 注意：xv6的后台处理比较简化，没有处理僵尸进程（实际Unix shell会用信号处理）。 7. 函数末尾：退出进程1exit(0); 无论哪种命令类型执行完毕（除了exec成功的情况，因为exec会替换代码，不会走到这里），子进程都会调用exit(0)退出。 四、总结关键点回顾 核心逻辑：runcmd通过类型判断+递归调用，处理xv6 shell的所有命令类型，依赖fork+exec实现程序执行，依赖pipe+dup实现管道，依赖close+open实现重定向。 各命令类型的核心差异： EXEC：直接exec执行程序，失败则打印错误； REDIR：先重定向文件描述符，再递归执行命令； LIST：fork执行左命令，wait后执行右命令； PIPE：创建管道，两个子进程分别处理左右命令，实现数据传递； BACK：fork执行命令，父进程不wait，后台运行； xv6的简化处理：相比实际Unix shell，xv6的runcmd省略了信号处理（如后台进程的僵尸回收）、通配符解析、环境变量等功能，但保留了shell的核心骨架。 这个函数是xv6 shell的“心脏”，理解它的逻辑就能掌握xv6如何处理用户命令的本质。","path":"2025/12/18/fork+exec执行程序的核心模型/","date":"12-18","excerpt":"","tags":[]}],"categories":[],"tags":[]}